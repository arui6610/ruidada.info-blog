{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/assets/rui.JPG","path":"assets/rui.JPG","modified":0,"renderable":0},{"_id":"themes/yilia/source/style.js","path":"style.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.js","path":"main.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1576822192356},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1576822192357},{"_id":"themes/yilia/README.md","hash":"2e4f07cb1f66bb4eb6be9c9b451d143320912216","modified":1576822292568},{"_id":"themes/yilia/_config.yml","hash":"f22b7b516351f576dc741ec23a136d0064f51ade","modified":1576822292569},{"_id":"themes/yilia/webpack.config.js","hash":"ccf5929d2727b00e76266f9f5d6edc0bc74539dc","modified":1576822292608},{"_id":"themes/yilia/package.json","hash":"00617be92734bd435ec21614c445bed23cf7448d","modified":1576822292574},{"_id":"source/_drafts/iOS-03.md","hash":"9125bffa3dd66ae09fbe2fd020d40d60a0182025","modified":1576822102047},{"_id":"source/_drafts/new-draft.md","hash":"eacfee243330361756e725175b014a328f334d33","modified":1576822102048},{"_id":"source/_posts/MacOS+GitLab+Jenkins构建iOS自动化打包平台教程.md","hash":"1f5af601d376c94e79f429aeb93e4d18d03a57af","modified":1576822102048},{"_id":"source/_posts/VPS_01_01.md","hash":"fd41e77610e42227bdd2a39696ee4997320d5eeb","modified":1576822102048},{"_id":"source/_posts/VPS_02_01.md","hash":"3a46beaafecd9f7a2642f8d667a90cadb31c40f8","modified":1576822102049},{"_id":"source/_posts/VPS_02_02.md","hash":"86c21b5d05c6ffde9cea1fcdeda72b08f14b171d","modified":1576822102049},{"_id":"source/_posts/VPS_02_03.md","hash":"29ff81520d05386b8177570dff7bb9f36afe0cfa","modified":1576822102049},{"_id":"source/_posts/iOS-02.md","hash":"309eaae2b9f62366669c8cd9821fb85b062c41c3","modified":1576822102049},{"_id":"source/_posts/iOS-03.md","hash":"9125bffa3dd66ae09fbe2fd020d40d60a0182025","modified":1576822102049},{"_id":"source/_posts/ios-daily-01.md","hash":"d7d071c05ef8dda9e664ab3400596468abe75f60","modified":1576822102050},{"_id":"source/_posts/iOS-04.md","hash":"b903f83924fba3e2990dd251b94bae4623d08f2c","modified":1576822102050},{"_id":"source/_posts/ios-daily-02.md","hash":"bf4a1d96741e71cfa2ee05e307fb8c2b8cab9cb2","modified":1576822102050},{"_id":"source/_posts/ios_stduy_note_01.md","hash":"f5f9352754dd90cef85a8c188407c5e97b787772","modified":1576822102050},{"_id":"source/_posts/ios_stduy_note_02.md","hash":"2fcf1d1141b28440411a4934ee32261468b404f6","modified":1576822102051},{"_id":"source/_posts/rn-01.md","hash":"7b874926a107335526333b4402f1e43cd8022477","modified":1576822102051},{"_id":"source/_posts/rn-03.md","hash":"a96db08e465e4e54fe92b3f79483fc09da1292e5","modified":1576822102051},{"_id":"source/_posts/rn-02.md","hash":"4031ffcbae2f64548751d686fe2070d91eb5d763","modified":1576822102051},{"_id":"source/assets/rui.JPG","hash":"626829c897743de92ee3d29a0a680415f600767d","modified":1576822102051},{"_id":"source/categories/index.md","hash":"3e0b37efbf95ee4e6e2ac5b206f81636ba58dfe3","modified":1576822102051},{"_id":"source/tags/index.md","hash":"e5a4dd571a99fd878ff16c9d6d112b7c8fb14ce2","modified":1576822102052},{"_id":"themes/yilia/.git/HEAD","hash":"550e0d047f7f2fccf6f50fb3828e50ecafef82ae","modified":1576822292612},{"_id":"source/tagcloud/index.md","hash":"69d097dc8678755b86f0f5d00d7155c893bb63b1","modified":1576822102052},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"9a848657dea76546fc71b7e1a6f593a2bf6084d1","modified":1576823885341},{"_id":"themes/yilia/.git/config","hash":"e01c4ef53c8586bd3e37446a0967d5292d66aed2","modified":1576822292611},{"_id":"themes/yilia/.git/index","hash":"3e2f1a89dd9cd1da613cecf4d661434ab2133694","modified":1576822292609},{"_id":"themes/yilia/.git/packed-refs","hash":"dfdca3a266511ee17ede4ec06cb787d5db1660b4","modified":1576822192348},{"_id":"themes/yilia/.git/sourcetreeconfig","hash":"ca203a658eeb9a761bc0e2aac4c7d793b0870aca","modified":1576823885557},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1576822192358},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1576822192358},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1576822192359},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1576822192358},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1576822192359},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1576822192359},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1576822192359},{"_id":"themes/yilia/layout/categories.ejs","hash":"82df10be9f40448db19229ea3befe07fcd60dd31","modified":1576822292572},{"_id":"themes/yilia/layout/layout.ejs","hash":"18bc94a020c6e74b0a7a29bc412670605e0c0873","modified":1576822292572},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1576822192372},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1576822192372},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1576822192372},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1576822192373},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1576822192374},{"_id":"themes/yilia/layout/tagcloud.ejs","hash":"2e35b2e35a042ae63dfbdbb9d5d9c3d446dfc3d5","modified":1576822292573},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1576822192373},{"_id":"themes/yilia/package-lock.json","hash":"4ccf85bc2508507465643457c9ea6e27e192fa67","modified":1576822292573},{"_id":"themes/yilia/.git/logs/HEAD","hash":"6335ef15925a986f1aa792d8327e3774835acd06","modified":1576822292612},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"8bbedf112605c8aeca10b6e09cfe32f444675282","modified":1576822292569},{"_id":"themes/yilia/source/style.js","hash":"af5208b816c29a0e3006b3509088b1ba4f4779ec","modified":1576822292608},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1576822192359},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1576822192359},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1576822192361},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"038eecdf9b29e6a798ac0ec917e5348e40428ed8","modified":1576822292569},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1576822192361},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"d78993618051392103df1107c0da5abb81e2acac","modified":1576822292570},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"88620efeea181f12cecc44edb8735cfa34ba0052","modified":1576822292570},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"256f83ef8bc7bdc8f69617e606fe1118136b5208","modified":1576822292570},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"324f809c7d1505cbf1ef3a479782c67ae90dfa81","modified":1576822292570},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1576822192361},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c5b92f83828e41a891c6db1d3e63cd2e007034e0","modified":1576822292572},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"6255dfde4a65a191f15f13d4f535a3ef91d45a1f","modified":1576822292572},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1576822192376},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1576822192375},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"b750499d5120f963b683d0c96ac3f345c714e448","modified":1576822292574},{"_id":"themes/yilia/source-src/css/archive-inner.scss","hash":"1d58b3e22486d700228d3668744655dd38466728","modified":1576822292574},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"4edb98e196eac9e67f86b76e39a2a03673391842","modified":1576822292575},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"d046414a96adc400b54897fc236b3272e6deeafd","modified":1576822292575},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"000a5875e1e46116b824c9ac0657178093ce4a17","modified":1576822292575},{"_id":"themes/yilia/source-src/css/article.scss","hash":"b1add6b3c05416ac854ec5dd9d4cc20be3fafc1f","modified":1576822292575},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"1a4be8634b8dcf271cebad1feb687e96a038ffbf","modified":1576822292576},{"_id":"themes/yilia/source-src/css/categories.scss","hash":"cd6b24f9b59fdbe566b38ba9391eb0592f575e28","modified":1576822292576},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"f5ee21869fcd3e2b257b49b0f680c78763d416dd","modified":1576822292576},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1576822192384},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1576822192384},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"fe592c32cc2e6462358ac907e1e38a0dad01219f","modified":1576822292578},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"819774a2979d0d94eb4e3ebf62afc96f803bac67","modified":1576822292578},{"_id":"themes/yilia/source-src/css/ins.scss","hash":"4ae283a384088192de3afab83992801d432434d4","modified":1576822292584},{"_id":"themes/yilia/source-src/css/left.scss","hash":"2a261fa2e402909a866c648a5de8eb287da6fba9","modified":1576822292584},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9be4f8647d2cf739dcfc20666d5a38726faab1a6","modified":1576822292585},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"4277e4b7e8fef5480d8e2b9574cbfdf59f0225c8","modified":1576822292585},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"b64c70b7ccb7847745e769c896663dd204dea861","modified":1576822292585},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1576822192389},{"_id":"themes/yilia/source-src/css/social.scss","hash":"5b4a2cfd8a26687dc7bc44a4fa55ebb7d1ffe363","modified":1576822292586},{"_id":"themes/yilia/source-src/css/style.js","hash":"6c4cb072d0d5cbbb5291aa255dee31c7b13cfe66","modified":1576822292586},{"_id":"themes/yilia/source-src/css/switch.scss","hash":"795b0d1ad5ff278933409a1ab7451483fe6ceae5","modified":1576822292586},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1576822192390},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"79d3fad4fcda15210410774089b0ee7fe8d58810","modified":1576822292586},{"_id":"themes/yilia/source-src/css/toc-article.scss","hash":"78eb3317e0d466384cd65388e01f8f5e1a6521b4","modified":1576822292587},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1576822192391},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"c92aa91195696d1f2e5280a8db358593068e5e76","modified":1576822292587},{"_id":"themes/yilia/source-src/js/archive-inner.js","hash":"76dc705f483dc476144eee1d0a6d362e62300bb8","modified":1576822292592},{"_id":"themes/yilia/source-src/js/browser.js","hash":"8ca48b006591bbf6d75688637c14fd1b5bdd650f","modified":1576822292592},{"_id":"themes/yilia/source-src/js/jquery.lazyload.js","hash":"37961302284435b2677b7fd1e0c0f7624e226e4a","modified":1576822292596},{"_id":"themes/yilia/source-src/js/fix-page.js","hash":"f18e33e99b1032b95a60b018960bed64235c1a29","modified":1576822292593},{"_id":"themes/yilia/source-src/js/ins.js","hash":"bec3fe48fd17b078035163bcc474b6ea480536b0","modified":1576822292593},{"_id":"themes/yilia/source-src/js/main.js","hash":"eae1232ff87bcdff224bb3ede88a092683fb4ce5","modified":1576822292596},{"_id":"themes/yilia/source-src/js/tags.js","hash":"f259b3f808df3a8523a42978f922bb9eda76e0ee","modified":1576822292597},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"a3d10a3e01749b005c65f0aa79a31628108b5a41","modified":1576822292597},{"_id":"themes/yilia/source-src/js/util.js","hash":"28c66c54cab81b2a6c8c393226f5bd30f369e1bb","modified":1576822292597},{"_id":"themes/yilia/source-src/js/tools.js","hash":"ed69771cd501770c2c303ae6ae695d2a9a187cdd","modified":1576822292597},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"4024ba3b9c6b1454715cf93658dd4849a048d548","modified":1576822292597},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe-ui-default.js","hash":"724162c14e5722a2ce1f44cf086dcea7b6855b80","modified":1576822292598},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe-ui-default.min.js","hash":"38557bef17c33e172bc8e1670cd302d91622dfad","modified":1576822292599},{"_id":"themes/yilia/source-src/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1576822292587},{"_id":"themes/yilia/source-src/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1576822292588},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe.scss","hash":"838d43529282b91a60934bbd39f3f9f5dbefee98","modified":1576822292601},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe.min.js","hash":"e3267f5ae23f00c1ae052d019f12787296e34afc","modified":1576822292600},{"_id":"themes/yilia/source-src/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1576822292589},{"_id":"themes/yilia/source-src/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1576822292588},{"_id":"themes/yilia/source-src/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1576822292588},{"_id":"themes/yilia/source-src/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1576822292589},{"_id":"themes/yilia/source-src/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1576822292592},{"_id":"themes/yilia/source-src/fancybox/jquery.fancybox.scss","hash":"053a09e0513c6ddf4d950c984e0e14b1ca98af98","modified":1576822292592},{"_id":"themes/yilia/source-src/fancybox/jquery.fancybox.js","hash":"c9229126dd986878283ec2f8d53aa45afc9fb7a9","modified":1576822292591},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe.js","hash":"ff9e3cc58b44a61144a9e211503755b170c24e91","modified":1576822292600},{"_id":"themes/yilia/.git/refs/heads/myself","hash":"6da0193a1a3ecbd6637a0ac1fa3fb9915889d976","modified":1576822292610},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1576822192350},{"_id":"themes/yilia/.git/objects/pack/pack-3445cadc1823f215af1662c2c9ad4e564ce716a1.idx","hash":"c9e2696b2091ee635caddf781dd4c1fda22ef1a7","modified":1576822192338},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"62cde65a4ab7aef85a4390308bc7608f59463e02","modified":1576822292571},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"2ab4308d013dcb1f0898cf112e3f75573e597e33","modified":1576822292571},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1576822192364},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1576822192363},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"d9fa04c06319510bd088ca9c286af947da3cfb38","modified":1576822292571},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"a59c83e46aaccb053b60bb41369dfcd6848cbd69","modified":1576822292571},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"3a44b657ebdeed1764d90f81b43e91e5a8f25c21","modified":1576822292571},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1576822192367},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"6f44ec8ff32515280c0b7ea8ad7e4cb5f4dfcd84","modified":1576822292576},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1576822192379},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1576822192381},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1576822192380},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"dc89a3b360881584838cdd9b95fe88aae6518e50","modified":1576822292576},{"_id":"themes/yilia/source-src/css/fonts/icomoon.eot","hash":"9a661069e1255d10032926a8ef87502f445f4e20","modified":1576822292577},{"_id":"themes/yilia/source-src/css/fonts/icomoon.ttf","hash":"9f1e824fc076dbfedf186609a2664558d5e3e986","modified":1576822292577},{"_id":"themes/yilia/source-src/css/fonts/icomoon.woff","hash":"a5c2eb785800a3a0aeaf2284d191d69df1893d6d","modified":1576822292578},{"_id":"themes/yilia/source-src/css/fonts/icomoon.svg","hash":"56ba63db8bfe20347e0457b4c583dd18e29ca701","modified":1576822292577},{"_id":"themes/yilia/source-src/css/img/black-scales.png","hash":"243ea748d016704922ccfc0b6c18d97472c27bff","modified":1576822292581},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1576822192386},{"_id":"themes/yilia/source-src/css/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1576822292581},{"_id":"themes/yilia/source-src/css/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1576822292582},{"_id":"themes/yilia/source-src/css/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1576822292582},{"_id":"themes/yilia/source-src/css/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1576822292582},{"_id":"themes/yilia/source-src/css/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1576822292582},{"_id":"themes/yilia/source-src/css/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1576822292582},{"_id":"themes/yilia/source-src/css/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1576822292582},{"_id":"themes/yilia/source-src/css/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1576822292583},{"_id":"themes/yilia/source-src/css/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1576822292583},{"_id":"themes/yilia/source-src/css/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1576822292583},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1576822192386},{"_id":"themes/yilia/source-src/css/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1576822292583},{"_id":"themes/yilia/source-src/css/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1576822292583},{"_id":"themes/yilia/source-src/css/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1576822292583},{"_id":"themes/yilia/source-src/css/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1576822292583},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/default-skin.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1576822292598},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1576822292598},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/default-skin.scss","hash":"91f44576a5f5ccff4740ff5020656bd2f00ca13c","modified":1576822292598},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1576822292598},{"_id":"themes/yilia/source-src/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1576822292589},{"_id":"themes/yilia/source-src/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1576822292590},{"_id":"themes/yilia/source-src/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1576822292590},{"_id":"themes/yilia/source-src/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1576822292590},{"_id":"themes/yilia/source-src/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1576822292591},{"_id":"themes/yilia/source-src/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1576822292591},{"_id":"themes/yilia/source-src/css/img/black-paper.png","hash":"a180d3109a5cb6b9b9aa60d81730446ebe275473","modified":1576822292580},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"953927fdf280eb1e37853729c8642c669b2cf96a","modified":1576822192351},{"_id":"themes/yilia/.git/logs/refs/heads/myself","hash":"3628889ab979e5f4391e07824bc9a67d655ecd36","modified":1576822292610},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1576822192349},{"_id":"themes/yilia/source/main.js","hash":"1e21f15b37c2ad0821ae64ceb08da99fae055663","modified":1576822292605},{"_id":"themes/yilia/source-src/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1576822292596},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"953927fdf280eb1e37853729c8642c669b2cf96a","modified":1576822192349},{"_id":"themes/yilia/.git/objects/pack/pack-3445cadc1823f215af1662c2c9ad4e564ce716a1.pack","hash":"e64db41255b06151285c82643fa7dcd6b9e712f6","modified":1576822192337},{"_id":"public/categories/index.html","hash":"1b6034d59df977fa98c8e2ca275f0fcdd1642c25","modified":1576824959214},{"_id":"public/tags/index.html","hash":"757c8b6af17e8a27bcb3c3fed8fc79a56656a3a3","modified":1576824959214},{"_id":"public/tagcloud/index.html","hash":"1451f4204d56eaacb89b59ac4b427f925449936f","modified":1576824959215},{"_id":"public/2016/01/10/ios-daily-01/index.html","hash":"8b452e9f2f1cbe26ce2873c878fda6434369e851","modified":1576824959215},{"_id":"public/archives/page/2/index.html","hash":"597fb10fc1557e8e92e3b40a2b0afcd1ff1d3e8f","modified":1576824959215},{"_id":"public/archives/2015/index.html","hash":"3ab3bb4d3f8aac6b1be43ebc5531ac40992cd229","modified":1576824959215},{"_id":"public/archives/2015/05/index.html","hash":"cf60d42681b44a81239be269d1013ac2f1944471","modified":1576824959215},{"_id":"public/archives/2016/index.html","hash":"bb34915cf43a33573ae94b2fbb7219fbe8c2ac1f","modified":1576824959215},{"_id":"public/archives/2016/01/index.html","hash":"cf4c45e2bfda260c4d71c883ceb0f3c5ea94c1fa","modified":1576824959215},{"_id":"public/archives/2016/05/index.html","hash":"0cbf56b11b64fbd4c89373fb5072948a02f9b76a","modified":1576824959215},{"_id":"public/archives/2016/07/index.html","hash":"38ebd89ba07d2cb98c5c58818bf965c7b186ba0b","modified":1576824959215},{"_id":"public/archives/2016/09/index.html","hash":"4cdc2dd8572a2ad350b8fa65d3ad654c2a33d18d","modified":1576824959215},{"_id":"public/archives/2017/index.html","hash":"dd0a3161e2ac5709c367a3e7b30b5aa4ac8d46a0","modified":1576824959215},{"_id":"public/archives/2017/03/index.html","hash":"b9d6e42f73e6312812e206c7d2058979c1b81999","modified":1576824959215},{"_id":"public/archives/2017/08/index.html","hash":"5f24ce0596aa2d3d071d65f051480c2d8d27dbdf","modified":1576824959216},{"_id":"public/archives/2017/11/index.html","hash":"e40d641c9fefca7b24bda9e0b61ac4df4610a9e4","modified":1576824959216},{"_id":"public/archives/2017/12/index.html","hash":"d52c608b2a17f79adb62dcbc64948962f88c766f","modified":1576824959216},{"_id":"public/categories/教程/index.html","hash":"cc7aeceb6115e537a44c167b15d0ce5b6bc0a301","modified":1576824959216},{"_id":"public/categories/技术/iOS/index.html","hash":"ac30285e0f8e9b00710979bf1d9d2cbc123ad959","modified":1576824959216},{"_id":"public/categories/教程/Hexo/index.html","hash":"b44f4b6f03f35d9155eb3f0409da4a1cee9da456","modified":1576824959216},{"_id":"public/categories/教程/工具/index.html","hash":"78c8d355e678388124dc9f9b5e0ffdf7c28f81b5","modified":1576824959216},{"_id":"public/categories/教程/Jenkins/index.html","hash":"676b9520068c74334fb534af4f414c594c08a02d","modified":1576824959216},{"_id":"public/categories/技术/OC/index.html","hash":"5bf1a2461f7bfec1147822e8237c0cd26d8d2ee6","modified":1576824959216},{"_id":"public/categories/技术/React-Native/index.html","hash":"3c9e93ec53e3a54b067259037c1326f46059e57f","modified":1576824959216},{"_id":"public/categories/教程/工具/VPS/index.html","hash":"20d4c22fde5820c99f2e738052e16469fc937240","modified":1576824959216},{"_id":"public/tags/教程/index.html","hash":"509f10470ab02fee5be6402734a5222b978eb9b4","modified":1576824959216},{"_id":"public/tags/iOS/index.html","hash":"289bc8fa054a610398cd9dd5d6e8d9ddb5211e8d","modified":1576824959216},{"_id":"public/tags/工具/index.html","hash":"d40fc96a92ff9762ebe5426b75da962a50a4499b","modified":1576824959216},{"_id":"public/tags/VPS/index.html","hash":"e25c2a027f265676f8e5c7338e006420fa43a6c5","modified":1576824959216},{"_id":"public/tags/hexo/index.html","hash":"fa5166bb620f36ca950f6159501932a3f977952f","modified":1576824959217},{"_id":"public/tags/Jenkins/index.html","hash":"c29715e4040cd59e8a057337e1d61804c7d1755d","modified":1576824959217},{"_id":"public/tags/日常/index.html","hash":"2b473cfd22034dc730b27483b1abc823253fd0c6","modified":1576824959217},{"_id":"public/tags/OC/index.html","hash":"7da1e06853b966434d1f86a9055b788f0c5c1fa5","modified":1576824959217},{"_id":"public/tags/笔记/index.html","hash":"f1cbfd852e24243b2c23bbeb1f1621bd1852d9cc","modified":1576824959217},{"_id":"public/tags/React-Native/index.html","hash":"fa18f52556a7c3e6d8d648284a241dc021bbfad6","modified":1576824959217},{"_id":"public/2017/12/03/MacOS+GitLab+Jenkins构建iOS自动化打包平台教程/index.html","hash":"377a4cbf7b15911a80d3f7340d9667c051ee37d7","modified":1576824959217},{"_id":"public/2017/11/22/VPS_02_03/index.html","hash":"d066aeeeed70c3985068e9fc3288420038681c7d","modified":1576824959217},{"_id":"public/2017/11/20/VPS_02_02/index.html","hash":"d152e2c015e0326abca8658735977b947603f116","modified":1576824959217},{"_id":"public/2017/11/19/VPS_02_01/index.html","hash":"1ed59a0964d74b81f4097ca9efa262d3370d5d47","modified":1576824959217},{"_id":"public/2017/11/05/VPS_01_01/index.html","hash":"b51e1778ad66477af1376ca02c7f2d0b2fffea5c","modified":1576824959217},{"_id":"public/2017/08/19/iOS-04/index.html","hash":"34cf2dd98a131b7f2befeed6110f20f9615de335","modified":1576824959218},{"_id":"public/2017/03/10/ios-daily-02/index.html","hash":"05bd18e18c4c3e8a5e92ff30dacbac9d413aedcd","modified":1576824959218},{"_id":"public/2016/09/18/rn-03/index.html","hash":"f56f688ebfa4fae48164f905e4a9c27bde4f9fc8","modified":1576824959218},{"_id":"public/2016/09/11/rn-02/index.html","hash":"b3ecbafff0ef1dda9c07961d34bb0d267ca87840","modified":1576824959218},{"_id":"public/2016/07/20/rn-01/index.html","hash":"4f3abce393f358edeb90fe4b0e03553606715403","modified":1576824959218},{"_id":"public/2016/05/10/iOS-03/index.html","hash":"99eb19cacdfbf0b441b225f353638d29ac942b2c","modified":1576824959218},{"_id":"public/2016/05/10/iOS-02/index.html","hash":"c85bd8c6b4683e72453123ca8c299a028e65ab80","modified":1576824959218},{"_id":"public/2015/05/10/ios_stduy_note_01/index.html","hash":"5c8f4d4937d03a3a643b35e9501b50903084b03b","modified":1576824959218},{"_id":"public/2015/05/11/ios_stduy_note_02/index.html","hash":"07f7bc2009b34b68a49055ad1c96da908edb636b","modified":1576824959218},{"_id":"public/archives/index.html","hash":"084543dd3610ab18d115ed5d83e0cd53ae6dbb3f","modified":1576824959218},{"_id":"public/categories/技术/index.html","hash":"9361e669c0de4f6d500b8e20c8e775f0de2c4cce","modified":1576824959218},{"_id":"public/index.html","hash":"cd235abbbd72b50a0623b9803963fc09834a95a4","modified":1576824959218},{"_id":"public/page/2/index.html","hash":"75625ab826565475fd6abbb705c7dda0e84e5392","modified":1576824959219},{"_id":"public/tags/技术/index.html","hash":"e4491e4d010fe59d885f73308764897ba4a6e173","modified":1576824959219}],"Category":[{"name":"技术","_id":"ck4dsux2v0006odnqmarwvtus"},{"name":"教程","_id":"ck4dsux2z000bodnqhnky1zyp"},{"name":"iOS","parent":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux38000qodnq5rftugde"},{"name":"Hexo","parent":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3b000wodnqto9f2ytb"},{"name":"工具","parent":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3e0013odnq6n8g2f50"},{"name":"Jenkins","parent":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3m0020odnqge2onnvj"},{"name":"OC","parent":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3n0026odnqxb2xazv8"},{"name":"React Native","parent":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3p002iodnq3y1kahgg"},{"name":"VPS","parent":"ck4dsux3e0013odnq6n8g2f50","_id":"ck4dsux3q002oodnq3dhzr9vc"}],"Data":[],"Page":[{"title":"文章分类","date":"2018-06-11T02:13:21.000Z","type":"categories","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-06-11 10:13:21\ntype: \"categories\"\nlayout: \"categories\"\ncomments: false\n---\n","updated":"2019-12-20T06:08:22.051Z","path":"categories/index.html","_id":"ck4dsux2r0001odnqadm8b4mc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-04-25T14:34:08.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-04-25 22:34:08\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2019-12-20T06:08:22.052Z","path":"tags/index.html","comments":1,"_id":"ck4dsux2t0003odnqngxwo0fg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章标签","date":"2018-06-11T02:13:21.000Z","type":"tagcloud","layout":"tagcloud","comments":0,"_content":"","source":"tagcloud/index.md","raw":"---\ntitle: 文章标签\ndate: 2018-06-11 10:13:21\ntype: \"tagcloud\"\nlayout: \"tagcloud\"\ncomments: false\n---\n","updated":"2019-12-20T06:08:22.052Z","path":"tagcloud/index.html","_id":"ck4dsux2v0007odnqlwa2t29y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"Main函数之前的那些事儿02：App启动速度优化","date":"2016-05-10T05:36:00.000Z","_content":"> **公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间**\n>\n> - main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间\n> - main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。\n\n## 分析\n\n尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。\n\n### **+load优化思路**\n\n<!-- more -->\n\n* 在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。\n* 加载时机（分为3个时刻）\n  1. 系统调用完所有class的load方法之后，且在main函数执行之前。（__attribute__((constructor))）\n  2. 程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）\n  3. 程序didFinishLaunch之后。（在2之后延迟5s）\n* 结合GCD实现同步异步执行\n  有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）\n* 优先级问题\n  同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）\n\n## **demo**\n\n```\n//\n//  XRLoadManager.h\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import <Foundation/Foundation.h>\ntypedef NS_ENUM(NSUInteger, LoadAt) {\n    /**\n     *  准备执行main函数，优先级最高\n     */\n    LoadAtPreMain = 0,\n    /**\n     *  应用进入活跃状态, 在PreMain之后\n     */\n    LoadAtAppLaunched,\n    /**\n     *  遥远的时间, 大致在 becomeActive 执行完后 5s\n     */\n    LoadAtIdleTime,\n    \n    /////\n    LoadAtN\n};\n\n@interface XRLoadManager : NSObject\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;\n\n@end\n\n```\n\n```\n//\n//  XRLoadManager.m\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import \"XRLoadManager.h\"\n#import <UIKit/UIKit.h>\n#import <Foundation/Foundation.h>\n\n@interface _XRLoadObject : NSObject\n@property (nonatomic, assign) LoadAt at;\n@property (nonatomic, assign) NSInteger sort;\n@property (nonatomic, assign) BOOL mainThread;\n@property (nonatomic, copy) void (^block) (void);\n@end\n\n@implementation _XRLoadObject\n\n@end\n\n@implementation XRLoadManager\nstatic NSMutableArray *loadables[LoadAtN];\n\n\n+ (void)load_init {\n    static dispatch_once_t once;\n    dispatch_once(&once, ^{\n        for (int i = 0; i < LoadAtN; i++) {\n            loadables[i] = [NSMutableArray array];\n        }\n    });\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];\n}\n\n+ (void)load_deInit {\n    for (int i = 0; i < LoadAtN; i++) {\n        NSMutableArray *array = loadables[i];\n        [array removeAllObjects];\n    }\n}\n\n+ (void)handleAppLaunched:(NSNotification *)note {\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    \n    [self run_launched];\n    \n    // run idle\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^{\n        [self run_idleTime];\n        [self load_deInit];\n    });\n}\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:NO block:block];\n}\n\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:YES block:block];\n}\n\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block {\n    [self load_some:at sort:sort mainthread:YES block:block];\n}\n\n+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block {\n    assert(block);\n    _XRLoadObject *obj = [[_XRLoadObject alloc] init];\n    obj.at = at;\n    obj.sort = sort;\n    obj.mainThread = mainthread;\n    obj.block = block;\n    [self load_init];\n    [loadables[at] addObject:obj];\n}\n\n+ (void)run_preMain {\n    [self run_block_array:LoadAtPreMain];\n}\n\n+ (void)run_launched {\n    [self run_block_array:LoadAtAppLaunched];\n}\n\n+ (void)run_idleTime {\n    [self run_block_array:LoadAtIdleTime];\n}\n\n+ (void)run_block_array:(LoadAt)at {\n    \n    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) {\n        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) {\n            if (!obj1.mainThread && obj2.mainThread) {\n                return NSOrderedDescending;\n            }\n            if (obj1.mainThread && !obj2.mainThread) {\n                return NSOrderedAscending;\n            }\n            if (obj1.sort > obj2.sort) {\n                return NSOrderedDescending;\n            }\n            if (obj1.sort == obj2.sort) {\n                return NSOrderedSame;\n            }\n            return NSOrderedAscending;\n        }];\n        for (_XRLoadObject *obj in array) {\n            if (obj.mainThread) {\n                if ([NSThread isMainThread]) {\n                    obj.block();\n                } else {\n                    dispatch_async(dispatch_get_main_queue(), obj.block);\n                }\n            } else {\n                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);\n            }\n        }\n    };\n    if (at == LoadAtPreMain) {\n        sortLoadBlock(loadables[LoadAtPreMain]);\n    }else if (at == LoadAtAppLaunched) {\n        sortLoadBlock(loadables[LoadAtAppLaunched]);\n    }else if (at == LoadAtIdleTime) {\n        sortLoadBlock(loadables[LoadAtIdleTime]);\n    }\n    \n}\n\n@end\n\n__attribute__((constructor))\nstatic void initlize(void) {\n    [XRLoadManager run_preMain];\n}\n```\n","source":"_drafts/iOS-03.md","raw":"---\nlayout: post\ntitle: \"Main函数之前的那些事儿02：App启动速度优化\"\ndate: 2016-05-10 13:36\ncategories: \n- 技术\n- [技术, iOS]\ntags: \n- 技术\n- iOS\n---\n> **公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间**\n>\n> - main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间\n> - main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。\n\n## 分析\n\n尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。\n\n### **+load优化思路**\n\n<!-- more -->\n\n* 在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。\n* 加载时机（分为3个时刻）\n  1. 系统调用完所有class的load方法之后，且在main函数执行之前。（__attribute__((constructor))）\n  2. 程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）\n  3. 程序didFinishLaunch之后。（在2之后延迟5s）\n* 结合GCD实现同步异步执行\n  有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）\n* 优先级问题\n  同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）\n\n## **demo**\n\n```\n//\n//  XRLoadManager.h\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import <Foundation/Foundation.h>\ntypedef NS_ENUM(NSUInteger, LoadAt) {\n    /**\n     *  准备执行main函数，优先级最高\n     */\n    LoadAtPreMain = 0,\n    /**\n     *  应用进入活跃状态, 在PreMain之后\n     */\n    LoadAtAppLaunched,\n    /**\n     *  遥远的时间, 大致在 becomeActive 执行完后 5s\n     */\n    LoadAtIdleTime,\n    \n    /////\n    LoadAtN\n};\n\n@interface XRLoadManager : NSObject\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;\n\n@end\n\n```\n\n```\n//\n//  XRLoadManager.m\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import \"XRLoadManager.h\"\n#import <UIKit/UIKit.h>\n#import <Foundation/Foundation.h>\n\n@interface _XRLoadObject : NSObject\n@property (nonatomic, assign) LoadAt at;\n@property (nonatomic, assign) NSInteger sort;\n@property (nonatomic, assign) BOOL mainThread;\n@property (nonatomic, copy) void (^block) (void);\n@end\n\n@implementation _XRLoadObject\n\n@end\n\n@implementation XRLoadManager\nstatic NSMutableArray *loadables[LoadAtN];\n\n\n+ (void)load_init {\n    static dispatch_once_t once;\n    dispatch_once(&once, ^{\n        for (int i = 0; i < LoadAtN; i++) {\n            loadables[i] = [NSMutableArray array];\n        }\n    });\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];\n}\n\n+ (void)load_deInit {\n    for (int i = 0; i < LoadAtN; i++) {\n        NSMutableArray *array = loadables[i];\n        [array removeAllObjects];\n    }\n}\n\n+ (void)handleAppLaunched:(NSNotification *)note {\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    \n    [self run_launched];\n    \n    // run idle\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^{\n        [self run_idleTime];\n        [self load_deInit];\n    });\n}\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:NO block:block];\n}\n\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:YES block:block];\n}\n\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block {\n    [self load_some:at sort:sort mainthread:YES block:block];\n}\n\n+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block {\n    assert(block);\n    _XRLoadObject *obj = [[_XRLoadObject alloc] init];\n    obj.at = at;\n    obj.sort = sort;\n    obj.mainThread = mainthread;\n    obj.block = block;\n    [self load_init];\n    [loadables[at] addObject:obj];\n}\n\n+ (void)run_preMain {\n    [self run_block_array:LoadAtPreMain];\n}\n\n+ (void)run_launched {\n    [self run_block_array:LoadAtAppLaunched];\n}\n\n+ (void)run_idleTime {\n    [self run_block_array:LoadAtIdleTime];\n}\n\n+ (void)run_block_array:(LoadAt)at {\n    \n    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) {\n        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) {\n            if (!obj1.mainThread && obj2.mainThread) {\n                return NSOrderedDescending;\n            }\n            if (obj1.mainThread && !obj2.mainThread) {\n                return NSOrderedAscending;\n            }\n            if (obj1.sort > obj2.sort) {\n                return NSOrderedDescending;\n            }\n            if (obj1.sort == obj2.sort) {\n                return NSOrderedSame;\n            }\n            return NSOrderedAscending;\n        }];\n        for (_XRLoadObject *obj in array) {\n            if (obj.mainThread) {\n                if ([NSThread isMainThread]) {\n                    obj.block();\n                } else {\n                    dispatch_async(dispatch_get_main_queue(), obj.block);\n                }\n            } else {\n                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);\n            }\n        }\n    };\n    if (at == LoadAtPreMain) {\n        sortLoadBlock(loadables[LoadAtPreMain]);\n    }else if (at == LoadAtAppLaunched) {\n        sortLoadBlock(loadables[LoadAtAppLaunched]);\n    }else if (at == LoadAtIdleTime) {\n        sortLoadBlock(loadables[LoadAtIdleTime]);\n    }\n    \n}\n\n@end\n\n__attribute__((constructor))\nstatic void initlize(void) {\n    [XRLoadManager run_preMain];\n}\n```\n","slug":"iOS-03","published":0,"updated":"2019-12-20T06:08:22.047Z","comments":1,"photos":[],"link":"","_id":"ck4dsux2o0000odnqx2wdm4d9","content":"<blockquote>\n<p><strong>公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间</strong></p>\n<ul>\n<li>main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间</li>\n<li>main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li>\n</ul>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</p>\n<h3 id=\"load优化思路\"><a href=\"#load优化思路\" class=\"headerlink\" title=\"+load优化思路\"></a><strong>+load优化思路</strong></h3><a id=\"more\"></a>\n<ul>\n<li>在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。</li>\n<li>加载时机（分为3个时刻）<ol>\n<li>系统调用完所有class的load方法之后，且在main函数执行之前。（<strong>attribute</strong>((constructor))）</li>\n<li>程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）</li>\n<li>程序didFinishLaunch之后。（在2之后延迟5s）</li>\n</ol>\n</li>\n<li>结合GCD实现同步异步执行<br>有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）</li>\n<li>优先级问题<br>同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）</li>\n</ul>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a><strong>demo</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.h</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">typedef NS_ENUM(NSUInteger, LoadAt) &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  准备执行main函数，优先级最高</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtPreMain = 0,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  应用进入活跃状态, 在PreMain之后</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtAppLaunched,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  遥远的时间, 大致在 becomeActive 执行完后 5s</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtIdleTime,</span><br><span class=\"line\">    </span><br><span class=\"line\">    /////</span><br><span class=\"line\">    LoadAtN</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XRLoadManager : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.m</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;XRLoadManager.h&quot;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface _XRLoadObject : NSObject</span><br><span class=\"line\">@property (nonatomic, assign) LoadAt at;</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger sort;</span><br><span class=\"line\">@property (nonatomic, assign) BOOL mainThread;</span><br><span class=\"line\">@property (nonatomic, copy) void (^block) (void);</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation _XRLoadObject</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XRLoadManager</span><br><span class=\"line\">static NSMutableArray *loadables[LoadAtN];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_init &#123;</span><br><span class=\"line\">    static dispatch_once_t once;</span><br><span class=\"line\">    dispatch_once(&amp;once, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">            loadables[i] = [NSMutableArray array];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_deInit &#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">        NSMutableArray *array = loadables[i];</span><br><span class=\"line\">        [array removeAllObjects];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)handleAppLaunched:(NSNotification *)note &#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self run_launched];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // run idle</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        [self run_idleTime];</span><br><span class=\"line\">        [self load_deInit];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:NO block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:sort mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block &#123;</span><br><span class=\"line\">    assert(block);</span><br><span class=\"line\">    _XRLoadObject *obj = [[_XRLoadObject alloc] init];</span><br><span class=\"line\">    obj.at = at;</span><br><span class=\"line\">    obj.sort = sort;</span><br><span class=\"line\">    obj.mainThread = mainthread;</span><br><span class=\"line\">    obj.block = block;</span><br><span class=\"line\">    [self load_init];</span><br><span class=\"line\">    [loadables[at] addObject:obj];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_preMain &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtPreMain];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_launched &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtAppLaunched];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_idleTime &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtIdleTime];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_block_array:(LoadAt)at &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) &#123;</span><br><span class=\"line\">        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) &#123;</span><br><span class=\"line\">            if (!obj1.mainThread &amp;&amp; obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.mainThread &amp;&amp; !obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedAscending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort &gt; obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort == obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return NSOrderedAscending;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        for (_XRLoadObject *obj in array) &#123;</span><br><span class=\"line\">            if (obj.mainThread) &#123;</span><br><span class=\"line\">                if ([NSThread isMainThread]) &#123;</span><br><span class=\"line\">                    obj.block();</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dispatch_async(dispatch_get_main_queue(), obj.block);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if (at == LoadAtPreMain) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtPreMain]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtAppLaunched) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtAppLaunched]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtIdleTime) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtIdleTime]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((constructor))</span><br><span class=\"line\">static void initlize(void) &#123;</span><br><span class=\"line\">    [XRLoadManager run_preMain];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间</strong></p>\n<ul>\n<li>main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间</li>\n<li>main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li>\n</ul>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</p>\n<h3 id=\"load优化思路\"><a href=\"#load优化思路\" class=\"headerlink\" title=\"+load优化思路\"></a><strong>+load优化思路</strong></h3>","more":"<ul>\n<li>在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。</li>\n<li>加载时机（分为3个时刻）<ol>\n<li>系统调用完所有class的load方法之后，且在main函数执行之前。（<strong>attribute</strong>((constructor))）</li>\n<li>程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）</li>\n<li>程序didFinishLaunch之后。（在2之后延迟5s）</li>\n</ol>\n</li>\n<li>结合GCD实现同步异步执行<br>有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）</li>\n<li>优先级问题<br>同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）</li>\n</ul>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a><strong>demo</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.h</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">typedef NS_ENUM(NSUInteger, LoadAt) &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  准备执行main函数，优先级最高</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtPreMain = 0,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  应用进入活跃状态, 在PreMain之后</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtAppLaunched,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  遥远的时间, 大致在 becomeActive 执行完后 5s</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtIdleTime,</span><br><span class=\"line\">    </span><br><span class=\"line\">    /////</span><br><span class=\"line\">    LoadAtN</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XRLoadManager : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.m</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;XRLoadManager.h&quot;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface _XRLoadObject : NSObject</span><br><span class=\"line\">@property (nonatomic, assign) LoadAt at;</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger sort;</span><br><span class=\"line\">@property (nonatomic, assign) BOOL mainThread;</span><br><span class=\"line\">@property (nonatomic, copy) void (^block) (void);</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation _XRLoadObject</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XRLoadManager</span><br><span class=\"line\">static NSMutableArray *loadables[LoadAtN];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_init &#123;</span><br><span class=\"line\">    static dispatch_once_t once;</span><br><span class=\"line\">    dispatch_once(&amp;once, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">            loadables[i] = [NSMutableArray array];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_deInit &#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">        NSMutableArray *array = loadables[i];</span><br><span class=\"line\">        [array removeAllObjects];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)handleAppLaunched:(NSNotification *)note &#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self run_launched];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // run idle</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        [self run_idleTime];</span><br><span class=\"line\">        [self load_deInit];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:NO block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:sort mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block &#123;</span><br><span class=\"line\">    assert(block);</span><br><span class=\"line\">    _XRLoadObject *obj = [[_XRLoadObject alloc] init];</span><br><span class=\"line\">    obj.at = at;</span><br><span class=\"line\">    obj.sort = sort;</span><br><span class=\"line\">    obj.mainThread = mainthread;</span><br><span class=\"line\">    obj.block = block;</span><br><span class=\"line\">    [self load_init];</span><br><span class=\"line\">    [loadables[at] addObject:obj];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_preMain &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtPreMain];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_launched &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtAppLaunched];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_idleTime &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtIdleTime];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_block_array:(LoadAt)at &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) &#123;</span><br><span class=\"line\">        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) &#123;</span><br><span class=\"line\">            if (!obj1.mainThread &amp;&amp; obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.mainThread &amp;&amp; !obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedAscending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort &gt; obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort == obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return NSOrderedAscending;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        for (_XRLoadObject *obj in array) &#123;</span><br><span class=\"line\">            if (obj.mainThread) &#123;</span><br><span class=\"line\">                if ([NSThread isMainThread]) &#123;</span><br><span class=\"line\">                    obj.block();</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dispatch_async(dispatch_get_main_queue(), obj.block);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if (at == LoadAtPreMain) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtPreMain]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtAppLaunched) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtAppLaunched]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtIdleTime) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtIdleTime]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((constructor))</span><br><span class=\"line\">static void initlize(void) &#123;</span><br><span class=\"line\">    [XRLoadManager run_preMain];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"new draft","_content":"","source":"_drafts/new-draft.md","raw":"---\ntitle: new draft\ntags:\n---\n","slug":"new-draft","published":0,"date":"2019-12-20T06:08:22.047Z","updated":"2019-12-20T06:08:22.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4dsux2r0002odnqzbeq4rdd","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"[layout]","title":"VPS科学上网教程:SS搭建+bbr加速","date":"2017-11-05T03:49:53.000Z","comments":1,"toc":true,"_content":"\n## 一、SS安装\n\n### 1. root用户ssh登录vps\n\n### 2. 安装Shadowsocks一键安装脚本（四合一）\n\n```\nwget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh && chmod +x shadowsocks-all.sh && ./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log\n```\n\n### 3.安装完成\n\n四个版本可选，我就直接安装python版本的。提示输入密码，端口，加密方式等。\n\n<!-- more -->\n\n出现如下提示，安装完成\n\n```\nCongratulations, your_shadowsocks_version install completed!\nYour Server IP        :your_server_ip\nYour Server Port      :your_server_port\nYour Password         :your_password\nYour Encryption Method:your_encryption_method\n\nYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)\n ss://your_encryption_method:your_password@your_server_ip:your_server_port\nYour QR Code has been saved as a PNG file path:\n your_path.png\n\nWelcome to visit:https://teddysun.com/486.html\nEnjoy it!\n```\n\n### 4.相关命令(开启、停止、重启、信息)\n\n```\nShadowsocks-Python 版：\n/etc/init.d/shadowsocks-python start | stop | restart | status\n\nShadowsocksR 版：\n/etc/init.d/shadowsocks-r start | stop | restart | status\n\nShadowsocks-Go 版：\n/etc/init.d/shadowsocks-go start | stop | restart | status\n\nShadowsocks-libev 版：\n/etc/init.d/shadowsocks-libev start | stop | restart | status\n```\n\n### 5.配置文件\n\n```\nShadowsocks-Python 版：\n/etc/shadowsocks-python/config.json\n\nShadowsocksR 版：\n/etc/shadowsocks-r/config.json\n\nShadowsocks-Go 版：\n/etc/shadowsocks-go/config.json\n\nShadowsocks-libev 版：\n/etc/shadowsocks-libev/config.json\n```\n\n### 6.卸载\n\n```\n./shadowsocks-all.sh uninstall\n```\n\n\n\n---\n\n## 二、bbr加速\n\n### 1.安装bbr脚本\n\n```\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh && chmod +x bbr.sh && ./bbr.sh\n```\n\n安装完成，提示重启。\n\n### 2.查看安装信息\n\n```\n1.uname -r\n查看内核\n\n2.sysctl net.ipv4.tcp_available_congestion_control\n返回值一般为：net.ipv4.tcp_available_congestion_control = bbr cubic reno\n\n3.sysctl net.ipv4.tcp_congestion_control\n返回值一般为：net.ipv4.tcp_congestion_control = bbr\n\n4.sysctl net.core.default_qdisc\n返回值一般为：net.core.default_qdisc = fq\n\n5.lsmod | grep bbr\n返回值有 tcp_bbr 模块即说明 bbr 已启动\n```\n\n---\n\n## 三、客户端下载\n\n客户端下载地址 ：[download](https://bbs.bydisk.com/shadowsocks-download.html)\n\n","source":"_posts/VPS_01_01.md","raw":"---\nlayout: '[layout]'\ntitle: VPS科学上网教程:SS搭建+bbr加速\ndate: 2017-11-05 11:49:53\ncategories: \n- 教程\n- [教程, 工具, VPS]\ntags: \n- 教程\n- 工具\n- VPS\ncomments: true\ntoc: true\n---\n\n## 一、SS安装\n\n### 1. root用户ssh登录vps\n\n### 2. 安装Shadowsocks一键安装脚本（四合一）\n\n```\nwget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh && chmod +x shadowsocks-all.sh && ./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log\n```\n\n### 3.安装完成\n\n四个版本可选，我就直接安装python版本的。提示输入密码，端口，加密方式等。\n\n<!-- more -->\n\n出现如下提示，安装完成\n\n```\nCongratulations, your_shadowsocks_version install completed!\nYour Server IP        :your_server_ip\nYour Server Port      :your_server_port\nYour Password         :your_password\nYour Encryption Method:your_encryption_method\n\nYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)\n ss://your_encryption_method:your_password@your_server_ip:your_server_port\nYour QR Code has been saved as a PNG file path:\n your_path.png\n\nWelcome to visit:https://teddysun.com/486.html\nEnjoy it!\n```\n\n### 4.相关命令(开启、停止、重启、信息)\n\n```\nShadowsocks-Python 版：\n/etc/init.d/shadowsocks-python start | stop | restart | status\n\nShadowsocksR 版：\n/etc/init.d/shadowsocks-r start | stop | restart | status\n\nShadowsocks-Go 版：\n/etc/init.d/shadowsocks-go start | stop | restart | status\n\nShadowsocks-libev 版：\n/etc/init.d/shadowsocks-libev start | stop | restart | status\n```\n\n### 5.配置文件\n\n```\nShadowsocks-Python 版：\n/etc/shadowsocks-python/config.json\n\nShadowsocksR 版：\n/etc/shadowsocks-r/config.json\n\nShadowsocks-Go 版：\n/etc/shadowsocks-go/config.json\n\nShadowsocks-libev 版：\n/etc/shadowsocks-libev/config.json\n```\n\n### 6.卸载\n\n```\n./shadowsocks-all.sh uninstall\n```\n\n\n\n---\n\n## 二、bbr加速\n\n### 1.安装bbr脚本\n\n```\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh && chmod +x bbr.sh && ./bbr.sh\n```\n\n安装完成，提示重启。\n\n### 2.查看安装信息\n\n```\n1.uname -r\n查看内核\n\n2.sysctl net.ipv4.tcp_available_congestion_control\n返回值一般为：net.ipv4.tcp_available_congestion_control = bbr cubic reno\n\n3.sysctl net.ipv4.tcp_congestion_control\n返回值一般为：net.ipv4.tcp_congestion_control = bbr\n\n4.sysctl net.core.default_qdisc\n返回值一般为：net.core.default_qdisc = fq\n\n5.lsmod | grep bbr\n返回值有 tcp_bbr 模块即说明 bbr 已启动\n```\n\n---\n\n## 三、客户端下载\n\n客户端下载地址 ：[download](https://bbs.bydisk.com/shadowsocks-download.html)\n\n","slug":"VPS_01_01","published":1,"updated":"2019-12-20T06:08:22.048Z","photos":[],"link":"","_id":"ck4dsux2u0005odnqz3hjrn3o","content":"<h2 id=\"一、SS安装\"><a href=\"#一、SS安装\" class=\"headerlink\" title=\"一、SS安装\"></a>一、SS安装</h2><h3 id=\"1-root用户ssh登录vps\"><a href=\"#1-root用户ssh登录vps\" class=\"headerlink\" title=\"1. root用户ssh登录vps\"></a>1. root用户ssh登录vps</h3><h3 id=\"2-安装Shadowsocks一键安装脚本（四合一）\"><a href=\"#2-安装Shadowsocks一键安装脚本（四合一）\" class=\"headerlink\" title=\"2. 安装Shadowsocks一键安装脚本（四合一）\"></a>2. 安装Shadowsocks一键安装脚本（四合一）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh &amp;&amp; chmod +x shadowsocks-all.sh &amp;&amp; ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-安装完成\"><a href=\"#3-安装完成\" class=\"headerlink\" title=\"3.安装完成\"></a>3.安装完成</h3><p>四个版本可选，我就直接安装python版本的。提示输入密码，端口，加密方式等。</p>\n<a id=\"more\"></a>\n<p>出现如下提示，安装完成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, your_shadowsocks_version install completed!</span><br><span class=\"line\">Your Server IP        :your_server_ip</span><br><span class=\"line\">Your Server Port      :your_server_port</span><br><span class=\"line\">Your Password         :your_password</span><br><span class=\"line\">Your Encryption Method:your_encryption_method</span><br><span class=\"line\"></span><br><span class=\"line\">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class=\"line\"> ss://your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class=\"line\">Your QR Code has been saved as a PNG file path:</span><br><span class=\"line\"> your_path.png</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to visit:https://teddysun.com/486.html</span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-相关命令-开启、停止、重启、信息\"><a href=\"#4-相关命令-开启、停止、重启、信息\" class=\"headerlink\" title=\"4.相关命令(开启、停止、重启、信息)\"></a>4.相关命令(开启、停止、重启、信息)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-python start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-r start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-go start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-libev start | stop | restart | status</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-配置文件\"><a href=\"#5-配置文件\" class=\"headerlink\" title=\"5.配置文件\"></a>5.配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">/etc/shadowsocks-python/config.json</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">/etc/shadowsocks-r/config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">/etc/shadowsocks-go/config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">/etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-卸载\"><a href=\"#6-卸载\" class=\"headerlink\" title=\"6.卸载\"></a>6.卸载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"二、bbr加速\"><a href=\"#二、bbr加速\" class=\"headerlink\" title=\"二、bbr加速\"></a>二、bbr加速</h2><h3 id=\"1-安装bbr脚本\"><a href=\"#1-安装bbr脚本\" class=\"headerlink\" title=\"1.安装bbr脚本\"></a>1.安装bbr脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>\n<p>安装完成，提示重启。</p>\n<h3 id=\"2-查看安装信息\"><a href=\"#2-查看安装信息\" class=\"headerlink\" title=\"2.查看安装信息\"></a>2.查看安装信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.uname -r</span><br><span class=\"line\">查看内核</span><br><span class=\"line\"></span><br><span class=\"line\">2.sysctl net.ipv4.tcp_available_congestion_control</span><br><span class=\"line\">返回值一般为：net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class=\"line\"></span><br><span class=\"line\">3.sysctl net.ipv4.tcp_congestion_control</span><br><span class=\"line\">返回值一般为：net.ipv4.tcp_congestion_control = bbr</span><br><span class=\"line\"></span><br><span class=\"line\">4.sysctl net.core.default_qdisc</span><br><span class=\"line\">返回值一般为：net.core.default_qdisc = fq</span><br><span class=\"line\"></span><br><span class=\"line\">5.lsmod | grep bbr</span><br><span class=\"line\">返回值有 tcp_bbr 模块即说明 bbr 已启动</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"三、客户端下载\"><a href=\"#三、客户端下载\" class=\"headerlink\" title=\"三、客户端下载\"></a>三、客户端下载</h2><p>客户端下载地址 ：<a href=\"https://bbs.bydisk.com/shadowsocks-download.html\" target=\"_blank\" rel=\"noopener\">download</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、SS安装\"><a href=\"#一、SS安装\" class=\"headerlink\" title=\"一、SS安装\"></a>一、SS安装</h2><h3 id=\"1-root用户ssh登录vps\"><a href=\"#1-root用户ssh登录vps\" class=\"headerlink\" title=\"1. root用户ssh登录vps\"></a>1. root用户ssh登录vps</h3><h3 id=\"2-安装Shadowsocks一键安装脚本（四合一）\"><a href=\"#2-安装Shadowsocks一键安装脚本（四合一）\" class=\"headerlink\" title=\"2. 安装Shadowsocks一键安装脚本（四合一）\"></a>2. 安装Shadowsocks一键安装脚本（四合一）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh &amp;&amp; chmod +x shadowsocks-all.sh &amp;&amp; ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-安装完成\"><a href=\"#3-安装完成\" class=\"headerlink\" title=\"3.安装完成\"></a>3.安装完成</h3><p>四个版本可选，我就直接安装python版本的。提示输入密码，端口，加密方式等。</p>","more":"<p>出现如下提示，安装完成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, your_shadowsocks_version install completed!</span><br><span class=\"line\">Your Server IP        :your_server_ip</span><br><span class=\"line\">Your Server Port      :your_server_port</span><br><span class=\"line\">Your Password         :your_password</span><br><span class=\"line\">Your Encryption Method:your_encryption_method</span><br><span class=\"line\"></span><br><span class=\"line\">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class=\"line\"> ss://your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class=\"line\">Your QR Code has been saved as a PNG file path:</span><br><span class=\"line\"> your_path.png</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to visit:https://teddysun.com/486.html</span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-相关命令-开启、停止、重启、信息\"><a href=\"#4-相关命令-开启、停止、重启、信息\" class=\"headerlink\" title=\"4.相关命令(开启、停止、重启、信息)\"></a>4.相关命令(开启、停止、重启、信息)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-python start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-r start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-go start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">/etc/init.d/shadowsocks-libev start | stop | restart | status</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-配置文件\"><a href=\"#5-配置文件\" class=\"headerlink\" title=\"5.配置文件\"></a>5.配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">/etc/shadowsocks-python/config.json</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">/etc/shadowsocks-r/config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">/etc/shadowsocks-go/config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">/etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-卸载\"><a href=\"#6-卸载\" class=\"headerlink\" title=\"6.卸载\"></a>6.卸载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"二、bbr加速\"><a href=\"#二、bbr加速\" class=\"headerlink\" title=\"二、bbr加速\"></a>二、bbr加速</h2><h3 id=\"1-安装bbr脚本\"><a href=\"#1-安装bbr脚本\" class=\"headerlink\" title=\"1.安装bbr脚本\"></a>1.安装bbr脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>\n<p>安装完成，提示重启。</p>\n<h3 id=\"2-查看安装信息\"><a href=\"#2-查看安装信息\" class=\"headerlink\" title=\"2.查看安装信息\"></a>2.查看安装信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.uname -r</span><br><span class=\"line\">查看内核</span><br><span class=\"line\"></span><br><span class=\"line\">2.sysctl net.ipv4.tcp_available_congestion_control</span><br><span class=\"line\">返回值一般为：net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class=\"line\"></span><br><span class=\"line\">3.sysctl net.ipv4.tcp_congestion_control</span><br><span class=\"line\">返回值一般为：net.ipv4.tcp_congestion_control = bbr</span><br><span class=\"line\"></span><br><span class=\"line\">4.sysctl net.core.default_qdisc</span><br><span class=\"line\">返回值一般为：net.core.default_qdisc = fq</span><br><span class=\"line\"></span><br><span class=\"line\">5.lsmod | grep bbr</span><br><span class=\"line\">返回值有 tcp_bbr 模块即说明 bbr 已启动</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"三、客户端下载\"><a href=\"#三、客户端下载\" class=\"headerlink\" title=\"三、客户端下载\"></a>三、客户端下载</h2><p>客户端下载地址 ：<a href=\"https://bbs.bydisk.com/shadowsocks-download.html\" target=\"_blank\" rel=\"noopener\">download</a></p>"},{"layout":"[layout]","title":"VPS搭建个人博客/相册教程01_服务器环境配置","date":"2017-11-19T06:15:23.000Z","_content":"\n> 环境：\n>\n> vps环境：CentOS 6.9\n>\n> 本机环境：macOS10.12\n\n---\n\n## 1. SSH登录VPS\n\n## 2. 搭建LNMP环境\n\n### 2.1 cd到root用户目录下\n```\ncd /root # 安装包下载目录\n```\n\n<!-- more -->\n\n### 2.2 下载lnmp一键安装包\n\n```\nwget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz # 版本随意\n```\n\n### 2.3 解压缩到/usr/local目录下\n\n```\ntar zxf lnmp1.4.tar.gz -C /usr/local # 安装目录要放在/usr路径下\n```\n\n### 2.4 安装\n\n```\ncd /usr/local/lnmp1.4 && ./install.sh \n```\n\n然后会出现一些安装提示选项，一路回车键就好。然后就开始安装各种软件，来杯82年的java，稍等片刻，安装完成。\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171215_33.png)\n\n出现如上提示表示安装完成。输入**lnmp help**命令查看更多使用帮助。\n\n![Snip20171218_1.png](http://ozpzewso9.bkt.clouddn.com/Snip20171218_1.png)\n\n在浏览器中输入**vps**的**ip**地址，将会看到如下提示页面。至此，**lnmp**环境已经安装完成。\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171215_34.png)\n\n\n\n## 3. **安装Node环境**\n\n> 个人相册使用的是zing-gallery的开源项目。因为需要在服务端开启一个node服务，所以这里需要配置好node环境。\n\n### 3.1 cd到root用户目录下\n\n```\ncd /root\n```\n\n### 3.2 下载**node**安装包\n\n```\nwget http://nodejs.org/dist/v6.4.0/node-v6.4.0-linux-x64.tar.gz \n```\n\n### 3.3 解压缩到/usr/local目录下\n\n```\ntar zxvf node-v6.4.0-linux-x86.tar.gz -C /usr/local\n```\n\n### 3.4 添加环境变量\n\n```\nvi /etc/profile\n\n在最底下添加以下代码\nexport NODE_HOME=/usr/local/node-v6.4.0-linux-x64\nexport PATH=$PATH:$NODE_HOME/bin\nexport NODE_PATH=$NODE_HOME/lib/node_modules\n```\n\n### 3.5 source /etc/profile\n\n### 3.6 node -v\n\n### 3.7 npm -v\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171215_36.png)\n\n**PS:**\n\n如果需要升级**node**，可以使用**node**升级神器**-n**。\n\n1.全局安装n\n\n​\tnpm install -g n\n\n2.查看版本\n\n​\tn -V\n\n3.卸载当前的node\n\n4.使用n安装node\n\n​\tn stable（稳定的正式版本）\n\n​\tn latest（官方最新的发布版本）\n\n​\tn lts（最新的LTS正式版本）\n\n​\tn 9.2.0 （安装指定版本）\n\n具体使用**n help**查看帮助\n\n\n\n## 4. **配置Git仓库**\n\n> 静态博客和个人相册的代码，你可以选择托管到github或者coding.net上。然后使用webhooks，在你每次本地push之后，触发post-receive脚本，然后在个人vps上，拉取远程仓库的代码。\n>\n> 因为是自己的vps，想怎么搞就怎么搞，所以在vps上搭建好git环境，我就直接将博客和相册代码托管到vps上了，没有使用github和coding.net。\n\n### 4.1 安装git\n\n```\ngit --version \n```\n\n如果安装过git，会提示git版本号。\n如果没有安装过，使用下面的命令安装git，安装完查看git版本\n\n```\nyum install -y git\n```\n\n### 4.2 用户配置\n\n* 1.新建一个git用户\n\n  ```\n  adduser git\n  ```\n\n* 2.修改密码\n\n  ```\n  passwd git # 输入密码，确认密码即可\n  ```\n\n* 3.配置git用户\n\n  * 3.1切换到git用户目录下\n\n    ```\n    su git \n    cd ~\n    ```\n\n  * 3.2添加ssh公钥\n\n    ```\n    mkdir -p ~/.ssh\n    vi ~/.ssh/authorized_keys # 在电脑的命令行中执行 cat ~/.ssh/id_rsa.pub | pbcopy # 将公钥复制粘贴到authorized_keys，然后保存退出\n    ```\n\n  * 3.3添加文件及目录权限\n\n    ```\n    chmod 700 ~/.ssh\n    chmod 600 ~/.ssh/authorized_keys\n    ```\n\n  * 3.4设置git用户ssh免密码登录\n\n    ```\n    su root # 切换到root用户\n    chmod 740 /etc/sudoers # 修改权限\n    vi /etc/sudoers\n\n    找到以下内容\n    ## Allow root to run any commands anywhere\n    root    ALL=(ALL)     ALL\n    在下面加上一行,保存退出\n    git ALL=(ALL) ALL \n\n    chmod 400 /etc/sudoers # 恢复为原来的权限\n    ```\n\n  * exit退出，使用**git**用户用**ssh**登录\n\n**ps：**\n\n如果你刚输完密码，然后再若干秒之后忘了密码。比如我，这时你就可以用到以下命令。\n\nuserdel -r git\n\n如果出现userdel: user git is currently used by process 10958\n\nps -u git | awk '{print $1}' | grep -vi pid | xargs kill -9\n\nkill用户相关进程，之后再次执行删除用户命令\n\n### 4.3 **hexo**博客及**gallery**相册**git远程仓库**配置\n\n* 1.git用户下，进入到git用户主目录\n\n  ```\n  cd ~\n  ```\n\n* 2.新建一个文件夹,用于存放hexo博客以及gallery相册的git仓库\n\n  ```\n  mkdir repo\n  ```\n\n* 3.配置hexo博客的git仓库\n\n  * 3.1 新建一个文件夹用于存放hexo博客的git仓库\n\n    ```\n    cd /home/git/repo && mkdir blog.git && cd blog.git\n    ```\n\n  * 3.2 初始化一个空仓库\n\n    ```\n    git init --bare\n    ```\n\n  * 3.3 配置githooks，新建一个脚本文件\n\n    ```\n    cd hooks && vi post-receive\n\n    复制以下代码粘贴保存退出\n    #!/bin/bash\n    GIT_REPO=/home/git/repo/blog.git #git仓库目录\n    TMP_GIT_CLONE=/tmp/hexo\n    PUBLIC_WWW=/home/wwwroot/blog #代码存放目录\n    rm -rf ${TMP_GIT_CLONE}\n    git clone $GIT_REPO $TMP_GIT_CLONE\n    rm -rf ${PUBLIC_WWW}/*\n    cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}\n    ```\n\n  * 3.4 修改权限\n\n    ```\n     chmod +x post-receive\n    ```\n\n  * 3.5 修改所有者\n\n    ```\n    chown git:git -R /home/wwwgit/blogs\n    ```\n\n    ​\n\n* 4.配置gallery相册的git仓库\n\n  * 4.1 新建一个文件夹用于存放gallery相册的git仓库\n\n    ```\n    cd /home/git/repo &&mkdir gallery.git && cd gallery.git\n    ```\n\n  * 4.2 初始化一个空仓库\n\n    ```\n    git init --bare\n    ```\n\n  * 4.3 老规矩，同上\n\n    ```\n    cd hooks && vi post-receive\n\n    老规矩，复制以下代码粘贴保存退出\n    git --work-tree=/home/wwwroot/gallery--git-dir=/home/git/repo/gallery.git checkout -f\n    ```\n\n  * 4.4 修改权限\n\n    ```\n     chmod +x post-receive\n    ```\n\n  * 4.5 修改所有者\n\n    ```\n    chown git:git -R /home/wwwgit/gallery\n    ```\n\n至此，在vps服务器上面已经配置好了hexo博客以及gallery相册的git托管仓库了，仓库地址放在/home/git/repo目录下，代码放在/home/wwwroot目录下。\n\n\n\n## 5. Nginx配置\n\n### 5.1 查看nginx默认配置文件\n\n```\nvi /usr/local/nginx/conf/nginx.conf\n\n找到以下代码：\nserver\n    {\n        listen 80 default_server;\n        #listen [::]:80 default_server ipv6only=on;\n        server_name _;\n        index index.html index.htm index.php;\n        root  /home/wwwroot/default;\n\t\t...\n    }\ninclude vhost/*.conf;\n```\n\n看到nginx默认配置，虚拟主机配置，监听80端口，索引文件名称为index.html index.htm index.php，索引文件根路径为/home/wwwroot/default。\n\n在浏览器中输入ip地址可以看到打开的是**LNMP一键安装包安装成功**提示网页。\n\n接下来cd到/home/wwwroot/default目录下，可以看到该目录下已经存在如下这些文件，也就是你在浏览器中通过ip地址打开的LNMP一键安装包安装成功提示网页的内容。\n\n```\nroot@vultr default]# cd /home/wwwroot/default\n[root@vultr default]# ls -l\ntotal 84\n-rw-r--r--  1 root root  2781 Dec 15 21:00 index.html\n-rw-r--r--  1 root root  5683 Dec 15 21:00 lnmp.gif\n-rw-r--r--  1 root root 20256 Dec 15 21:00 ocp.php\n-rw-r--r--  1 root root    20 Dec 15 21:00 phpinfo.php\ndrwxr-xr-x 14 www  www   4096 Dec 15 21:00 phpmyadmin\n-rw-r--r--  1 root root 42609 Dec 15 21:00 p.php\n[root@vultr default]#\n```\n\n所以我们直接将root 目录改为hexo博客的文件目录即可，但是一般不建议直接在默认的配置文件里修改，在配置文件中底部会发现**include vhost/*.conf;**这句，意思也就是说会去包含当前文件夹vhost文件夹下所有配置文件。所以我们就可以在vhost文件夹下新建一个虚拟主机的方式来配置hexo博客。\n\n### 5.2 新建一个虚拟主机\n\n```\nlnmp vhost add\n```\n\n填上你的域名，设置root为你的hexo博客文件路径即可。\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171218_48.png)\n\n配置成功。\n\n### 5.3 重启nginx服务\n\n```\nnginx -s reload\n```\n\n至此，nginx配置成功。\n\n\n\n---\n\n此时，在浏览器中输入域名访问网页，dns解析到绑定的ip也就是你的vps分配给你ip地址，读取该配置文件中root目录下的文件资源也就是你的hexo博客目录的资源文件，加载博客页面。发现打开的是个403页面（当然了，因为/home/wwwroot/hexo目录下并没有任何文件。）。\n\n接下来就是要将本地hexo博客使用git从本地上传到服务器上就可以了。\n\n至此，服务端的配置已经基本完成。\n\n","source":"_posts/VPS_02_01.md","raw":"---\nlayout: '[layout]'\ntitle: VPS搭建个人博客/相册教程01_服务器环境配置\ndate: 2017-11-19 14:15:23\ncategories: \n- 教程\n- [教程, Hexo]\ntags: \n- 教程\n- hexo\n---\n\n> 环境：\n>\n> vps环境：CentOS 6.9\n>\n> 本机环境：macOS10.12\n\n---\n\n## 1. SSH登录VPS\n\n## 2. 搭建LNMP环境\n\n### 2.1 cd到root用户目录下\n```\ncd /root # 安装包下载目录\n```\n\n<!-- more -->\n\n### 2.2 下载lnmp一键安装包\n\n```\nwget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz # 版本随意\n```\n\n### 2.3 解压缩到/usr/local目录下\n\n```\ntar zxf lnmp1.4.tar.gz -C /usr/local # 安装目录要放在/usr路径下\n```\n\n### 2.4 安装\n\n```\ncd /usr/local/lnmp1.4 && ./install.sh \n```\n\n然后会出现一些安装提示选项，一路回车键就好。然后就开始安装各种软件，来杯82年的java，稍等片刻，安装完成。\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171215_33.png)\n\n出现如上提示表示安装完成。输入**lnmp help**命令查看更多使用帮助。\n\n![Snip20171218_1.png](http://ozpzewso9.bkt.clouddn.com/Snip20171218_1.png)\n\n在浏览器中输入**vps**的**ip**地址，将会看到如下提示页面。至此，**lnmp**环境已经安装完成。\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171215_34.png)\n\n\n\n## 3. **安装Node环境**\n\n> 个人相册使用的是zing-gallery的开源项目。因为需要在服务端开启一个node服务，所以这里需要配置好node环境。\n\n### 3.1 cd到root用户目录下\n\n```\ncd /root\n```\n\n### 3.2 下载**node**安装包\n\n```\nwget http://nodejs.org/dist/v6.4.0/node-v6.4.0-linux-x64.tar.gz \n```\n\n### 3.3 解压缩到/usr/local目录下\n\n```\ntar zxvf node-v6.4.0-linux-x86.tar.gz -C /usr/local\n```\n\n### 3.4 添加环境变量\n\n```\nvi /etc/profile\n\n在最底下添加以下代码\nexport NODE_HOME=/usr/local/node-v6.4.0-linux-x64\nexport PATH=$PATH:$NODE_HOME/bin\nexport NODE_PATH=$NODE_HOME/lib/node_modules\n```\n\n### 3.5 source /etc/profile\n\n### 3.6 node -v\n\n### 3.7 npm -v\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171215_36.png)\n\n**PS:**\n\n如果需要升级**node**，可以使用**node**升级神器**-n**。\n\n1.全局安装n\n\n​\tnpm install -g n\n\n2.查看版本\n\n​\tn -V\n\n3.卸载当前的node\n\n4.使用n安装node\n\n​\tn stable（稳定的正式版本）\n\n​\tn latest（官方最新的发布版本）\n\n​\tn lts（最新的LTS正式版本）\n\n​\tn 9.2.0 （安装指定版本）\n\n具体使用**n help**查看帮助\n\n\n\n## 4. **配置Git仓库**\n\n> 静态博客和个人相册的代码，你可以选择托管到github或者coding.net上。然后使用webhooks，在你每次本地push之后，触发post-receive脚本，然后在个人vps上，拉取远程仓库的代码。\n>\n> 因为是自己的vps，想怎么搞就怎么搞，所以在vps上搭建好git环境，我就直接将博客和相册代码托管到vps上了，没有使用github和coding.net。\n\n### 4.1 安装git\n\n```\ngit --version \n```\n\n如果安装过git，会提示git版本号。\n如果没有安装过，使用下面的命令安装git，安装完查看git版本\n\n```\nyum install -y git\n```\n\n### 4.2 用户配置\n\n* 1.新建一个git用户\n\n  ```\n  adduser git\n  ```\n\n* 2.修改密码\n\n  ```\n  passwd git # 输入密码，确认密码即可\n  ```\n\n* 3.配置git用户\n\n  * 3.1切换到git用户目录下\n\n    ```\n    su git \n    cd ~\n    ```\n\n  * 3.2添加ssh公钥\n\n    ```\n    mkdir -p ~/.ssh\n    vi ~/.ssh/authorized_keys # 在电脑的命令行中执行 cat ~/.ssh/id_rsa.pub | pbcopy # 将公钥复制粘贴到authorized_keys，然后保存退出\n    ```\n\n  * 3.3添加文件及目录权限\n\n    ```\n    chmod 700 ~/.ssh\n    chmod 600 ~/.ssh/authorized_keys\n    ```\n\n  * 3.4设置git用户ssh免密码登录\n\n    ```\n    su root # 切换到root用户\n    chmod 740 /etc/sudoers # 修改权限\n    vi /etc/sudoers\n\n    找到以下内容\n    ## Allow root to run any commands anywhere\n    root    ALL=(ALL)     ALL\n    在下面加上一行,保存退出\n    git ALL=(ALL) ALL \n\n    chmod 400 /etc/sudoers # 恢复为原来的权限\n    ```\n\n  * exit退出，使用**git**用户用**ssh**登录\n\n**ps：**\n\n如果你刚输完密码，然后再若干秒之后忘了密码。比如我，这时你就可以用到以下命令。\n\nuserdel -r git\n\n如果出现userdel: user git is currently used by process 10958\n\nps -u git | awk '{print $1}' | grep -vi pid | xargs kill -9\n\nkill用户相关进程，之后再次执行删除用户命令\n\n### 4.3 **hexo**博客及**gallery**相册**git远程仓库**配置\n\n* 1.git用户下，进入到git用户主目录\n\n  ```\n  cd ~\n  ```\n\n* 2.新建一个文件夹,用于存放hexo博客以及gallery相册的git仓库\n\n  ```\n  mkdir repo\n  ```\n\n* 3.配置hexo博客的git仓库\n\n  * 3.1 新建一个文件夹用于存放hexo博客的git仓库\n\n    ```\n    cd /home/git/repo && mkdir blog.git && cd blog.git\n    ```\n\n  * 3.2 初始化一个空仓库\n\n    ```\n    git init --bare\n    ```\n\n  * 3.3 配置githooks，新建一个脚本文件\n\n    ```\n    cd hooks && vi post-receive\n\n    复制以下代码粘贴保存退出\n    #!/bin/bash\n    GIT_REPO=/home/git/repo/blog.git #git仓库目录\n    TMP_GIT_CLONE=/tmp/hexo\n    PUBLIC_WWW=/home/wwwroot/blog #代码存放目录\n    rm -rf ${TMP_GIT_CLONE}\n    git clone $GIT_REPO $TMP_GIT_CLONE\n    rm -rf ${PUBLIC_WWW}/*\n    cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}\n    ```\n\n  * 3.4 修改权限\n\n    ```\n     chmod +x post-receive\n    ```\n\n  * 3.5 修改所有者\n\n    ```\n    chown git:git -R /home/wwwgit/blogs\n    ```\n\n    ​\n\n* 4.配置gallery相册的git仓库\n\n  * 4.1 新建一个文件夹用于存放gallery相册的git仓库\n\n    ```\n    cd /home/git/repo &&mkdir gallery.git && cd gallery.git\n    ```\n\n  * 4.2 初始化一个空仓库\n\n    ```\n    git init --bare\n    ```\n\n  * 4.3 老规矩，同上\n\n    ```\n    cd hooks && vi post-receive\n\n    老规矩，复制以下代码粘贴保存退出\n    git --work-tree=/home/wwwroot/gallery--git-dir=/home/git/repo/gallery.git checkout -f\n    ```\n\n  * 4.4 修改权限\n\n    ```\n     chmod +x post-receive\n    ```\n\n  * 4.5 修改所有者\n\n    ```\n    chown git:git -R /home/wwwgit/gallery\n    ```\n\n至此，在vps服务器上面已经配置好了hexo博客以及gallery相册的git托管仓库了，仓库地址放在/home/git/repo目录下，代码放在/home/wwwroot目录下。\n\n\n\n## 5. Nginx配置\n\n### 5.1 查看nginx默认配置文件\n\n```\nvi /usr/local/nginx/conf/nginx.conf\n\n找到以下代码：\nserver\n    {\n        listen 80 default_server;\n        #listen [::]:80 default_server ipv6only=on;\n        server_name _;\n        index index.html index.htm index.php;\n        root  /home/wwwroot/default;\n\t\t...\n    }\ninclude vhost/*.conf;\n```\n\n看到nginx默认配置，虚拟主机配置，监听80端口，索引文件名称为index.html index.htm index.php，索引文件根路径为/home/wwwroot/default。\n\n在浏览器中输入ip地址可以看到打开的是**LNMP一键安装包安装成功**提示网页。\n\n接下来cd到/home/wwwroot/default目录下，可以看到该目录下已经存在如下这些文件，也就是你在浏览器中通过ip地址打开的LNMP一键安装包安装成功提示网页的内容。\n\n```\nroot@vultr default]# cd /home/wwwroot/default\n[root@vultr default]# ls -l\ntotal 84\n-rw-r--r--  1 root root  2781 Dec 15 21:00 index.html\n-rw-r--r--  1 root root  5683 Dec 15 21:00 lnmp.gif\n-rw-r--r--  1 root root 20256 Dec 15 21:00 ocp.php\n-rw-r--r--  1 root root    20 Dec 15 21:00 phpinfo.php\ndrwxr-xr-x 14 www  www   4096 Dec 15 21:00 phpmyadmin\n-rw-r--r--  1 root root 42609 Dec 15 21:00 p.php\n[root@vultr default]#\n```\n\n所以我们直接将root 目录改为hexo博客的文件目录即可，但是一般不建议直接在默认的配置文件里修改，在配置文件中底部会发现**include vhost/*.conf;**这句，意思也就是说会去包含当前文件夹vhost文件夹下所有配置文件。所以我们就可以在vhost文件夹下新建一个虚拟主机的方式来配置hexo博客。\n\n### 5.2 新建一个虚拟主机\n\n```\nlnmp vhost add\n```\n\n填上你的域名，设置root为你的hexo博客文件路径即可。\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171218_48.png)\n\n配置成功。\n\n### 5.3 重启nginx服务\n\n```\nnginx -s reload\n```\n\n至此，nginx配置成功。\n\n\n\n---\n\n此时，在浏览器中输入域名访问网页，dns解析到绑定的ip也就是你的vps分配给你ip地址，读取该配置文件中root目录下的文件资源也就是你的hexo博客目录的资源文件，加载博客页面。发现打开的是个403页面（当然了，因为/home/wwwroot/hexo目录下并没有任何文件。）。\n\n接下来就是要将本地hexo博客使用git从本地上传到服务器上就可以了。\n\n至此，服务端的配置已经基本完成。\n\n","slug":"VPS_02_01","published":1,"updated":"2019-12-20T06:08:22.049Z","comments":1,"photos":[],"link":"","_id":"ck4dsux2w0008odnqdzxsgh4y","content":"<blockquote>\n<p>环境：</p>\n<p>vps环境：CentOS 6.9</p>\n<p>本机环境：macOS10.12</p>\n</blockquote>\n<hr>\n<h2 id=\"1-SSH登录VPS\"><a href=\"#1-SSH登录VPS\" class=\"headerlink\" title=\"1. SSH登录VPS\"></a>1. SSH登录VPS</h2><h2 id=\"2-搭建LNMP环境\"><a href=\"#2-搭建LNMP环境\" class=\"headerlink\" title=\"2. 搭建LNMP环境\"></a>2. 搭建LNMP环境</h2><h3 id=\"2-1-cd到root用户目录下\"><a href=\"#2-1-cd到root用户目录下\" class=\"headerlink\" title=\"2.1 cd到root用户目录下\"></a>2.1 cd到root用户目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /root # 安装包下载目录</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"2-2-下载lnmp一键安装包\"><a href=\"#2-2-下载lnmp一键安装包\" class=\"headerlink\" title=\"2.2 下载lnmp一键安装包\"></a>2.2 下载lnmp一键安装包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz # 版本随意</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-解压缩到-usr-local目录下\"><a href=\"#2-3-解压缩到-usr-local目录下\" class=\"headerlink\" title=\"2.3 解压缩到/usr/local目录下\"></a>2.3 解压缩到/usr/local目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxf lnmp1.4.tar.gz -C /usr/local # 安装目录要放在/usr路径下</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-安装\"><a href=\"#2-4-安装\" class=\"headerlink\" title=\"2.4 安装\"></a>2.4 安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/lnmp1.4 &amp;&amp; ./install.sh</span><br></pre></td></tr></table></figure>\n<p>然后会出现一些安装提示选项，一路回车键就好。然后就开始安装各种软件，来杯82年的java，稍等片刻，安装完成。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171215_33.png\" alt=\"\"></p>\n<p>出现如上提示表示安装完成。输入<strong>lnmp help</strong>命令查看更多使用帮助。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171218_1.png\" alt=\"Snip20171218_1.png\"></p>\n<p>在浏览器中输入<strong>vps</strong>的<strong>ip</strong>地址，将会看到如下提示页面。至此，<strong>lnmp</strong>环境已经安装完成。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171215_34.png\" alt=\"\"></p>\n<h2 id=\"3-安装Node环境\"><a href=\"#3-安装Node环境\" class=\"headerlink\" title=\"3. 安装Node环境\"></a>3. <strong>安装Node环境</strong></h2><blockquote>\n<p>个人相册使用的是zing-gallery的开源项目。因为需要在服务端开启一个node服务，所以这里需要配置好node环境。</p>\n</blockquote>\n<h3 id=\"3-1-cd到root用户目录下\"><a href=\"#3-1-cd到root用户目录下\" class=\"headerlink\" title=\"3.1 cd到root用户目录下\"></a>3.1 cd到root用户目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /root</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-下载node安装包\"><a href=\"#3-2-下载node安装包\" class=\"headerlink\" title=\"3.2 下载node安装包\"></a>3.2 下载<strong>node</strong>安装包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nodejs.org/dist/v6.4.0/node-v6.4.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-解压缩到-usr-local目录下\"><a href=\"#3-3-解压缩到-usr-local目录下\" class=\"headerlink\" title=\"3.3 解压缩到/usr/local目录下\"></a>3.3 解压缩到/usr/local目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf node-v6.4.0-linux-x86.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-添加环境变量\"><a href=\"#3-4-添加环境变量\" class=\"headerlink\" title=\"3.4 添加环境变量\"></a>3.4 添加环境变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\">在最底下添加以下代码</span><br><span class=\"line\">export NODE_HOME=/usr/local/node-v6.4.0-linux-x64</span><br><span class=\"line\">export PATH=$PATH:$NODE_HOME/bin</span><br><span class=\"line\">export NODE_PATH=$NODE_HOME/lib/node_modules</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-source-etc-profile\"><a href=\"#3-5-source-etc-profile\" class=\"headerlink\" title=\"3.5 source /etc/profile\"></a>3.5 source /etc/profile</h3><h3 id=\"3-6-node-v\"><a href=\"#3-6-node-v\" class=\"headerlink\" title=\"3.6 node -v\"></a>3.6 node -v</h3><h3 id=\"3-7-npm-v\"><a href=\"#3-7-npm-v\" class=\"headerlink\" title=\"3.7 npm -v\"></a>3.7 npm -v</h3><p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171215_36.png\" alt=\"\"></p>\n<p><strong>PS:</strong></p>\n<p>如果需要升级<strong>node</strong>，可以使用<strong>node</strong>升级神器<strong>-n</strong>。</p>\n<p>1.全局安装n</p>\n<p>​    npm install -g n</p>\n<p>2.查看版本</p>\n<p>​    n -V</p>\n<p>3.卸载当前的node</p>\n<p>4.使用n安装node</p>\n<p>​    n stable（稳定的正式版本）</p>\n<p>​    n latest（官方最新的发布版本）</p>\n<p>​    n lts（最新的LTS正式版本）</p>\n<p>​    n 9.2.0 （安装指定版本）</p>\n<p>具体使用<strong>n help</strong>查看帮助</p>\n<h2 id=\"4-配置Git仓库\"><a href=\"#4-配置Git仓库\" class=\"headerlink\" title=\"4. 配置Git仓库\"></a>4. <strong>配置Git仓库</strong></h2><blockquote>\n<p>静态博客和个人相册的代码，你可以选择托管到github或者coding.net上。然后使用webhooks，在你每次本地push之后，触发post-receive脚本，然后在个人vps上，拉取远程仓库的代码。</p>\n<p>因为是自己的vps，想怎么搞就怎么搞，所以在vps上搭建好git环境，我就直接将博客和相册代码托管到vps上了，没有使用github和coding.net。</p>\n</blockquote>\n<h3 id=\"4-1-安装git\"><a href=\"#4-1-安装git\" class=\"headerlink\" title=\"4.1 安装git\"></a>4.1 安装git</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br></pre></td></tr></table></figure>\n<p>如果安装过git，会提示git版本号。<br>如果没有安装过，使用下面的命令安装git，安装完查看git版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y git</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-用户配置\"><a href=\"#4-2-用户配置\" class=\"headerlink\" title=\"4.2 用户配置\"></a>4.2 用户配置</h3><ul>\n<li><p>1.新建一个git用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.修改密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd git # 输入密码，确认密码即可</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.配置git用户</p>\n<ul>\n<li><p>3.1切换到git用户目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su git </span><br><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.2添加ssh公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p ~/.ssh</span><br><span class=\"line\">vi ~/.ssh/authorized_keys # 在电脑的命令行中执行 cat ~/.ssh/id_rsa.pub | pbcopy # 将公钥复制粘贴到authorized_keys，然后保存退出</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.3添加文件及目录权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 700 ~/.ssh</span><br><span class=\"line\">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.4设置git用户ssh免密码登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root # 切换到root用户</span><br><span class=\"line\">chmod 740 /etc/sudoers # 修改权限</span><br><span class=\"line\">vi /etc/sudoers</span><br><span class=\"line\"></span><br><span class=\"line\">找到以下内容</span><br><span class=\"line\">## Allow root to run any commands anywhere</span><br><span class=\"line\">root    ALL=(ALL)     ALL</span><br><span class=\"line\">在下面加上一行,保存退出</span><br><span class=\"line\">git ALL=(ALL) ALL </span><br><span class=\"line\"></span><br><span class=\"line\">chmod 400 /etc/sudoers # 恢复为原来的权限</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>exit退出，使用<strong>git</strong>用户用<strong>ssh</strong>登录</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>ps：</strong></p>\n<p>如果你刚输完密码，然后再若干秒之后忘了密码。比如我，这时你就可以用到以下命令。</p>\n<p>userdel -r git</p>\n<p>如果出现userdel: user git is currently used by process 10958</p>\n<p>ps -u git | awk ‘{print $1}’ | grep -vi pid | xargs kill -9</p>\n<p>kill用户相关进程，之后再次执行删除用户命令</p>\n<h3 id=\"4-3-hexo博客及gallery相册git远程仓库配置\"><a href=\"#4-3-hexo博客及gallery相册git远程仓库配置\" class=\"headerlink\" title=\"4.3 hexo博客及gallery相册git远程仓库配置\"></a>4.3 <strong>hexo</strong>博客及<strong>gallery</strong>相册<strong>git远程仓库</strong>配置</h3><ul>\n<li><p>1.git用户下，进入到git用户主目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.新建一个文件夹,用于存放hexo博客以及gallery相册的git仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir repo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.配置hexo博客的git仓库</p>\n<ul>\n<li><p>3.1 新建一个文件夹用于存放hexo博客的git仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/git/repo &amp;&amp; mkdir blog.git &amp;&amp; cd blog.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.2 初始化一个空仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.3 配置githooks，新建一个脚本文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hooks &amp;&amp; vi post-receive</span><br><span class=\"line\"></span><br><span class=\"line\">复制以下代码粘贴保存退出</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">GIT_REPO=/home/git/repo/blog.git #git仓库目录</span><br><span class=\"line\">TMP_GIT_CLONE=/tmp/hexo</span><br><span class=\"line\">PUBLIC_WWW=/home/wwwroot/blog #代码存放目录</span><br><span class=\"line\">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class=\"line\">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class=\"line\">rm -rf $&#123;PUBLIC_WWW&#125;/*</span><br><span class=\"line\">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.4 修改权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.5 修改所有者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown git:git -R /home/wwwgit/blogs</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><p>4.配置gallery相册的git仓库</p>\n<ul>\n<li><p>4.1 新建一个文件夹用于存放gallery相册的git仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/git/repo &amp;&amp;mkdir gallery.git &amp;&amp; cd gallery.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.2 初始化一个空仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.3 老规矩，同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hooks &amp;&amp; vi post-receive</span><br><span class=\"line\"></span><br><span class=\"line\">老规矩，复制以下代码粘贴保存退出</span><br><span class=\"line\">git --work-tree=/home/wwwroot/gallery--git-dir=/home/git/repo/gallery.git checkout -f</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.4 修改权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.5 修改所有者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown git:git -R /home/wwwgit/gallery</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>至此，在vps服务器上面已经配置好了hexo博客以及gallery相册的git托管仓库了，仓库地址放在/home/git/repo目录下，代码放在/home/wwwroot目录下。</p>\n<h2 id=\"5-Nginx配置\"><a href=\"#5-Nginx配置\" class=\"headerlink\" title=\"5. Nginx配置\"></a>5. Nginx配置</h2><h3 id=\"5-1-查看nginx默认配置文件\"><a href=\"#5-1-查看nginx默认配置文件\" class=\"headerlink\" title=\"5.1 查看nginx默认配置文件\"></a>5.1 查看nginx默认配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/local/nginx/conf/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">找到以下代码：</span><br><span class=\"line\">server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        listen 80 default_server;</span><br><span class=\"line\">        #listen [::]:80 default_server ipv6only=on;</span><br><span class=\"line\">        server_name _;</span><br><span class=\"line\">        index index.html index.htm index.php;</span><br><span class=\"line\">        root  /home/wwwroot/default;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">include vhost/*.conf;</span><br></pre></td></tr></table></figure>\n<p>看到nginx默认配置，虚拟主机配置，监听80端口，索引文件名称为index.html index.htm index.php，索引文件根路径为/home/wwwroot/default。</p>\n<p>在浏览器中输入ip地址可以看到打开的是<strong>LNMP一键安装包安装成功</strong>提示网页。</p>\n<p>接下来cd到/home/wwwroot/default目录下，可以看到该目录下已经存在如下这些文件，也就是你在浏览器中通过ip地址打开的LNMP一键安装包安装成功提示网页的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@vultr default]# cd /home/wwwroot/default</span><br><span class=\"line\">[root@vultr default]# ls -l</span><br><span class=\"line\">total 84</span><br><span class=\"line\">-rw-r--r--  1 root root  2781 Dec 15 21:00 index.html</span><br><span class=\"line\">-rw-r--r--  1 root root  5683 Dec 15 21:00 lnmp.gif</span><br><span class=\"line\">-rw-r--r--  1 root root 20256 Dec 15 21:00 ocp.php</span><br><span class=\"line\">-rw-r--r--  1 root root    20 Dec 15 21:00 phpinfo.php</span><br><span class=\"line\">drwxr-xr-x 14 www  www   4096 Dec 15 21:00 phpmyadmin</span><br><span class=\"line\">-rw-r--r--  1 root root 42609 Dec 15 21:00 p.php</span><br><span class=\"line\">[root@vultr default]#</span><br></pre></td></tr></table></figure>\n<p>所以我们直接将root 目录改为hexo博客的文件目录即可，但是一般不建议直接在默认的配置文件里修改，在配置文件中底部会发现<strong>include vhost/*.conf;</strong>这句，意思也就是说会去包含当前文件夹vhost文件夹下所有配置文件。所以我们就可以在vhost文件夹下新建一个虚拟主机的方式来配置hexo博客。</p>\n<h3 id=\"5-2-新建一个虚拟主机\"><a href=\"#5-2-新建一个虚拟主机\" class=\"headerlink\" title=\"5.2 新建一个虚拟主机\"></a>5.2 新建一个虚拟主机</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lnmp vhost add</span><br></pre></td></tr></table></figure>\n<p>填上你的域名，设置root为你的hexo博客文件路径即可。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171218_48.png\" alt=\"\"></p>\n<p>配置成功。</p>\n<h3 id=\"5-3-重启nginx服务\"><a href=\"#5-3-重启nginx服务\" class=\"headerlink\" title=\"5.3 重启nginx服务\"></a>5.3 重启nginx服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>至此，nginx配置成功。</p>\n<hr>\n<p>此时，在浏览器中输入域名访问网页，dns解析到绑定的ip也就是你的vps分配给你ip地址，读取该配置文件中root目录下的文件资源也就是你的hexo博客目录的资源文件，加载博客页面。发现打开的是个403页面（当然了，因为/home/wwwroot/hexo目录下并没有任何文件。）。</p>\n<p>接下来就是要将本地hexo博客使用git从本地上传到服务器上就可以了。</p>\n<p>至此，服务端的配置已经基本完成。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>环境：</p>\n<p>vps环境：CentOS 6.9</p>\n<p>本机环境：macOS10.12</p>\n</blockquote>\n<hr>\n<h2 id=\"1-SSH登录VPS\"><a href=\"#1-SSH登录VPS\" class=\"headerlink\" title=\"1. SSH登录VPS\"></a>1. SSH登录VPS</h2><h2 id=\"2-搭建LNMP环境\"><a href=\"#2-搭建LNMP环境\" class=\"headerlink\" title=\"2. 搭建LNMP环境\"></a>2. 搭建LNMP环境</h2><h3 id=\"2-1-cd到root用户目录下\"><a href=\"#2-1-cd到root用户目录下\" class=\"headerlink\" title=\"2.1 cd到root用户目录下\"></a>2.1 cd到root用户目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /root # 安装包下载目录</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"2-2-下载lnmp一键安装包\"><a href=\"#2-2-下载lnmp一键安装包\" class=\"headerlink\" title=\"2.2 下载lnmp一键安装包\"></a>2.2 下载lnmp一键安装包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz # 版本随意</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-解压缩到-usr-local目录下\"><a href=\"#2-3-解压缩到-usr-local目录下\" class=\"headerlink\" title=\"2.3 解压缩到/usr/local目录下\"></a>2.3 解压缩到/usr/local目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxf lnmp1.4.tar.gz -C /usr/local # 安装目录要放在/usr路径下</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-安装\"><a href=\"#2-4-安装\" class=\"headerlink\" title=\"2.4 安装\"></a>2.4 安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/lnmp1.4 &amp;&amp; ./install.sh</span><br></pre></td></tr></table></figure>\n<p>然后会出现一些安装提示选项，一路回车键就好。然后就开始安装各种软件，来杯82年的java，稍等片刻，安装完成。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171215_33.png\" alt=\"\"></p>\n<p>出现如上提示表示安装完成。输入<strong>lnmp help</strong>命令查看更多使用帮助。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171218_1.png\" alt=\"Snip20171218_1.png\"></p>\n<p>在浏览器中输入<strong>vps</strong>的<strong>ip</strong>地址，将会看到如下提示页面。至此，<strong>lnmp</strong>环境已经安装完成。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171215_34.png\" alt=\"\"></p>\n<h2 id=\"3-安装Node环境\"><a href=\"#3-安装Node环境\" class=\"headerlink\" title=\"3. 安装Node环境\"></a>3. <strong>安装Node环境</strong></h2><blockquote>\n<p>个人相册使用的是zing-gallery的开源项目。因为需要在服务端开启一个node服务，所以这里需要配置好node环境。</p>\n</blockquote>\n<h3 id=\"3-1-cd到root用户目录下\"><a href=\"#3-1-cd到root用户目录下\" class=\"headerlink\" title=\"3.1 cd到root用户目录下\"></a>3.1 cd到root用户目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /root</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-下载node安装包\"><a href=\"#3-2-下载node安装包\" class=\"headerlink\" title=\"3.2 下载node安装包\"></a>3.2 下载<strong>node</strong>安装包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nodejs.org/dist/v6.4.0/node-v6.4.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-解压缩到-usr-local目录下\"><a href=\"#3-3-解压缩到-usr-local目录下\" class=\"headerlink\" title=\"3.3 解压缩到/usr/local目录下\"></a>3.3 解压缩到/usr/local目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf node-v6.4.0-linux-x86.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-添加环境变量\"><a href=\"#3-4-添加环境变量\" class=\"headerlink\" title=\"3.4 添加环境变量\"></a>3.4 添加环境变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\">在最底下添加以下代码</span><br><span class=\"line\">export NODE_HOME=/usr/local/node-v6.4.0-linux-x64</span><br><span class=\"line\">export PATH=$PATH:$NODE_HOME/bin</span><br><span class=\"line\">export NODE_PATH=$NODE_HOME/lib/node_modules</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-source-etc-profile\"><a href=\"#3-5-source-etc-profile\" class=\"headerlink\" title=\"3.5 source /etc/profile\"></a>3.5 source /etc/profile</h3><h3 id=\"3-6-node-v\"><a href=\"#3-6-node-v\" class=\"headerlink\" title=\"3.6 node -v\"></a>3.6 node -v</h3><h3 id=\"3-7-npm-v\"><a href=\"#3-7-npm-v\" class=\"headerlink\" title=\"3.7 npm -v\"></a>3.7 npm -v</h3><p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171215_36.png\" alt=\"\"></p>\n<p><strong>PS:</strong></p>\n<p>如果需要升级<strong>node</strong>，可以使用<strong>node</strong>升级神器<strong>-n</strong>。</p>\n<p>1.全局安装n</p>\n<p>​    npm install -g n</p>\n<p>2.查看版本</p>\n<p>​    n -V</p>\n<p>3.卸载当前的node</p>\n<p>4.使用n安装node</p>\n<p>​    n stable（稳定的正式版本）</p>\n<p>​    n latest（官方最新的发布版本）</p>\n<p>​    n lts（最新的LTS正式版本）</p>\n<p>​    n 9.2.0 （安装指定版本）</p>\n<p>具体使用<strong>n help</strong>查看帮助</p>\n<h2 id=\"4-配置Git仓库\"><a href=\"#4-配置Git仓库\" class=\"headerlink\" title=\"4. 配置Git仓库\"></a>4. <strong>配置Git仓库</strong></h2><blockquote>\n<p>静态博客和个人相册的代码，你可以选择托管到github或者coding.net上。然后使用webhooks，在你每次本地push之后，触发post-receive脚本，然后在个人vps上，拉取远程仓库的代码。</p>\n<p>因为是自己的vps，想怎么搞就怎么搞，所以在vps上搭建好git环境，我就直接将博客和相册代码托管到vps上了，没有使用github和coding.net。</p>\n</blockquote>\n<h3 id=\"4-1-安装git\"><a href=\"#4-1-安装git\" class=\"headerlink\" title=\"4.1 安装git\"></a>4.1 安装git</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br></pre></td></tr></table></figure>\n<p>如果安装过git，会提示git版本号。<br>如果没有安装过，使用下面的命令安装git，安装完查看git版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y git</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-用户配置\"><a href=\"#4-2-用户配置\" class=\"headerlink\" title=\"4.2 用户配置\"></a>4.2 用户配置</h3><ul>\n<li><p>1.新建一个git用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.修改密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd git # 输入密码，确认密码即可</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.配置git用户</p>\n<ul>\n<li><p>3.1切换到git用户目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su git </span><br><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.2添加ssh公钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p ~/.ssh</span><br><span class=\"line\">vi ~/.ssh/authorized_keys # 在电脑的命令行中执行 cat ~/.ssh/id_rsa.pub | pbcopy # 将公钥复制粘贴到authorized_keys，然后保存退出</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.3添加文件及目录权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 700 ~/.ssh</span><br><span class=\"line\">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.4设置git用户ssh免密码登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root # 切换到root用户</span><br><span class=\"line\">chmod 740 /etc/sudoers # 修改权限</span><br><span class=\"line\">vi /etc/sudoers</span><br><span class=\"line\"></span><br><span class=\"line\">找到以下内容</span><br><span class=\"line\">## Allow root to run any commands anywhere</span><br><span class=\"line\">root    ALL=(ALL)     ALL</span><br><span class=\"line\">在下面加上一行,保存退出</span><br><span class=\"line\">git ALL=(ALL) ALL </span><br><span class=\"line\"></span><br><span class=\"line\">chmod 400 /etc/sudoers # 恢复为原来的权限</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>exit退出，使用<strong>git</strong>用户用<strong>ssh</strong>登录</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>ps：</strong></p>\n<p>如果你刚输完密码，然后再若干秒之后忘了密码。比如我，这时你就可以用到以下命令。</p>\n<p>userdel -r git</p>\n<p>如果出现userdel: user git is currently used by process 10958</p>\n<p>ps -u git | awk ‘{print $1}’ | grep -vi pid | xargs kill -9</p>\n<p>kill用户相关进程，之后再次执行删除用户命令</p>\n<h3 id=\"4-3-hexo博客及gallery相册git远程仓库配置\"><a href=\"#4-3-hexo博客及gallery相册git远程仓库配置\" class=\"headerlink\" title=\"4.3 hexo博客及gallery相册git远程仓库配置\"></a>4.3 <strong>hexo</strong>博客及<strong>gallery</strong>相册<strong>git远程仓库</strong>配置</h3><ul>\n<li><p>1.git用户下，进入到git用户主目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.新建一个文件夹,用于存放hexo博客以及gallery相册的git仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir repo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.配置hexo博客的git仓库</p>\n<ul>\n<li><p>3.1 新建一个文件夹用于存放hexo博客的git仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/git/repo &amp;&amp; mkdir blog.git &amp;&amp; cd blog.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.2 初始化一个空仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.3 配置githooks，新建一个脚本文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hooks &amp;&amp; vi post-receive</span><br><span class=\"line\"></span><br><span class=\"line\">复制以下代码粘贴保存退出</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">GIT_REPO=/home/git/repo/blog.git #git仓库目录</span><br><span class=\"line\">TMP_GIT_CLONE=/tmp/hexo</span><br><span class=\"line\">PUBLIC_WWW=/home/wwwroot/blog #代码存放目录</span><br><span class=\"line\">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class=\"line\">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class=\"line\">rm -rf $&#123;PUBLIC_WWW&#125;/*</span><br><span class=\"line\">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.4 修改权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.5 修改所有者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown git:git -R /home/wwwgit/blogs</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><p>4.配置gallery相册的git仓库</p>\n<ul>\n<li><p>4.1 新建一个文件夹用于存放gallery相册的git仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/git/repo &amp;&amp;mkdir gallery.git &amp;&amp; cd gallery.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.2 初始化一个空仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.3 老规矩，同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hooks &amp;&amp; vi post-receive</span><br><span class=\"line\"></span><br><span class=\"line\">老规矩，复制以下代码粘贴保存退出</span><br><span class=\"line\">git --work-tree=/home/wwwroot/gallery--git-dir=/home/git/repo/gallery.git checkout -f</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.4 修改权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.5 修改所有者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown git:git -R /home/wwwgit/gallery</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>至此，在vps服务器上面已经配置好了hexo博客以及gallery相册的git托管仓库了，仓库地址放在/home/git/repo目录下，代码放在/home/wwwroot目录下。</p>\n<h2 id=\"5-Nginx配置\"><a href=\"#5-Nginx配置\" class=\"headerlink\" title=\"5. Nginx配置\"></a>5. Nginx配置</h2><h3 id=\"5-1-查看nginx默认配置文件\"><a href=\"#5-1-查看nginx默认配置文件\" class=\"headerlink\" title=\"5.1 查看nginx默认配置文件\"></a>5.1 查看nginx默认配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/local/nginx/conf/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">找到以下代码：</span><br><span class=\"line\">server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        listen 80 default_server;</span><br><span class=\"line\">        #listen [::]:80 default_server ipv6only=on;</span><br><span class=\"line\">        server_name _;</span><br><span class=\"line\">        index index.html index.htm index.php;</span><br><span class=\"line\">        root  /home/wwwroot/default;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">include vhost/*.conf;</span><br></pre></td></tr></table></figure>\n<p>看到nginx默认配置，虚拟主机配置，监听80端口，索引文件名称为index.html index.htm index.php，索引文件根路径为/home/wwwroot/default。</p>\n<p>在浏览器中输入ip地址可以看到打开的是<strong>LNMP一键安装包安装成功</strong>提示网页。</p>\n<p>接下来cd到/home/wwwroot/default目录下，可以看到该目录下已经存在如下这些文件，也就是你在浏览器中通过ip地址打开的LNMP一键安装包安装成功提示网页的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@vultr default]# cd /home/wwwroot/default</span><br><span class=\"line\">[root@vultr default]# ls -l</span><br><span class=\"line\">total 84</span><br><span class=\"line\">-rw-r--r--  1 root root  2781 Dec 15 21:00 index.html</span><br><span class=\"line\">-rw-r--r--  1 root root  5683 Dec 15 21:00 lnmp.gif</span><br><span class=\"line\">-rw-r--r--  1 root root 20256 Dec 15 21:00 ocp.php</span><br><span class=\"line\">-rw-r--r--  1 root root    20 Dec 15 21:00 phpinfo.php</span><br><span class=\"line\">drwxr-xr-x 14 www  www   4096 Dec 15 21:00 phpmyadmin</span><br><span class=\"line\">-rw-r--r--  1 root root 42609 Dec 15 21:00 p.php</span><br><span class=\"line\">[root@vultr default]#</span><br></pre></td></tr></table></figure>\n<p>所以我们直接将root 目录改为hexo博客的文件目录即可，但是一般不建议直接在默认的配置文件里修改，在配置文件中底部会发现<strong>include vhost/*.conf;</strong>这句，意思也就是说会去包含当前文件夹vhost文件夹下所有配置文件。所以我们就可以在vhost文件夹下新建一个虚拟主机的方式来配置hexo博客。</p>\n<h3 id=\"5-2-新建一个虚拟主机\"><a href=\"#5-2-新建一个虚拟主机\" class=\"headerlink\" title=\"5.2 新建一个虚拟主机\"></a>5.2 新建一个虚拟主机</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lnmp vhost add</span><br></pre></td></tr></table></figure>\n<p>填上你的域名，设置root为你的hexo博客文件路径即可。</p>\n<p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171218_48.png\" alt=\"\"></p>\n<p>配置成功。</p>\n<h3 id=\"5-3-重启nginx服务\"><a href=\"#5-3-重启nginx服务\" class=\"headerlink\" title=\"5.3 重启nginx服务\"></a>5.3 重启nginx服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>至此，nginx配置成功。</p>\n<hr>\n<p>此时，在浏览器中输入域名访问网页，dns解析到绑定的ip也就是你的vps分配给你ip地址，读取该配置文件中root目录下的文件资源也就是你的hexo博客目录的资源文件，加载博客页面。发现打开的是个403页面（当然了，因为/home/wwwroot/hexo目录下并没有任何文件。）。</p>\n<p>接下来就是要将本地hexo博客使用git从本地上传到服务器上就可以了。</p>\n<p>至此，服务端的配置已经基本完成。</p>"},{"layout":"post","title":"MacOS+GitLab+Jenkins构建iOS自动化打包平台教程","date":"2017-12-03T15:45:00.000Z","comments":1,"toc":true,"_content":"## 一、Jenkins\n\n> Jenkins是一个Java项目，依赖于Java环境。在命令行中输入java -version，如果安装过就会出现对应的Java版本。没有则进入[JavaSDK官网](https://link.jianshu.com/?t=http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)下载安装。\n\n### 1. 安装\n\n> Jenkins安装方式有好几种，建议使用homebrew方式来进行安装Jenkins。因为用dmg方式安装的Jenkins默认会生成一个Shared的jenkins用户，且安装路径为/Users/xx/Shared。\n\n<!-- more -->\n\n#### 1.1 brew安装\n\n> Homebrew是一款Mac OS平台下的软件包管理工具，如果没有安装过[homebrew](https://brew.sh/)，在命令行中输入如下命令安装：\n>\n> ```\n> /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\n> ```\n>\n> \n\n- 安装jenkins\n\n  ```\n  brew install jenkins\n  ```\n\n- 卸载jenkins\n\n  ```\n  brew uninstall jenkins\n  ```\n\n#### 1.2 修改安装路径\n\n- 安装完成自后，在命令行中cd到/Library/LaunchDaemons文件夹中\n\n  ```\n  cd /Library/LaunchDaemons\n  ```\n\n- 如果不存在org.jenkins-ci.plist文件，就手动创建一个\n\n  ```\n  sudo touch org.jenkins-ci.plist  \n  ```\n\n- 修改plist内容，JENKINS_HOME的值修改为你想要放置的安装路径即可\n\n  ```\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n  <plist version=\"1.0\">\n    <dict>\n      <key>StandardOutPath</key>\n      <string>/var/log/jenkins/jenkins.log</string>\n      <key>StandardErrorPath</key>\n      <string>/var/log/jenkins/jenkins.log</string>\n      <key>EnvironmentVariables</key>\n      <dict>\n        <key>JENKINS_HOME</key>\n        <string>/Users/ci/.jenkins</string>\n      </dict>\n      <key>GroupName</key>\n      <string>daemon</string>\n      <key>KeepAlive</key>\n      <true/>\n      <key>Label</key>\n      <string>org.jenkins-ci</string>\n      <key>ProgramArguments</key>\n      <array>\n        <string>/bin/bash</string>\n        <string>/Library/Application Support/Jenkins/jenkins-runner.sh</string>\n      </array>\n      <key>RunAtLoad</key>\n      <true/>\n      <key>UserName</key>\n      <string>jenkins</string>\n      <key>SessionCreate</key>\n      <true/>\n    </dict>\n  </plist>\n  ```\n\n- 开启服务并设置为开机启动\n\n  ```\n  sudo launchctl load -w /Library/LaunchDaemons/org.jenkins-ci.plist\n  ```\n\n#### 1.3 设置开机启动\n\n- 将/usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist文件拷贝到~/Library/LaunchAgents目录下\n\n  ```\n  cp -p /usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist ~/Library/LaunchAgents  \n  ```\n\n- 设置开机启动\n\n  ```\n  sudo launchctl load -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n  PS:若出现\"/Library/LaunchAgents/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions\"提示，则执行：\n  sudo chown root /Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n  之后再次执行上面命令即可\n  ```\n\n- 取消开机启动\n\n  ```\n  sudo launchctl unload -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n  ```\n\n***PS:Mac OS中，使用launchctl指令可以开启一些启动服务，其中/Library/LaunchAgents中存放的是一些用户登陆后启动的服务。而/Library/LaunchDaemons中存放的就是用户未登录前就可以启动的服务。常用的命令有：launchctl load、launchctl unload、launchctl remove 、launchctl list***\n\n\n\n### 2.初始化\n\n> 安装完成之后，重启电脑，Jenkins默认会开启一个端口号为8080的本地的web服务。\n>\n> 在浏览器中输入localhost:8080访问Jenkins页面，进行初始化。\n\n#### 2.1 Unlock Jenkins\n\n按照提示打开文件，获取密码，复制密码到输入框中，继续。\n\n#### 2.2 Customize Jenkins\n\n### 3. 环境配置\n\n#### 3.1 插件下载\n\n> 系统管理-管理插件-可选插件-过滤搜索-直接安装\n>\n> 如果无法获取插件，可以在系统管理-管理插件-高级-升级站点，将默认的https网址修改为http的。\n\n必选插件：\n\n- Git client plugin 、Git plugin、Git server Plugin\n- GitHub API Plugin、GitHub Branch Source Plugin、GitHub Organization Folder Plugin、GitHub plugin\n- GitLab Authentication plugin、Gitlab Hook Plugin、GitLab logo Plugin、GitLab Plugin\n- Xcode integration\n\n#### 3.2 gitlab配置\n\n在Credentials中添加凭证。我选择的是SSH授权。Username是你的gitlab用户名。查看本机.ssh/is_rsa中保存的私钥，将你gitlab账号中上传的SSH Key对应的私钥复制粘贴到Private Key中即可。Passphrase填写你当时生成ssh key的时候的密码即可。\n\n### 4. 项目配置\n\n## 二、打包脚本\n\n### 1. 相关知识整理\n\n#### 1.1 PlistBuddy\n\n> plist文件是一种xml类型的在Mac OS以及iOS中最常见的一种文件格式，通过键值对的方式进行配置。PlistBuddy则是Mac自带的一个专门用来解析plist文件的工具。PlistBuddy支持的字段类型有：string、array、dict、bool、real、integer、date、data。具体使用可以在命令行中输入/usr/libexec/PlistBuddy --help来查看使用帮助\n\n**基本使用介绍：**\n\n- 添加\n\n  - 添加普通字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Add :Version string 1.0' test.plist\n    ```\n\n    ​\n\n  - 添加数组字段\n\n    ```\n    # 先添加key值\n    /usr/libexec/PlistBuddy -c 'Add :Application array' test.plist\n    # 添加value值\n    /usr/libexec/PlistBuddy -c 'Add :Application: string app1' test.plist\n    /usr/libexec/PlistBuddy -c 'Add :Application: string app2' test.plist\n    /usr/libexec/PlistBuddy -c 'Add :Application: string app3' test.plist\n    ```\n\n    ​\n\n  - 添加字典字段\n\n    ```\n    # 先添加key值\n    /usr/libexec/PlistBuddy -c 'Add :Person dict' test.plist\n    # 添加value值,\n    /usr/libexec/PlistBuddy -c 'Add :Person:Name string zs' test.plist\n    /usr/libexec/PlistBuddy -c 'Add :Person:Age integer 3' test.plist\n    ```\n\n    ​\n\n- 删除\n\n  - 删除普通字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Delete :Version' test.plist\n    ```\n\n    ​\n\n  - 删除字典字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Delete :Person:Age' test.plist\n    ```\n\n    ​\n\n  - 删除数组字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Delete :Application:2' test.plist\n    ```\n\n    ​\n\n- 修改\n\n  - 修改数组字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Set :Application:1 \"APP2\"' test.plist\n    ```\n\n    ​\n\n  - 修改字典字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Set :Person:Name \"ls\"' test.plist\n    ```\n\n    ​\n\n\n- 查找\n\n  - 查找打印字段对应的值\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Print :Person' test.plist\n    ```\n\n  - 查找数组中对应元素的值\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Print :Application:2' test.plist\n    ```\n\n  ​\n\n#### 1.2 xcodebuild\n\n> \n\n**xcodebuild工作细节：**\n\n- Check dependencies（检查项目配置，如Code Sign） -> Preprocessor -> Compile -> Link -> Copy Resource、Compile Xib、CompileStoryboard、CompileAssetCatalog -> Generate DSYM File -> ProcessProductPackaging -> Code Signing（需要访问钥匙串信息） -> Validate -> Result（.app和.dSYM）\n- Code Signing（Code Signing Identity，Provisioning Profile）\n\n**常用命令:**\n\n- clean\n\n  ```\n  xcodebuild clean -workspace ${Workspace_Name} -scheme ${Scheme_Name}\n  参数说明：\n  * -workspace ${Workspace_Name} \n    指定工作空间文件XXX.xcworkspace\n  * -scheme ${Scheme_Name} \n    指定构建工程名称\n  ```\n\n- archive\n\n  ```\n  xcodebuild archive\n  -archivePath \"${Archive_Path}\" \n  -workspace ${Workspace_Name} \n  -scheme ${Scheme_Name} \n  -configuration ${Build_Config} \n  CODE_SIGN_IDENTITY=\"${Cert_Identity}\" \n  DEVELOPMENT_TEAM=\"${Team_ID}\"\n  PROVISIONING_PROFILE_SPECIFIER=\"${Mobile_Provision_UUID}\"  \n  参数说明：\n  *  -archivePath \"${Archive_Path}\" \n    Archive后文件导出的路径\n  * -workspace ${Workspace_Name} \n    工作空间文件名称（XXX.xcworkspace）\n  * -scheme ${Scheme_Name} \n    项目名称\n  * -configuration ${Build_Config} \n    构建配置（Debug/Release）\n  * CODE_SIGN_IDENTITY=\"${Cert_Identity}\" \n    打包证书名称\n  * DEVELOPMENT_TEAM=\"${Team_ID}\"\n    证书teamID\n  * PROVISIONING_PROFILE_SPECIFIER=\"${Mobile_Provision_UUID}\"  \n    描述文件的UUID\n  ```\n\n\n- export\n\n  ```\n  xcodebuild\n  -exportArchive \n  -archivePath \"${Archive_Path}\" \n  -exportPath ${Ipa_Name} \n  -exportFormat ipa \n  -exportWithOriginalSigningIdentity \n  参数说明：\n  * -exportArchive \n  * -archivePath \"${Archive_Path}\"\n  * -exportPath ${Ipa_Name} \n  * -exportFormat ipa \n  * -exportWithOriginalSigningIdentity \n  ```\n\n  ​\n\n#### 1.3 OCLint\n\n> OCLint是一个静态代码分析工具，在Jenkins打包脚本中引入 OCLint 的目的，一方面是为了CodeReview。另一方面在编译失败的情况下输出分析日志，方便我们定位问题。\n>\n> OCLint的工作流程：\n>\n> 编译-->xcodebuild(生成xcodebuild.log)-->xcpretty(分析xcodebuild.log生成compile_commands.json文件)-->oclint-json-compilation-database(获取编译信息)-->oclint(输出分析报告)\n\n- brew安装\n\n  ```\n  brew tap oclint/formulae\n  brew install oclint\n  ```\n\n- 相关命令介绍\n\n  - 1.oclint：基础指令。通过这个指令可以指定加载验证规则、编译代码、分析代码和生成报告。\n  - 2.oclint-json-compilation-database：高级指令。通过这个指令可以从 compile_commands.json 文件中读取配置信息并执行 oclint。\n  - 3.oclint-xcodebuild：主要用于生成compile_commands.json文件，已经不进行维护了，用xcpretty替代来生成json文件。\n\n- 使用\n\n  - 输出编译报告\n\n    xodebuild生成分析xcodebuild.log文件，xcpretty分析xcodebuild.log生成compile_commands.json文件。\n\n    tee命令获取输出结果。xcpretty命令将编译结果输出为json-compilation-database类型的编译报告。\n\n    ```\n    xcodebuild archive -archivePath \"${Archive_Path}\" -workspace ${Workspace_Name} -scheme ${Scheme_Name} -configuration ${Build_Config} CODE_SIGN_IDENTITY=\"${Cert_Identity}\" DEVELOPMENT_TEAM=\"${Team_ID}\" PROVISIONING_PROFILE_SPECIFIER=\"${Mobile_Provision_UUID}\" | tee xcodebuild.log | xcpretty --report json-compilation-database\n    ```\n\n  - 输出分析报告\n\n    根据上一步xcpretty生成的json-compilation-database类型的编译报告，然后就需要使用oclint-json-compilation-database来解析。\n\n    ```\n    oclint-json-compilation-database -e Pods -v -- -report-type html -o \"${Report_HTML}\" -max-priority-1=99999 -max-priority-2=99999 -max-priority-3=99999 1>/dev/null 2>&1\n    ```\n\n    ​\n\n### 2. 脚本文件结构\n\n### 3. 脚本描述\n\n- main.sh\n\n  ```\n  main中主要做了以下几件事情：\n  \t1.配置路径信息(例如：脚本本地目录，默认配置目录，描述文件目录，keychain目录等等)\n  \t2.配置默认证书相关信息(例如：默认证书名称，teamID,描述文件，描述文件UUID)\n  \t3.Jenkins参数设置\n  \t4.执行mainUpgrade.sh获取Jenkins项目信息，更新脚本等\n  \t5.执行diag.sh输出诊断信息\n  \t6.执行mainRun.sh开始启动打包脚本\n  ```\n\n  - mainUpgrade.sh\n\n    ```\n    mainUpgrade中主要用来获取Jenkins对应jobs的项目名称，版本号，git分支，连接等相关信息\n    ```\n\n  - diag.sh\n\n    ```\n    diag主要输出相关使用命令的诊断信息\n    ```\n\n  - mainRun.sh\n\n    ```\n    mainRun中开始真正的打包脚本执行，依次执行了如下脚本\n    1.comment.sh\n    2.info.sh\n    3.config.sh\n    4.entitlements.sh\n    5.pod.sh\n    6.version.sh\n    7.build.sh\n    8.plist.sh\n    9.html.sh\n    10.smail.sh\n    11.plistUpload.sh\n    12.dSYMUpload\n    13.appstore.sh\n    ```\n\n    - comment.sh\n\n      ```\n      用来生成本次打包的备注文案\n\n      ```\n\n    - diskClean.sh\n\n      ```\n      清理磁盘文件，清理DeriverdData,iOS DeviceSupport相关文件\n\n      ```\n\n    - info.sh\n\n      ```\n      读取项目工程信息\n\n      ```\n\n      - infoGit.sh\n\n        ```\n        主要做了2件事情：\n        1.读取项目git信息，包括项目名称，项目当前分支名称\n        2.读取打包配置文件(一个plist类型的文件，里面配置了对应项目的打包证书enterprise，ad-hoc,appstore证书信息，添加邮件抄送，debug/release等等一些打包配置信息)\n\n        ```\n\n      - infoProject.sh\n\n        ```\n        用来获取项目工程中的信息，包括workspace路径，bundleIdentigier,infoPlist路径，build号，version号等等\n\n        ```\n\n      - infoPath.sh\n\n        ```\n        用于配置和生成打包输出的相关文件路径，包括Archive文件路径，ipa文件路径，dSYM文件路径，Html文件路径，OCLint文件路径等等。\n\n        ```\n\n    - config.sh\n\n      ```\n      读取证书配置，配置证书相关信息。配置bugly信息。设置编译类型。设置输出包类型等等。\n\n      ```\n\n      - configCert.sh\n\n        ```\n        根据打包配置文件以及Jenkins配置信息，读取对应method(输出包类型)相对应的打包证书，描述文件，teamID，描述文件UUID等相关信息。\n\n        ```\n\n    - entitlements.sh\n\n      ```\n      读取相应的描述文件信息，利用plsitbuddy分别修改了.pbxproj以及.entitlements文件中的相关权限配置。\n\n      ```\n\n    - pod.sh\n\n      ```\n      pod repo update 以及 pod update\n\n      ```\n\n    - version.sh\n\n      ```\n      更新版本号，读取本地的一个用于记录版本号的文件。更新方式有2种方式，一种为版本号自增，一种为使用自定义的版本号。设置完更新文件即可。\n\n      ```\n\n    - build.sh\n\n      ```\n      1.修复keychain，导入 login.keychain\n      2.archive 和 oclint\n      3.\n\n      ```\n\n      - fixKeychain.sh\n\n      - buildArchiveOrOCLint.sh\n\n      - dSYM.sh\n\n        ```\n        将打包成功之后生成的.dSYM分别复制到项目路径以及dSYM导出路径下，并且将.dSYM文件压缩成zip包。\n        ps：切记项目 buildSetting 搜索『dwraf』找到 『Debug Information Format』,应设置为『DWRAF with dSYM File』, 否则编译不会生成 dSYM 文件\n\n        ```\n\n      - reSign.sh\n\n    - plist.sh\n\n      ```\n      这个脚本是用来生成一个plist文件，用来提供给itms-services://协议使用的，其中itms-services://协议中最主要的也就是这个plist文件。在之后会生成一个html文件，会将这个itms-services://协议添加进\"下载\"标签的href中。这样在safari浏览器中打开这个网页，点击下载，就可以很方便的下载安装包。\n\n      脚本参考代码如下：\n      #!/bin/sh\n\n      Install_Plist_Name=${Ipa_Name}_install.plist\n      Install_Plist_Path=\"${Install_Path}/${Install_Plist_Name}\"\n      Install_Ipa_URL=\"${Download_Ipa_URL}/${Ipa_Name}.ipa\"\n\n      cat << EOF > $Install_Plist_Path\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n      <plist version=\"1.0\">\n      <dict>\n      \t<key>items</key>\n      \t<array>\n          \t<dict>\n              \t<key>assets</key>\n              \t<array>\n      \t            <dict>\n      \t                <key>kind</key>\n      \t                <string>software-package</string>\n      \t                <key>url</key>\n      \t               \t<string>$Install_Ipa_URL</string>\n      \t            </dict>\n                  </array>\n                  <key>metadata</key>\n                  <dict>\n                      <key>bundle-identifier</key>\n                      <string>$Bundle_Identifier</string>\n                      <key>bundle-version</key>\n                     \t<string>$New_BuildVersion</string>\n                      <key>kind</key>\n                     \t<string>software</string>\n                      <key>title</key>\n                     \t<string>$Bundle_App_Name</string>\n                  </dict>\n              </dict>\n      \t</array>\n      </dict>\n      </plist>\n      EOF\n\n      ```\n\n    - html.sh\n\n      ```\n      生成一个静态页面用于展示打包信息以及绑定生成好的itms-services://协议，然后使用一个写好的js二维码生成库，生成一个网页链接二维码。\n      网页包含内容：\n      1.项目名称\n      2.证书名称\n      3.版本号\n      4.编译号\n      5.备注信息\n      6.二维码\n\n      ```\n\n    - smail.sh\n\n      - emails.sh\n\n        ```\n        用来生成邮件信息\n\n        ```\n\n      - sendmail.py\n\n        ```\n        发送邮件的脚本\n\n        ```\n\n    - plistUpload.sh\n\n      ```\n      提交之前生成好的plist文件到一个https站点（iOS7之后不支持http）, 这里就使用了coding.net的仓库。\n\n      ```\n\n    - dSYMUpload\n\n      ```\n      因为自家接入的是bugly，每次app上线后，手动上传dSYM文件很麻烦。所以这里弄了个脚本，根据Jenkins配置信息是否是否上传bugly。将之前生成好的.dSYM.zip自动上传到bugly。\n\n      上传参考代码：\n      #!/bin/sh\n\n      URLEncodeFunc() {\n      \tlocal length=\"${#1}\"\n      \tfor (( i = 0; i < length; i++ )); do\n      \t\tlocal c=\"${1:i:1}\"\n      \t\tcase $c in\n      \t\t\t[a-zA-Z0-9.~_-]) printf \"$c\" ;;\n      \t\t\t*) printf \"$c\" | xxd -p -c1 | while read x;do printf \"%%%s\" \"$x\";done\n      \t\tesac\n      \tdone\n      }\n\n      if [[ $Jenkins_dSYM_Upload = true ]]; then\n      \techo \"\\n上传 dSYM 到 Bugly...\"\n\n      \t# Bugly 的 TS 说他们要的是这样的版本号格式\n      \tBugly_Version=\"${Bundle_Version}(${New_BuildVersion})\"\n      \t\n      \t# pid默认为2\n      \tdSYM_Pid=\"2\"\n      \tdSYM_AppID=${Bugly_AppId}\n      \tdSYM_AppKey=${Bugly_AppKey}\n      \tdSYM_BundleId=${Bundle_Identifier}\n      \tdSYM_Version=`URLEncodeFunc ${Bugly_Version}`\n      \tdSYM_ZipFileName=`URLEncodeFunc ${dSYM_Path}`\n\n      \tjava -jar ${Bugly_JAR_Path} -i ${dSYM_Path} -u -id ${dSYM_AppID} -key ${dSYM_AppKey} -package ${dSYM_BundleId} -version ${dSYM_Version} 1>/dev/null\n\n      else\n      \techo \"\\n不上传 dSYM 到 bugly\\n\"\n      fi\n\n      rm -rf ${dSYM_Path}\n\n\n      ```\n\n    - appstore.sh","source":"_posts/MacOS+GitLab+Jenkins构建iOS自动化打包平台教程.md","raw":"---\nlayout: post\ntitle: \"MacOS+GitLab+Jenkins构建iOS自动化打包平台教程\"\ndate: 2017-12-03 23:45\ncategories: \n- 教程\n- [教程, Jenkins]\ntags: \n- 教程\n- Jenkins\ncomments: true\ntoc: true\n---\n## 一、Jenkins\n\n> Jenkins是一个Java项目，依赖于Java环境。在命令行中输入java -version，如果安装过就会出现对应的Java版本。没有则进入[JavaSDK官网](https://link.jianshu.com/?t=http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)下载安装。\n\n### 1. 安装\n\n> Jenkins安装方式有好几种，建议使用homebrew方式来进行安装Jenkins。因为用dmg方式安装的Jenkins默认会生成一个Shared的jenkins用户，且安装路径为/Users/xx/Shared。\n\n<!-- more -->\n\n#### 1.1 brew安装\n\n> Homebrew是一款Mac OS平台下的软件包管理工具，如果没有安装过[homebrew](https://brew.sh/)，在命令行中输入如下命令安装：\n>\n> ```\n> /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\n> ```\n>\n> \n\n- 安装jenkins\n\n  ```\n  brew install jenkins\n  ```\n\n- 卸载jenkins\n\n  ```\n  brew uninstall jenkins\n  ```\n\n#### 1.2 修改安装路径\n\n- 安装完成自后，在命令行中cd到/Library/LaunchDaemons文件夹中\n\n  ```\n  cd /Library/LaunchDaemons\n  ```\n\n- 如果不存在org.jenkins-ci.plist文件，就手动创建一个\n\n  ```\n  sudo touch org.jenkins-ci.plist  \n  ```\n\n- 修改plist内容，JENKINS_HOME的值修改为你想要放置的安装路径即可\n\n  ```\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n  <plist version=\"1.0\">\n    <dict>\n      <key>StandardOutPath</key>\n      <string>/var/log/jenkins/jenkins.log</string>\n      <key>StandardErrorPath</key>\n      <string>/var/log/jenkins/jenkins.log</string>\n      <key>EnvironmentVariables</key>\n      <dict>\n        <key>JENKINS_HOME</key>\n        <string>/Users/ci/.jenkins</string>\n      </dict>\n      <key>GroupName</key>\n      <string>daemon</string>\n      <key>KeepAlive</key>\n      <true/>\n      <key>Label</key>\n      <string>org.jenkins-ci</string>\n      <key>ProgramArguments</key>\n      <array>\n        <string>/bin/bash</string>\n        <string>/Library/Application Support/Jenkins/jenkins-runner.sh</string>\n      </array>\n      <key>RunAtLoad</key>\n      <true/>\n      <key>UserName</key>\n      <string>jenkins</string>\n      <key>SessionCreate</key>\n      <true/>\n    </dict>\n  </plist>\n  ```\n\n- 开启服务并设置为开机启动\n\n  ```\n  sudo launchctl load -w /Library/LaunchDaemons/org.jenkins-ci.plist\n  ```\n\n#### 1.3 设置开机启动\n\n- 将/usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist文件拷贝到~/Library/LaunchAgents目录下\n\n  ```\n  cp -p /usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist ~/Library/LaunchAgents  \n  ```\n\n- 设置开机启动\n\n  ```\n  sudo launchctl load -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n  PS:若出现\"/Library/LaunchAgents/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions\"提示，则执行：\n  sudo chown root /Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n  之后再次执行上面命令即可\n  ```\n\n- 取消开机启动\n\n  ```\n  sudo launchctl unload -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n  ```\n\n***PS:Mac OS中，使用launchctl指令可以开启一些启动服务，其中/Library/LaunchAgents中存放的是一些用户登陆后启动的服务。而/Library/LaunchDaemons中存放的就是用户未登录前就可以启动的服务。常用的命令有：launchctl load、launchctl unload、launchctl remove 、launchctl list***\n\n\n\n### 2.初始化\n\n> 安装完成之后，重启电脑，Jenkins默认会开启一个端口号为8080的本地的web服务。\n>\n> 在浏览器中输入localhost:8080访问Jenkins页面，进行初始化。\n\n#### 2.1 Unlock Jenkins\n\n按照提示打开文件，获取密码，复制密码到输入框中，继续。\n\n#### 2.2 Customize Jenkins\n\n### 3. 环境配置\n\n#### 3.1 插件下载\n\n> 系统管理-管理插件-可选插件-过滤搜索-直接安装\n>\n> 如果无法获取插件，可以在系统管理-管理插件-高级-升级站点，将默认的https网址修改为http的。\n\n必选插件：\n\n- Git client plugin 、Git plugin、Git server Plugin\n- GitHub API Plugin、GitHub Branch Source Plugin、GitHub Organization Folder Plugin、GitHub plugin\n- GitLab Authentication plugin、Gitlab Hook Plugin、GitLab logo Plugin、GitLab Plugin\n- Xcode integration\n\n#### 3.2 gitlab配置\n\n在Credentials中添加凭证。我选择的是SSH授权。Username是你的gitlab用户名。查看本机.ssh/is_rsa中保存的私钥，将你gitlab账号中上传的SSH Key对应的私钥复制粘贴到Private Key中即可。Passphrase填写你当时生成ssh key的时候的密码即可。\n\n### 4. 项目配置\n\n## 二、打包脚本\n\n### 1. 相关知识整理\n\n#### 1.1 PlistBuddy\n\n> plist文件是一种xml类型的在Mac OS以及iOS中最常见的一种文件格式，通过键值对的方式进行配置。PlistBuddy则是Mac自带的一个专门用来解析plist文件的工具。PlistBuddy支持的字段类型有：string、array、dict、bool、real、integer、date、data。具体使用可以在命令行中输入/usr/libexec/PlistBuddy --help来查看使用帮助\n\n**基本使用介绍：**\n\n- 添加\n\n  - 添加普通字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Add :Version string 1.0' test.plist\n    ```\n\n    ​\n\n  - 添加数组字段\n\n    ```\n    # 先添加key值\n    /usr/libexec/PlistBuddy -c 'Add :Application array' test.plist\n    # 添加value值\n    /usr/libexec/PlistBuddy -c 'Add :Application: string app1' test.plist\n    /usr/libexec/PlistBuddy -c 'Add :Application: string app2' test.plist\n    /usr/libexec/PlistBuddy -c 'Add :Application: string app3' test.plist\n    ```\n\n    ​\n\n  - 添加字典字段\n\n    ```\n    # 先添加key值\n    /usr/libexec/PlistBuddy -c 'Add :Person dict' test.plist\n    # 添加value值,\n    /usr/libexec/PlistBuddy -c 'Add :Person:Name string zs' test.plist\n    /usr/libexec/PlistBuddy -c 'Add :Person:Age integer 3' test.plist\n    ```\n\n    ​\n\n- 删除\n\n  - 删除普通字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Delete :Version' test.plist\n    ```\n\n    ​\n\n  - 删除字典字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Delete :Person:Age' test.plist\n    ```\n\n    ​\n\n  - 删除数组字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Delete :Application:2' test.plist\n    ```\n\n    ​\n\n- 修改\n\n  - 修改数组字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Set :Application:1 \"APP2\"' test.plist\n    ```\n\n    ​\n\n  - 修改字典字段\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Set :Person:Name \"ls\"' test.plist\n    ```\n\n    ​\n\n\n- 查找\n\n  - 查找打印字段对应的值\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Print :Person' test.plist\n    ```\n\n  - 查找数组中对应元素的值\n\n    ```\n    /usr/libexec/PlistBuddy -c 'Print :Application:2' test.plist\n    ```\n\n  ​\n\n#### 1.2 xcodebuild\n\n> \n\n**xcodebuild工作细节：**\n\n- Check dependencies（检查项目配置，如Code Sign） -> Preprocessor -> Compile -> Link -> Copy Resource、Compile Xib、CompileStoryboard、CompileAssetCatalog -> Generate DSYM File -> ProcessProductPackaging -> Code Signing（需要访问钥匙串信息） -> Validate -> Result（.app和.dSYM）\n- Code Signing（Code Signing Identity，Provisioning Profile）\n\n**常用命令:**\n\n- clean\n\n  ```\n  xcodebuild clean -workspace ${Workspace_Name} -scheme ${Scheme_Name}\n  参数说明：\n  * -workspace ${Workspace_Name} \n    指定工作空间文件XXX.xcworkspace\n  * -scheme ${Scheme_Name} \n    指定构建工程名称\n  ```\n\n- archive\n\n  ```\n  xcodebuild archive\n  -archivePath \"${Archive_Path}\" \n  -workspace ${Workspace_Name} \n  -scheme ${Scheme_Name} \n  -configuration ${Build_Config} \n  CODE_SIGN_IDENTITY=\"${Cert_Identity}\" \n  DEVELOPMENT_TEAM=\"${Team_ID}\"\n  PROVISIONING_PROFILE_SPECIFIER=\"${Mobile_Provision_UUID}\"  \n  参数说明：\n  *  -archivePath \"${Archive_Path}\" \n    Archive后文件导出的路径\n  * -workspace ${Workspace_Name} \n    工作空间文件名称（XXX.xcworkspace）\n  * -scheme ${Scheme_Name} \n    项目名称\n  * -configuration ${Build_Config} \n    构建配置（Debug/Release）\n  * CODE_SIGN_IDENTITY=\"${Cert_Identity}\" \n    打包证书名称\n  * DEVELOPMENT_TEAM=\"${Team_ID}\"\n    证书teamID\n  * PROVISIONING_PROFILE_SPECIFIER=\"${Mobile_Provision_UUID}\"  \n    描述文件的UUID\n  ```\n\n\n- export\n\n  ```\n  xcodebuild\n  -exportArchive \n  -archivePath \"${Archive_Path}\" \n  -exportPath ${Ipa_Name} \n  -exportFormat ipa \n  -exportWithOriginalSigningIdentity \n  参数说明：\n  * -exportArchive \n  * -archivePath \"${Archive_Path}\"\n  * -exportPath ${Ipa_Name} \n  * -exportFormat ipa \n  * -exportWithOriginalSigningIdentity \n  ```\n\n  ​\n\n#### 1.3 OCLint\n\n> OCLint是一个静态代码分析工具，在Jenkins打包脚本中引入 OCLint 的目的，一方面是为了CodeReview。另一方面在编译失败的情况下输出分析日志，方便我们定位问题。\n>\n> OCLint的工作流程：\n>\n> 编译-->xcodebuild(生成xcodebuild.log)-->xcpretty(分析xcodebuild.log生成compile_commands.json文件)-->oclint-json-compilation-database(获取编译信息)-->oclint(输出分析报告)\n\n- brew安装\n\n  ```\n  brew tap oclint/formulae\n  brew install oclint\n  ```\n\n- 相关命令介绍\n\n  - 1.oclint：基础指令。通过这个指令可以指定加载验证规则、编译代码、分析代码和生成报告。\n  - 2.oclint-json-compilation-database：高级指令。通过这个指令可以从 compile_commands.json 文件中读取配置信息并执行 oclint。\n  - 3.oclint-xcodebuild：主要用于生成compile_commands.json文件，已经不进行维护了，用xcpretty替代来生成json文件。\n\n- 使用\n\n  - 输出编译报告\n\n    xodebuild生成分析xcodebuild.log文件，xcpretty分析xcodebuild.log生成compile_commands.json文件。\n\n    tee命令获取输出结果。xcpretty命令将编译结果输出为json-compilation-database类型的编译报告。\n\n    ```\n    xcodebuild archive -archivePath \"${Archive_Path}\" -workspace ${Workspace_Name} -scheme ${Scheme_Name} -configuration ${Build_Config} CODE_SIGN_IDENTITY=\"${Cert_Identity}\" DEVELOPMENT_TEAM=\"${Team_ID}\" PROVISIONING_PROFILE_SPECIFIER=\"${Mobile_Provision_UUID}\" | tee xcodebuild.log | xcpretty --report json-compilation-database\n    ```\n\n  - 输出分析报告\n\n    根据上一步xcpretty生成的json-compilation-database类型的编译报告，然后就需要使用oclint-json-compilation-database来解析。\n\n    ```\n    oclint-json-compilation-database -e Pods -v -- -report-type html -o \"${Report_HTML}\" -max-priority-1=99999 -max-priority-2=99999 -max-priority-3=99999 1>/dev/null 2>&1\n    ```\n\n    ​\n\n### 2. 脚本文件结构\n\n### 3. 脚本描述\n\n- main.sh\n\n  ```\n  main中主要做了以下几件事情：\n  \t1.配置路径信息(例如：脚本本地目录，默认配置目录，描述文件目录，keychain目录等等)\n  \t2.配置默认证书相关信息(例如：默认证书名称，teamID,描述文件，描述文件UUID)\n  \t3.Jenkins参数设置\n  \t4.执行mainUpgrade.sh获取Jenkins项目信息，更新脚本等\n  \t5.执行diag.sh输出诊断信息\n  \t6.执行mainRun.sh开始启动打包脚本\n  ```\n\n  - mainUpgrade.sh\n\n    ```\n    mainUpgrade中主要用来获取Jenkins对应jobs的项目名称，版本号，git分支，连接等相关信息\n    ```\n\n  - diag.sh\n\n    ```\n    diag主要输出相关使用命令的诊断信息\n    ```\n\n  - mainRun.sh\n\n    ```\n    mainRun中开始真正的打包脚本执行，依次执行了如下脚本\n    1.comment.sh\n    2.info.sh\n    3.config.sh\n    4.entitlements.sh\n    5.pod.sh\n    6.version.sh\n    7.build.sh\n    8.plist.sh\n    9.html.sh\n    10.smail.sh\n    11.plistUpload.sh\n    12.dSYMUpload\n    13.appstore.sh\n    ```\n\n    - comment.sh\n\n      ```\n      用来生成本次打包的备注文案\n\n      ```\n\n    - diskClean.sh\n\n      ```\n      清理磁盘文件，清理DeriverdData,iOS DeviceSupport相关文件\n\n      ```\n\n    - info.sh\n\n      ```\n      读取项目工程信息\n\n      ```\n\n      - infoGit.sh\n\n        ```\n        主要做了2件事情：\n        1.读取项目git信息，包括项目名称，项目当前分支名称\n        2.读取打包配置文件(一个plist类型的文件，里面配置了对应项目的打包证书enterprise，ad-hoc,appstore证书信息，添加邮件抄送，debug/release等等一些打包配置信息)\n\n        ```\n\n      - infoProject.sh\n\n        ```\n        用来获取项目工程中的信息，包括workspace路径，bundleIdentigier,infoPlist路径，build号，version号等等\n\n        ```\n\n      - infoPath.sh\n\n        ```\n        用于配置和生成打包输出的相关文件路径，包括Archive文件路径，ipa文件路径，dSYM文件路径，Html文件路径，OCLint文件路径等等。\n\n        ```\n\n    - config.sh\n\n      ```\n      读取证书配置，配置证书相关信息。配置bugly信息。设置编译类型。设置输出包类型等等。\n\n      ```\n\n      - configCert.sh\n\n        ```\n        根据打包配置文件以及Jenkins配置信息，读取对应method(输出包类型)相对应的打包证书，描述文件，teamID，描述文件UUID等相关信息。\n\n        ```\n\n    - entitlements.sh\n\n      ```\n      读取相应的描述文件信息，利用plsitbuddy分别修改了.pbxproj以及.entitlements文件中的相关权限配置。\n\n      ```\n\n    - pod.sh\n\n      ```\n      pod repo update 以及 pod update\n\n      ```\n\n    - version.sh\n\n      ```\n      更新版本号，读取本地的一个用于记录版本号的文件。更新方式有2种方式，一种为版本号自增，一种为使用自定义的版本号。设置完更新文件即可。\n\n      ```\n\n    - build.sh\n\n      ```\n      1.修复keychain，导入 login.keychain\n      2.archive 和 oclint\n      3.\n\n      ```\n\n      - fixKeychain.sh\n\n      - buildArchiveOrOCLint.sh\n\n      - dSYM.sh\n\n        ```\n        将打包成功之后生成的.dSYM分别复制到项目路径以及dSYM导出路径下，并且将.dSYM文件压缩成zip包。\n        ps：切记项目 buildSetting 搜索『dwraf』找到 『Debug Information Format』,应设置为『DWRAF with dSYM File』, 否则编译不会生成 dSYM 文件\n\n        ```\n\n      - reSign.sh\n\n    - plist.sh\n\n      ```\n      这个脚本是用来生成一个plist文件，用来提供给itms-services://协议使用的，其中itms-services://协议中最主要的也就是这个plist文件。在之后会生成一个html文件，会将这个itms-services://协议添加进\"下载\"标签的href中。这样在safari浏览器中打开这个网页，点击下载，就可以很方便的下载安装包。\n\n      脚本参考代码如下：\n      #!/bin/sh\n\n      Install_Plist_Name=${Ipa_Name}_install.plist\n      Install_Plist_Path=\"${Install_Path}/${Install_Plist_Name}\"\n      Install_Ipa_URL=\"${Download_Ipa_URL}/${Ipa_Name}.ipa\"\n\n      cat << EOF > $Install_Plist_Path\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n      <plist version=\"1.0\">\n      <dict>\n      \t<key>items</key>\n      \t<array>\n          \t<dict>\n              \t<key>assets</key>\n              \t<array>\n      \t            <dict>\n      \t                <key>kind</key>\n      \t                <string>software-package</string>\n      \t                <key>url</key>\n      \t               \t<string>$Install_Ipa_URL</string>\n      \t            </dict>\n                  </array>\n                  <key>metadata</key>\n                  <dict>\n                      <key>bundle-identifier</key>\n                      <string>$Bundle_Identifier</string>\n                      <key>bundle-version</key>\n                     \t<string>$New_BuildVersion</string>\n                      <key>kind</key>\n                     \t<string>software</string>\n                      <key>title</key>\n                     \t<string>$Bundle_App_Name</string>\n                  </dict>\n              </dict>\n      \t</array>\n      </dict>\n      </plist>\n      EOF\n\n      ```\n\n    - html.sh\n\n      ```\n      生成一个静态页面用于展示打包信息以及绑定生成好的itms-services://协议，然后使用一个写好的js二维码生成库，生成一个网页链接二维码。\n      网页包含内容：\n      1.项目名称\n      2.证书名称\n      3.版本号\n      4.编译号\n      5.备注信息\n      6.二维码\n\n      ```\n\n    - smail.sh\n\n      - emails.sh\n\n        ```\n        用来生成邮件信息\n\n        ```\n\n      - sendmail.py\n\n        ```\n        发送邮件的脚本\n\n        ```\n\n    - plistUpload.sh\n\n      ```\n      提交之前生成好的plist文件到一个https站点（iOS7之后不支持http）, 这里就使用了coding.net的仓库。\n\n      ```\n\n    - dSYMUpload\n\n      ```\n      因为自家接入的是bugly，每次app上线后，手动上传dSYM文件很麻烦。所以这里弄了个脚本，根据Jenkins配置信息是否是否上传bugly。将之前生成好的.dSYM.zip自动上传到bugly。\n\n      上传参考代码：\n      #!/bin/sh\n\n      URLEncodeFunc() {\n      \tlocal length=\"${#1}\"\n      \tfor (( i = 0; i < length; i++ )); do\n      \t\tlocal c=\"${1:i:1}\"\n      \t\tcase $c in\n      \t\t\t[a-zA-Z0-9.~_-]) printf \"$c\" ;;\n      \t\t\t*) printf \"$c\" | xxd -p -c1 | while read x;do printf \"%%%s\" \"$x\";done\n      \t\tesac\n      \tdone\n      }\n\n      if [[ $Jenkins_dSYM_Upload = true ]]; then\n      \techo \"\\n上传 dSYM 到 Bugly...\"\n\n      \t# Bugly 的 TS 说他们要的是这样的版本号格式\n      \tBugly_Version=\"${Bundle_Version}(${New_BuildVersion})\"\n      \t\n      \t# pid默认为2\n      \tdSYM_Pid=\"2\"\n      \tdSYM_AppID=${Bugly_AppId}\n      \tdSYM_AppKey=${Bugly_AppKey}\n      \tdSYM_BundleId=${Bundle_Identifier}\n      \tdSYM_Version=`URLEncodeFunc ${Bugly_Version}`\n      \tdSYM_ZipFileName=`URLEncodeFunc ${dSYM_Path}`\n\n      \tjava -jar ${Bugly_JAR_Path} -i ${dSYM_Path} -u -id ${dSYM_AppID} -key ${dSYM_AppKey} -package ${dSYM_BundleId} -version ${dSYM_Version} 1>/dev/null\n\n      else\n      \techo \"\\n不上传 dSYM 到 bugly\\n\"\n      fi\n\n      rm -rf ${dSYM_Path}\n\n\n      ```\n\n    - appstore.sh","slug":"MacOS+GitLab+Jenkins构建iOS自动化打包平台教程","published":1,"updated":"2019-12-20T06:08:22.048Z","photos":[],"link":"","_id":"ck4dsux2y0009odnqn4t3y3je","content":"<h2 id=\"一、Jenkins\"><a href=\"#一、Jenkins\" class=\"headerlink\" title=\"一、Jenkins\"></a>一、Jenkins</h2><blockquote>\n<p>Jenkins是一个Java项目，依赖于Java环境。在命令行中输入java -version，如果安装过就会出现对应的Java版本。没有则进入<a href=\"https://link.jianshu.com/?t=http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">JavaSDK官网</a>下载安装。</p>\n</blockquote>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><blockquote>\n<p>Jenkins安装方式有好几种，建议使用homebrew方式来进行安装Jenkins。因为用dmg方式安装的Jenkins默认会生成一个Shared的jenkins用户，且安装路径为/Users/xx/Shared。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"1-1-brew安装\"><a href=\"#1-1-brew安装\" class=\"headerlink\" title=\"1.1 brew安装\"></a>1.1 brew安装</h4><blockquote>\n<p>Homebrew是一款Mac OS平台下的软件包管理工具，如果没有安装过<a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">homebrew</a>，在命令行中输入如下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<ul>\n<li><p>安装jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>卸载jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew uninstall jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-2-修改安装路径\"><a href=\"#1-2-修改安装路径\" class=\"headerlink\" title=\"1.2 修改安装路径\"></a>1.2 修改安装路径</h4><ul>\n<li><p>安装完成自后，在命令行中cd到/Library/LaunchDaemons文件夹中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /Library/LaunchDaemons</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果不存在org.jenkins-ci.plist文件，就手动创建一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch org.jenkins-ci.plist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改plist内容，JENKINS_HOME的值修改为你想要放置的安装路径即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">  &lt;dict&gt;</span><br><span class=\"line\">    &lt;key&gt;StandardOutPath&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;/var/log/jenkins/jenkins.log&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;StandardErrorPath&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;/var/log/jenkins/jenkins.log&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;EnvironmentVariables&lt;/key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">      &lt;key&gt;JENKINS_HOME&lt;/key&gt;</span><br><span class=\"line\">      &lt;string&gt;/Users/ci/.jenkins&lt;/string&gt;</span><br><span class=\"line\">    &lt;/dict&gt;</span><br><span class=\"line\">    &lt;key&gt;GroupName&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;daemon&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;org.jenkins-ci&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class=\"line\">    &lt;array&gt;</span><br><span class=\"line\">      &lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class=\"line\">      &lt;string&gt;/Library/Application Support/Jenkins/jenkins-runner.sh&lt;/string&gt;</span><br><span class=\"line\">    &lt;/array&gt;</span><br><span class=\"line\">    &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">    &lt;key&gt;UserName&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;jenkins&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;SessionCreate&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">  &lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启服务并设置为开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo launchctl load -w /Library/LaunchDaemons/org.jenkins-ci.plist</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-3-设置开机启动\"><a href=\"#1-3-设置开机启动\" class=\"headerlink\" title=\"1.3 设置开机启动\"></a>1.3 设置开机启动</h4><ul>\n<li><p>将/usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist文件拷贝到~/Library/LaunchAgents目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -p /usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist ~/Library/LaunchAgents</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo launchctl load -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br><span class=\"line\">PS:若出现&quot;/Library/LaunchAgents/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions&quot;提示，则执行：</span><br><span class=\"line\">sudo chown root /Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br><span class=\"line\">之后再次执行上面命令即可</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>取消开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo launchctl unload -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong><em>PS:Mac OS中，使用launchctl指令可以开启一些启动服务，其中/Library/LaunchAgents中存放的是一些用户登陆后启动的服务。而/Library/LaunchDaemons中存放的就是用户未登录前就可以启动的服务。常用的命令有：launchctl load、launchctl unload、launchctl remove 、launchctl list</em></strong></p>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><blockquote>\n<p>安装完成之后，重启电脑，Jenkins默认会开启一个端口号为8080的本地的web服务。</p>\n<p>在浏览器中输入localhost:8080访问Jenkins页面，进行初始化。</p>\n</blockquote>\n<h4 id=\"2-1-Unlock-Jenkins\"><a href=\"#2-1-Unlock-Jenkins\" class=\"headerlink\" title=\"2.1 Unlock Jenkins\"></a>2.1 Unlock Jenkins</h4><p>按照提示打开文件，获取密码，复制密码到输入框中，继续。</p>\n<h4 id=\"2-2-Customize-Jenkins\"><a href=\"#2-2-Customize-Jenkins\" class=\"headerlink\" title=\"2.2 Customize Jenkins\"></a>2.2 Customize Jenkins</h4><h3 id=\"3-环境配置\"><a href=\"#3-环境配置\" class=\"headerlink\" title=\"3. 环境配置\"></a>3. 环境配置</h3><h4 id=\"3-1-插件下载\"><a href=\"#3-1-插件下载\" class=\"headerlink\" title=\"3.1 插件下载\"></a>3.1 插件下载</h4><blockquote>\n<p>系统管理-管理插件-可选插件-过滤搜索-直接安装</p>\n<p>如果无法获取插件，可以在系统管理-管理插件-高级-升级站点，将默认的https网址修改为http的。</p>\n</blockquote>\n<p>必选插件：</p>\n<ul>\n<li>Git client plugin 、Git plugin、Git server Plugin</li>\n<li>GitHub API Plugin、GitHub Branch Source Plugin、GitHub Organization Folder Plugin、GitHub plugin</li>\n<li>GitLab Authentication plugin、Gitlab Hook Plugin、GitLab logo Plugin、GitLab Plugin</li>\n<li>Xcode integration</li>\n</ul>\n<h4 id=\"3-2-gitlab配置\"><a href=\"#3-2-gitlab配置\" class=\"headerlink\" title=\"3.2 gitlab配置\"></a>3.2 gitlab配置</h4><p>在Credentials中添加凭证。我选择的是SSH授权。Username是你的gitlab用户名。查看本机.ssh/is_rsa中保存的私钥，将你gitlab账号中上传的SSH Key对应的私钥复制粘贴到Private Key中即可。Passphrase填写你当时生成ssh key的时候的密码即可。</p>\n<h3 id=\"4-项目配置\"><a href=\"#4-项目配置\" class=\"headerlink\" title=\"4. 项目配置\"></a>4. 项目配置</h3><h2 id=\"二、打包脚本\"><a href=\"#二、打包脚本\" class=\"headerlink\" title=\"二、打包脚本\"></a>二、打包脚本</h2><h3 id=\"1-相关知识整理\"><a href=\"#1-相关知识整理\" class=\"headerlink\" title=\"1. 相关知识整理\"></a>1. 相关知识整理</h3><h4 id=\"1-1-PlistBuddy\"><a href=\"#1-1-PlistBuddy\" class=\"headerlink\" title=\"1.1 PlistBuddy\"></a>1.1 PlistBuddy</h4><blockquote>\n<p>plist文件是一种xml类型的在Mac OS以及iOS中最常见的一种文件格式，通过键值对的方式进行配置。PlistBuddy则是Mac自带的一个专门用来解析plist文件的工具。PlistBuddy支持的字段类型有：string、array、dict、bool、real、integer、date、data。具体使用可以在命令行中输入/usr/libexec/PlistBuddy –help来查看使用帮助</p>\n</blockquote>\n<p><strong>基本使用介绍：</strong></p>\n<ul>\n<li><p>添加</p>\n<ul>\n<li><p>添加普通字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Version string 1.0&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>添加数组字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 先添加key值</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application array&apos; test.plist</span><br><span class=\"line\"># 添加value值</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application: string app1&apos; test.plist</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application: string app2&apos; test.plist</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application: string app3&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>添加字典字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 先添加key值</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Person dict&apos; test.plist</span><br><span class=\"line\"># 添加value值,</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Person:Name string zs&apos; test.plist</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Person:Age integer 3&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><p>删除</p>\n<ul>\n<li><p>删除普通字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Delete :Version&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>删除字典字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Delete :Person:Age&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>删除数组字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Delete :Application:2&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><p>修改</p>\n<ul>\n<li><p>修改数组字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Set :Application:1 &quot;APP2&quot;&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>修改字典字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Set :Person:Name &quot;ls&quot;&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>查找</p>\n<ul>\n<li><p>查找打印字段对应的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Print :Person&apos; test.plist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找数组中对应元素的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Print :Application:2&apos; test.plist</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n<h4 id=\"1-2-xcodebuild\"><a href=\"#1-2-xcodebuild\" class=\"headerlink\" title=\"1.2 xcodebuild\"></a>1.2 xcodebuild</h4><blockquote>\n</blockquote>\n<p><strong>xcodebuild工作细节：</strong></p>\n<ul>\n<li>Check dependencies（检查项目配置，如Code Sign） -&gt; Preprocessor -&gt; Compile -&gt; Link -&gt; Copy Resource、Compile Xib、CompileStoryboard、CompileAssetCatalog -&gt; Generate DSYM File -&gt; ProcessProductPackaging -&gt; Code Signing（需要访问钥匙串信息） -&gt; Validate -&gt; Result（.app和.dSYM）</li>\n<li>Code Signing（Code Signing Identity，Provisioning Profile）</li>\n</ul>\n<p><strong>常用命令:</strong></p>\n<ul>\n<li><p>clean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild clean -workspace $&#123;Workspace_Name&#125; -scheme $&#123;Scheme_Name&#125;</span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">* -workspace $&#123;Workspace_Name&#125; </span><br><span class=\"line\">  指定工作空间文件XXX.xcworkspace</span><br><span class=\"line\">* -scheme $&#123;Scheme_Name&#125; </span><br><span class=\"line\">  指定构建工程名称</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>archive</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive</span><br><span class=\"line\">-archivePath &quot;$&#123;Archive_Path&#125;&quot; </span><br><span class=\"line\">-workspace $&#123;Workspace_Name&#125; </span><br><span class=\"line\">-scheme $&#123;Scheme_Name&#125; </span><br><span class=\"line\">-configuration $&#123;Build_Config&#125; </span><br><span class=\"line\">CODE_SIGN_IDENTITY=&quot;$&#123;Cert_Identity&#125;&quot; </span><br><span class=\"line\">DEVELOPMENT_TEAM=&quot;$&#123;Team_ID&#125;&quot;</span><br><span class=\"line\">PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;Mobile_Provision_UUID&#125;&quot;  </span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">*  -archivePath &quot;$&#123;Archive_Path&#125;&quot; </span><br><span class=\"line\">  Archive后文件导出的路径</span><br><span class=\"line\">* -workspace $&#123;Workspace_Name&#125; </span><br><span class=\"line\">  工作空间文件名称（XXX.xcworkspace）</span><br><span class=\"line\">* -scheme $&#123;Scheme_Name&#125; </span><br><span class=\"line\">  项目名称</span><br><span class=\"line\">* -configuration $&#123;Build_Config&#125; </span><br><span class=\"line\">  构建配置（Debug/Release）</span><br><span class=\"line\">* CODE_SIGN_IDENTITY=&quot;$&#123;Cert_Identity&#125;&quot; </span><br><span class=\"line\">  打包证书名称</span><br><span class=\"line\">* DEVELOPMENT_TEAM=&quot;$&#123;Team_ID&#125;&quot;</span><br><span class=\"line\">  证书teamID</span><br><span class=\"line\">* PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;Mobile_Provision_UUID&#125;&quot;  </span><br><span class=\"line\">  描述文件的UUID</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>export</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild</span><br><span class=\"line\">-exportArchive </span><br><span class=\"line\">-archivePath &quot;$&#123;Archive_Path&#125;&quot; </span><br><span class=\"line\">-exportPath $&#123;Ipa_Name&#125; </span><br><span class=\"line\">-exportFormat ipa </span><br><span class=\"line\">-exportWithOriginalSigningIdentity </span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">* -exportArchive </span><br><span class=\"line\">* -archivePath &quot;$&#123;Archive_Path&#125;&quot;</span><br><span class=\"line\">* -exportPath $&#123;Ipa_Name&#125; </span><br><span class=\"line\">* -exportFormat ipa </span><br><span class=\"line\">* -exportWithOriginalSigningIdentity</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h4 id=\"1-3-OCLint\"><a href=\"#1-3-OCLint\" class=\"headerlink\" title=\"1.3 OCLint\"></a>1.3 OCLint</h4><blockquote>\n<p>OCLint是一个静态代码分析工具，在Jenkins打包脚本中引入 OCLint 的目的，一方面是为了CodeReview。另一方面在编译失败的情况下输出分析日志，方便我们定位问题。</p>\n<p>OCLint的工作流程：</p>\n<p>编译–&gt;xcodebuild(生成xcodebuild.log)–&gt;xcpretty(分析xcodebuild.log生成compile_commands.json文件)–&gt;oclint-json-compilation-database(获取编译信息)–&gt;oclint(输出分析报告)</p>\n</blockquote>\n<ul>\n<li><p>brew安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap oclint/formulae</span><br><span class=\"line\">brew install oclint</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相关命令介绍</p>\n<ul>\n<li>1.oclint：基础指令。通过这个指令可以指定加载验证规则、编译代码、分析代码和生成报告。</li>\n<li>2.oclint-json-compilation-database：高级指令。通过这个指令可以从 compile_commands.json 文件中读取配置信息并执行 oclint。</li>\n<li>3.oclint-xcodebuild：主要用于生成compile_commands.json文件，已经不进行维护了，用xcpretty替代来生成json文件。</li>\n</ul>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>输出编译报告</p>\n<p>xodebuild生成分析xcodebuild.log文件，xcpretty分析xcodebuild.log生成compile_commands.json文件。</p>\n<p>tee命令获取输出结果。xcpretty命令将编译结果输出为json-compilation-database类型的编译报告。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive -archivePath &quot;$&#123;Archive_Path&#125;&quot; -workspace $&#123;Workspace_Name&#125; -scheme $&#123;Scheme_Name&#125; -configuration $&#123;Build_Config&#125; CODE_SIGN_IDENTITY=&quot;$&#123;Cert_Identity&#125;&quot; DEVELOPMENT_TEAM=&quot;$&#123;Team_ID&#125;&quot; PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;Mobile_Provision_UUID&#125;&quot; | tee xcodebuild.log | xcpretty --report json-compilation-database</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出分析报告</p>\n<p>根据上一步xcpretty生成的json-compilation-database类型的编译报告，然后就需要使用oclint-json-compilation-database来解析。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oclint-json-compilation-database -e Pods -v -- -report-type html -o &quot;$&#123;Report_HTML&#125;&quot; -max-priority-1=99999 -max-priority-2=99999 -max-priority-3=99999 1&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-脚本文件结构\"><a href=\"#2-脚本文件结构\" class=\"headerlink\" title=\"2. 脚本文件结构\"></a>2. 脚本文件结构</h3><h3 id=\"3-脚本描述\"><a href=\"#3-脚本描述\" class=\"headerlink\" title=\"3. 脚本描述\"></a>3. 脚本描述</h3><ul>\n<li><p>main.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main中主要做了以下几件事情：</span><br><span class=\"line\">\t1.配置路径信息(例如：脚本本地目录，默认配置目录，描述文件目录，keychain目录等等)</span><br><span class=\"line\">\t2.配置默认证书相关信息(例如：默认证书名称，teamID,描述文件，描述文件UUID)</span><br><span class=\"line\">\t3.Jenkins参数设置</span><br><span class=\"line\">\t4.执行mainUpgrade.sh获取Jenkins项目信息，更新脚本等</span><br><span class=\"line\">\t5.执行diag.sh输出诊断信息</span><br><span class=\"line\">\t6.执行mainRun.sh开始启动打包脚本</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>mainUpgrade.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainUpgrade中主要用来获取Jenkins对应jobs的项目名称，版本号，git分支，连接等相关信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>diag.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diag主要输出相关使用命令的诊断信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mainRun.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainRun中开始真正的打包脚本执行，依次执行了如下脚本</span><br><span class=\"line\">1.comment.sh</span><br><span class=\"line\">2.info.sh</span><br><span class=\"line\">3.config.sh</span><br><span class=\"line\">4.entitlements.sh</span><br><span class=\"line\">5.pod.sh</span><br><span class=\"line\">6.version.sh</span><br><span class=\"line\">7.build.sh</span><br><span class=\"line\">8.plist.sh</span><br><span class=\"line\">9.html.sh</span><br><span class=\"line\">10.smail.sh</span><br><span class=\"line\">11.plistUpload.sh</span><br><span class=\"line\">12.dSYMUpload</span><br><span class=\"line\">13.appstore.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>comment.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用来生成本次打包的备注文案</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>diskClean.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清理磁盘文件，清理DeriverdData,iOS DeviceSupport相关文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>info.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取项目工程信息</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>infoGit.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要做了2件事情：</span><br><span class=\"line\">1.读取项目git信息，包括项目名称，项目当前分支名称</span><br><span class=\"line\">2.读取打包配置文件(一个plist类型的文件，里面配置了对应项目的打包证书enterprise，ad-hoc,appstore证书信息，添加邮件抄送，debug/release等等一些打包配置信息)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>infoProject.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用来获取项目工程中的信息，包括workspace路径，bundleIdentigier,infoPlist路径，build号，version号等等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>infoPath.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用于配置和生成打包输出的相关文件路径，包括Archive文件路径，ipa文件路径，dSYM文件路径，Html文件路径，OCLint文件路径等等。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>config.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取证书配置，配置证书相关信息。配置bugly信息。设置编译类型。设置输出包类型等等。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>configCert.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据打包配置文件以及Jenkins配置信息，读取对应method(输出包类型)相对应的打包证书，描述文件，teamID，描述文件UUID等相关信息。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>entitlements.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取相应的描述文件信息，利用plsitbuddy分别修改了.pbxproj以及.entitlements文件中的相关权限配置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pod.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod repo update 以及 pod update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>version.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更新版本号，读取本地的一个用于记录版本号的文件。更新方式有2种方式，一种为版本号自增，一种为使用自定义的版本号。设置完更新文件即可。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>build.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.修复keychain，导入 login.keychain</span><br><span class=\"line\">2.archive 和 oclint</span><br><span class=\"line\">3.</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>fixKeychain.sh</p>\n</li>\n<li><p>buildArchiveOrOCLint.sh</p>\n</li>\n<li><p>dSYM.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将打包成功之后生成的.dSYM分别复制到项目路径以及dSYM导出路径下，并且将.dSYM文件压缩成zip包。</span><br><span class=\"line\">ps：切记项目 buildSetting 搜索『dwraf』找到 『Debug Information Format』,应设置为『DWRAF with dSYM File』, 否则编译不会生成 dSYM 文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reSign.sh</p>\n</li>\n</ul>\n</li>\n<li><p>plist.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个脚本是用来生成一个plist文件，用来提供给itms-services://协议使用的，其中itms-services://协议中最主要的也就是这个plist文件。在之后会生成一个html文件，会将这个itms-services://协议添加进&quot;下载&quot;标签的href中。这样在safari浏览器中打开这个网页，点击下载，就可以很方便的下载安装包。</span><br><span class=\"line\"></span><br><span class=\"line\">脚本参考代码如下：</span><br><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">Install_Plist_Name=$&#123;Ipa_Name&#125;_install.plist</span><br><span class=\"line\">Install_Plist_Path=&quot;$&#123;Install_Path&#125;/$&#123;Install_Plist_Name&#125;&quot;</span><br><span class=\"line\">Install_Ipa_URL=&quot;$&#123;Download_Ipa_URL&#125;/$&#123;Ipa_Name&#125;.ipa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">cat &lt;&lt; EOF &gt; $Install_Plist_Path</span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;items&lt;/key&gt;</span><br><span class=\"line\">\t&lt;array&gt;</span><br><span class=\"line\">    \t&lt;dict&gt;</span><br><span class=\"line\">        \t&lt;key&gt;assets&lt;/key&gt;</span><br><span class=\"line\">        \t&lt;array&gt;</span><br><span class=\"line\">\t            &lt;dict&gt;</span><br><span class=\"line\">\t                &lt;key&gt;kind&lt;/key&gt;</span><br><span class=\"line\">\t                &lt;string&gt;software-package&lt;/string&gt;</span><br><span class=\"line\">\t                &lt;key&gt;url&lt;/key&gt;</span><br><span class=\"line\">\t               \t&lt;string&gt;$Install_Ipa_URL&lt;/string&gt;</span><br><span class=\"line\">\t            &lt;/dict&gt;</span><br><span class=\"line\">            &lt;/array&gt;</span><br><span class=\"line\">            &lt;key&gt;metadata&lt;/key&gt;</span><br><span class=\"line\">            &lt;dict&gt;</span><br><span class=\"line\">                &lt;key&gt;bundle-identifier&lt;/key&gt;</span><br><span class=\"line\">                &lt;string&gt;$Bundle_Identifier&lt;/string&gt;</span><br><span class=\"line\">                &lt;key&gt;bundle-version&lt;/key&gt;</span><br><span class=\"line\">               \t&lt;string&gt;$New_BuildVersion&lt;/string&gt;</span><br><span class=\"line\">                &lt;key&gt;kind&lt;/key&gt;</span><br><span class=\"line\">               \t&lt;string&gt;software&lt;/string&gt;</span><br><span class=\"line\">                &lt;key&gt;title&lt;/key&gt;</span><br><span class=\"line\">               \t&lt;string&gt;$Bundle_App_Name&lt;/string&gt;</span><br><span class=\"line\">            &lt;/dict&gt;</span><br><span class=\"line\">        &lt;/dict&gt;</span><br><span class=\"line\">\t&lt;/array&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>html.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">生成一个静态页面用于展示打包信息以及绑定生成好的itms-services://协议，然后使用一个写好的js二维码生成库，生成一个网页链接二维码。</span><br><span class=\"line\">网页包含内容：</span><br><span class=\"line\">1.项目名称</span><br><span class=\"line\">2.证书名称</span><br><span class=\"line\">3.版本号</span><br><span class=\"line\">4.编译号</span><br><span class=\"line\">5.备注信息</span><br><span class=\"line\">6.二维码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>smail.sh</p>\n<ul>\n<li><p>emails.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用来生成邮件信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sendmail.py</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发送邮件的脚本</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>plistUpload.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">提交之前生成好的plist文件到一个https站点（iOS7之后不支持http）, 这里就使用了coding.net的仓库。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dSYMUpload</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为自家接入的是bugly，每次app上线后，手动上传dSYM文件很麻烦。所以这里弄了个脚本，根据Jenkins配置信息是否是否上传bugly。将之前生成好的.dSYM.zip自动上传到bugly。</span><br><span class=\"line\"></span><br><span class=\"line\">上传参考代码：</span><br><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">URLEncodeFunc() &#123;</span><br><span class=\"line\">\tlocal length=&quot;$&#123;#1&#125;&quot;</span><br><span class=\"line\">\tfor (( i = 0; i &lt; length; i++ )); do</span><br><span class=\"line\">\t\tlocal c=&quot;$&#123;1:i:1&#125;&quot;</span><br><span class=\"line\">\t\tcase $c in</span><br><span class=\"line\">\t\t\t[a-zA-Z0-9.~_-]) printf &quot;$c&quot; ;;</span><br><span class=\"line\">\t\t\t*) printf &quot;$c&quot; | xxd -p -c1 | while read x;do printf &quot;%%%s&quot; &quot;$x&quot;;done</span><br><span class=\"line\">\t\tesac</span><br><span class=\"line\">\tdone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $Jenkins_dSYM_Upload = true ]]; then</span><br><span class=\"line\">\techo &quot;\\n上传 dSYM 到 Bugly...&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t# Bugly 的 TS 说他们要的是这样的版本号格式</span><br><span class=\"line\">\tBugly_Version=&quot;$&#123;Bundle_Version&#125;($&#123;New_BuildVersion&#125;)&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t# pid默认为2</span><br><span class=\"line\">\tdSYM_Pid=&quot;2&quot;</span><br><span class=\"line\">\tdSYM_AppID=$&#123;Bugly_AppId&#125;</span><br><span class=\"line\">\tdSYM_AppKey=$&#123;Bugly_AppKey&#125;</span><br><span class=\"line\">\tdSYM_BundleId=$&#123;Bundle_Identifier&#125;</span><br><span class=\"line\">\tdSYM_Version=`URLEncodeFunc $&#123;Bugly_Version&#125;`</span><br><span class=\"line\">\tdSYM_ZipFileName=`URLEncodeFunc $&#123;dSYM_Path&#125;`</span><br><span class=\"line\"></span><br><span class=\"line\">\tjava -jar $&#123;Bugly_JAR_Path&#125; -i $&#123;dSYM_Path&#125; -u -id $&#123;dSYM_AppID&#125; -key $&#123;dSYM_AppKey&#125; -package $&#123;dSYM_BundleId&#125; -version $&#123;dSYM_Version&#125; 1&gt;/dev/null</span><br><span class=\"line\"></span><br><span class=\"line\">else</span><br><span class=\"line\">\techo &quot;\\n不上传 dSYM 到 bugly\\n&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">rm -rf $&#123;dSYM_Path&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>appstore.sh</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、Jenkins\"><a href=\"#一、Jenkins\" class=\"headerlink\" title=\"一、Jenkins\"></a>一、Jenkins</h2><blockquote>\n<p>Jenkins是一个Java项目，依赖于Java环境。在命令行中输入java -version，如果安装过就会出现对应的Java版本。没有则进入<a href=\"https://link.jianshu.com/?t=http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">JavaSDK官网</a>下载安装。</p>\n</blockquote>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><blockquote>\n<p>Jenkins安装方式有好几种，建议使用homebrew方式来进行安装Jenkins。因为用dmg方式安装的Jenkins默认会生成一个Shared的jenkins用户，且安装路径为/Users/xx/Shared。</p>\n</blockquote>","more":"<h4 id=\"1-1-brew安装\"><a href=\"#1-1-brew安装\" class=\"headerlink\" title=\"1.1 brew安装\"></a>1.1 brew安装</h4><blockquote>\n<p>Homebrew是一款Mac OS平台下的软件包管理工具，如果没有安装过<a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">homebrew</a>，在命令行中输入如下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<ul>\n<li><p>安装jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>卸载jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew uninstall jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-2-修改安装路径\"><a href=\"#1-2-修改安装路径\" class=\"headerlink\" title=\"1.2 修改安装路径\"></a>1.2 修改安装路径</h4><ul>\n<li><p>安装完成自后，在命令行中cd到/Library/LaunchDaemons文件夹中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /Library/LaunchDaemons</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果不存在org.jenkins-ci.plist文件，就手动创建一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch org.jenkins-ci.plist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改plist内容，JENKINS_HOME的值修改为你想要放置的安装路径即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">  &lt;dict&gt;</span><br><span class=\"line\">    &lt;key&gt;StandardOutPath&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;/var/log/jenkins/jenkins.log&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;StandardErrorPath&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;/var/log/jenkins/jenkins.log&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;EnvironmentVariables&lt;/key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">      &lt;key&gt;JENKINS_HOME&lt;/key&gt;</span><br><span class=\"line\">      &lt;string&gt;/Users/ci/.jenkins&lt;/string&gt;</span><br><span class=\"line\">    &lt;/dict&gt;</span><br><span class=\"line\">    &lt;key&gt;GroupName&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;daemon&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;org.jenkins-ci&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class=\"line\">    &lt;array&gt;</span><br><span class=\"line\">      &lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class=\"line\">      &lt;string&gt;/Library/Application Support/Jenkins/jenkins-runner.sh&lt;/string&gt;</span><br><span class=\"line\">    &lt;/array&gt;</span><br><span class=\"line\">    &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">    &lt;key&gt;UserName&lt;/key&gt;</span><br><span class=\"line\">    &lt;string&gt;jenkins&lt;/string&gt;</span><br><span class=\"line\">    &lt;key&gt;SessionCreate&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">  &lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启服务并设置为开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo launchctl load -w /Library/LaunchDaemons/org.jenkins-ci.plist</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-3-设置开机启动\"><a href=\"#1-3-设置开机启动\" class=\"headerlink\" title=\"1.3 设置开机启动\"></a>1.3 设置开机启动</h4><ul>\n<li><p>将/usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist文件拷贝到~/Library/LaunchAgents目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -p /usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist ~/Library/LaunchAgents</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo launchctl load -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br><span class=\"line\">PS:若出现&quot;/Library/LaunchAgents/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions&quot;提示，则执行：</span><br><span class=\"line\">sudo chown root /Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br><span class=\"line\">之后再次执行上面命令即可</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>取消开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo launchctl unload -w /Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong><em>PS:Mac OS中，使用launchctl指令可以开启一些启动服务，其中/Library/LaunchAgents中存放的是一些用户登陆后启动的服务。而/Library/LaunchDaemons中存放的就是用户未登录前就可以启动的服务。常用的命令有：launchctl load、launchctl unload、launchctl remove 、launchctl list</em></strong></p>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><blockquote>\n<p>安装完成之后，重启电脑，Jenkins默认会开启一个端口号为8080的本地的web服务。</p>\n<p>在浏览器中输入localhost:8080访问Jenkins页面，进行初始化。</p>\n</blockquote>\n<h4 id=\"2-1-Unlock-Jenkins\"><a href=\"#2-1-Unlock-Jenkins\" class=\"headerlink\" title=\"2.1 Unlock Jenkins\"></a>2.1 Unlock Jenkins</h4><p>按照提示打开文件，获取密码，复制密码到输入框中，继续。</p>\n<h4 id=\"2-2-Customize-Jenkins\"><a href=\"#2-2-Customize-Jenkins\" class=\"headerlink\" title=\"2.2 Customize Jenkins\"></a>2.2 Customize Jenkins</h4><h3 id=\"3-环境配置\"><a href=\"#3-环境配置\" class=\"headerlink\" title=\"3. 环境配置\"></a>3. 环境配置</h3><h4 id=\"3-1-插件下载\"><a href=\"#3-1-插件下载\" class=\"headerlink\" title=\"3.1 插件下载\"></a>3.1 插件下载</h4><blockquote>\n<p>系统管理-管理插件-可选插件-过滤搜索-直接安装</p>\n<p>如果无法获取插件，可以在系统管理-管理插件-高级-升级站点，将默认的https网址修改为http的。</p>\n</blockquote>\n<p>必选插件：</p>\n<ul>\n<li>Git client plugin 、Git plugin、Git server Plugin</li>\n<li>GitHub API Plugin、GitHub Branch Source Plugin、GitHub Organization Folder Plugin、GitHub plugin</li>\n<li>GitLab Authentication plugin、Gitlab Hook Plugin、GitLab logo Plugin、GitLab Plugin</li>\n<li>Xcode integration</li>\n</ul>\n<h4 id=\"3-2-gitlab配置\"><a href=\"#3-2-gitlab配置\" class=\"headerlink\" title=\"3.2 gitlab配置\"></a>3.2 gitlab配置</h4><p>在Credentials中添加凭证。我选择的是SSH授权。Username是你的gitlab用户名。查看本机.ssh/is_rsa中保存的私钥，将你gitlab账号中上传的SSH Key对应的私钥复制粘贴到Private Key中即可。Passphrase填写你当时生成ssh key的时候的密码即可。</p>\n<h3 id=\"4-项目配置\"><a href=\"#4-项目配置\" class=\"headerlink\" title=\"4. 项目配置\"></a>4. 项目配置</h3><h2 id=\"二、打包脚本\"><a href=\"#二、打包脚本\" class=\"headerlink\" title=\"二、打包脚本\"></a>二、打包脚本</h2><h3 id=\"1-相关知识整理\"><a href=\"#1-相关知识整理\" class=\"headerlink\" title=\"1. 相关知识整理\"></a>1. 相关知识整理</h3><h4 id=\"1-1-PlistBuddy\"><a href=\"#1-1-PlistBuddy\" class=\"headerlink\" title=\"1.1 PlistBuddy\"></a>1.1 PlistBuddy</h4><blockquote>\n<p>plist文件是一种xml类型的在Mac OS以及iOS中最常见的一种文件格式，通过键值对的方式进行配置。PlistBuddy则是Mac自带的一个专门用来解析plist文件的工具。PlistBuddy支持的字段类型有：string、array、dict、bool、real、integer、date、data。具体使用可以在命令行中输入/usr/libexec/PlistBuddy –help来查看使用帮助</p>\n</blockquote>\n<p><strong>基本使用介绍：</strong></p>\n<ul>\n<li><p>添加</p>\n<ul>\n<li><p>添加普通字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Version string 1.0&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>添加数组字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 先添加key值</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application array&apos; test.plist</span><br><span class=\"line\"># 添加value值</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application: string app1&apos; test.plist</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application: string app2&apos; test.plist</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Application: string app3&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>添加字典字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 先添加key值</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Person dict&apos; test.plist</span><br><span class=\"line\"># 添加value值,</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Person:Name string zs&apos; test.plist</span><br><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Add :Person:Age integer 3&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><p>删除</p>\n<ul>\n<li><p>删除普通字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Delete :Version&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>删除字典字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Delete :Person:Age&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>删除数组字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Delete :Application:2&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><p>修改</p>\n<ul>\n<li><p>修改数组字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Set :Application:1 &quot;APP2&quot;&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>修改字典字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Set :Person:Name &quot;ls&quot;&apos; test.plist</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>查找</p>\n<ul>\n<li><p>查找打印字段对应的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Print :Person&apos; test.plist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找数组中对应元素的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/PlistBuddy -c &apos;Print :Application:2&apos; test.plist</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n<h4 id=\"1-2-xcodebuild\"><a href=\"#1-2-xcodebuild\" class=\"headerlink\" title=\"1.2 xcodebuild\"></a>1.2 xcodebuild</h4><blockquote>\n</blockquote>\n<p><strong>xcodebuild工作细节：</strong></p>\n<ul>\n<li>Check dependencies（检查项目配置，如Code Sign） -&gt; Preprocessor -&gt; Compile -&gt; Link -&gt; Copy Resource、Compile Xib、CompileStoryboard、CompileAssetCatalog -&gt; Generate DSYM File -&gt; ProcessProductPackaging -&gt; Code Signing（需要访问钥匙串信息） -&gt; Validate -&gt; Result（.app和.dSYM）</li>\n<li>Code Signing（Code Signing Identity，Provisioning Profile）</li>\n</ul>\n<p><strong>常用命令:</strong></p>\n<ul>\n<li><p>clean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild clean -workspace $&#123;Workspace_Name&#125; -scheme $&#123;Scheme_Name&#125;</span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">* -workspace $&#123;Workspace_Name&#125; </span><br><span class=\"line\">  指定工作空间文件XXX.xcworkspace</span><br><span class=\"line\">* -scheme $&#123;Scheme_Name&#125; </span><br><span class=\"line\">  指定构建工程名称</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>archive</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive</span><br><span class=\"line\">-archivePath &quot;$&#123;Archive_Path&#125;&quot; </span><br><span class=\"line\">-workspace $&#123;Workspace_Name&#125; </span><br><span class=\"line\">-scheme $&#123;Scheme_Name&#125; </span><br><span class=\"line\">-configuration $&#123;Build_Config&#125; </span><br><span class=\"line\">CODE_SIGN_IDENTITY=&quot;$&#123;Cert_Identity&#125;&quot; </span><br><span class=\"line\">DEVELOPMENT_TEAM=&quot;$&#123;Team_ID&#125;&quot;</span><br><span class=\"line\">PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;Mobile_Provision_UUID&#125;&quot;  </span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">*  -archivePath &quot;$&#123;Archive_Path&#125;&quot; </span><br><span class=\"line\">  Archive后文件导出的路径</span><br><span class=\"line\">* -workspace $&#123;Workspace_Name&#125; </span><br><span class=\"line\">  工作空间文件名称（XXX.xcworkspace）</span><br><span class=\"line\">* -scheme $&#123;Scheme_Name&#125; </span><br><span class=\"line\">  项目名称</span><br><span class=\"line\">* -configuration $&#123;Build_Config&#125; </span><br><span class=\"line\">  构建配置（Debug/Release）</span><br><span class=\"line\">* CODE_SIGN_IDENTITY=&quot;$&#123;Cert_Identity&#125;&quot; </span><br><span class=\"line\">  打包证书名称</span><br><span class=\"line\">* DEVELOPMENT_TEAM=&quot;$&#123;Team_ID&#125;&quot;</span><br><span class=\"line\">  证书teamID</span><br><span class=\"line\">* PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;Mobile_Provision_UUID&#125;&quot;  </span><br><span class=\"line\">  描述文件的UUID</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>export</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild</span><br><span class=\"line\">-exportArchive </span><br><span class=\"line\">-archivePath &quot;$&#123;Archive_Path&#125;&quot; </span><br><span class=\"line\">-exportPath $&#123;Ipa_Name&#125; </span><br><span class=\"line\">-exportFormat ipa </span><br><span class=\"line\">-exportWithOriginalSigningIdentity </span><br><span class=\"line\">参数说明：</span><br><span class=\"line\">* -exportArchive </span><br><span class=\"line\">* -archivePath &quot;$&#123;Archive_Path&#125;&quot;</span><br><span class=\"line\">* -exportPath $&#123;Ipa_Name&#125; </span><br><span class=\"line\">* -exportFormat ipa </span><br><span class=\"line\">* -exportWithOriginalSigningIdentity</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h4 id=\"1-3-OCLint\"><a href=\"#1-3-OCLint\" class=\"headerlink\" title=\"1.3 OCLint\"></a>1.3 OCLint</h4><blockquote>\n<p>OCLint是一个静态代码分析工具，在Jenkins打包脚本中引入 OCLint 的目的，一方面是为了CodeReview。另一方面在编译失败的情况下输出分析日志，方便我们定位问题。</p>\n<p>OCLint的工作流程：</p>\n<p>编译–&gt;xcodebuild(生成xcodebuild.log)–&gt;xcpretty(分析xcodebuild.log生成compile_commands.json文件)–&gt;oclint-json-compilation-database(获取编译信息)–&gt;oclint(输出分析报告)</p>\n</blockquote>\n<ul>\n<li><p>brew安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap oclint/formulae</span><br><span class=\"line\">brew install oclint</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相关命令介绍</p>\n<ul>\n<li>1.oclint：基础指令。通过这个指令可以指定加载验证规则、编译代码、分析代码和生成报告。</li>\n<li>2.oclint-json-compilation-database：高级指令。通过这个指令可以从 compile_commands.json 文件中读取配置信息并执行 oclint。</li>\n<li>3.oclint-xcodebuild：主要用于生成compile_commands.json文件，已经不进行维护了，用xcpretty替代来生成json文件。</li>\n</ul>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>输出编译报告</p>\n<p>xodebuild生成分析xcodebuild.log文件，xcpretty分析xcodebuild.log生成compile_commands.json文件。</p>\n<p>tee命令获取输出结果。xcpretty命令将编译结果输出为json-compilation-database类型的编译报告。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive -archivePath &quot;$&#123;Archive_Path&#125;&quot; -workspace $&#123;Workspace_Name&#125; -scheme $&#123;Scheme_Name&#125; -configuration $&#123;Build_Config&#125; CODE_SIGN_IDENTITY=&quot;$&#123;Cert_Identity&#125;&quot; DEVELOPMENT_TEAM=&quot;$&#123;Team_ID&#125;&quot; PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;Mobile_Provision_UUID&#125;&quot; | tee xcodebuild.log | xcpretty --report json-compilation-database</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出分析报告</p>\n<p>根据上一步xcpretty生成的json-compilation-database类型的编译报告，然后就需要使用oclint-json-compilation-database来解析。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oclint-json-compilation-database -e Pods -v -- -report-type html -o &quot;$&#123;Report_HTML&#125;&quot; -max-priority-1=99999 -max-priority-2=99999 -max-priority-3=99999 1&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-脚本文件结构\"><a href=\"#2-脚本文件结构\" class=\"headerlink\" title=\"2. 脚本文件结构\"></a>2. 脚本文件结构</h3><h3 id=\"3-脚本描述\"><a href=\"#3-脚本描述\" class=\"headerlink\" title=\"3. 脚本描述\"></a>3. 脚本描述</h3><ul>\n<li><p>main.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main中主要做了以下几件事情：</span><br><span class=\"line\">\t1.配置路径信息(例如：脚本本地目录，默认配置目录，描述文件目录，keychain目录等等)</span><br><span class=\"line\">\t2.配置默认证书相关信息(例如：默认证书名称，teamID,描述文件，描述文件UUID)</span><br><span class=\"line\">\t3.Jenkins参数设置</span><br><span class=\"line\">\t4.执行mainUpgrade.sh获取Jenkins项目信息，更新脚本等</span><br><span class=\"line\">\t5.执行diag.sh输出诊断信息</span><br><span class=\"line\">\t6.执行mainRun.sh开始启动打包脚本</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>mainUpgrade.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainUpgrade中主要用来获取Jenkins对应jobs的项目名称，版本号，git分支，连接等相关信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>diag.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diag主要输出相关使用命令的诊断信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mainRun.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainRun中开始真正的打包脚本执行，依次执行了如下脚本</span><br><span class=\"line\">1.comment.sh</span><br><span class=\"line\">2.info.sh</span><br><span class=\"line\">3.config.sh</span><br><span class=\"line\">4.entitlements.sh</span><br><span class=\"line\">5.pod.sh</span><br><span class=\"line\">6.version.sh</span><br><span class=\"line\">7.build.sh</span><br><span class=\"line\">8.plist.sh</span><br><span class=\"line\">9.html.sh</span><br><span class=\"line\">10.smail.sh</span><br><span class=\"line\">11.plistUpload.sh</span><br><span class=\"line\">12.dSYMUpload</span><br><span class=\"line\">13.appstore.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>comment.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用来生成本次打包的备注文案</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>diskClean.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清理磁盘文件，清理DeriverdData,iOS DeviceSupport相关文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>info.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取项目工程信息</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>infoGit.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要做了2件事情：</span><br><span class=\"line\">1.读取项目git信息，包括项目名称，项目当前分支名称</span><br><span class=\"line\">2.读取打包配置文件(一个plist类型的文件，里面配置了对应项目的打包证书enterprise，ad-hoc,appstore证书信息，添加邮件抄送，debug/release等等一些打包配置信息)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>infoProject.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用来获取项目工程中的信息，包括workspace路径，bundleIdentigier,infoPlist路径，build号，version号等等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>infoPath.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用于配置和生成打包输出的相关文件路径，包括Archive文件路径，ipa文件路径，dSYM文件路径，Html文件路径，OCLint文件路径等等。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>config.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取证书配置，配置证书相关信息。配置bugly信息。设置编译类型。设置输出包类型等等。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>configCert.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据打包配置文件以及Jenkins配置信息，读取对应method(输出包类型)相对应的打包证书，描述文件，teamID，描述文件UUID等相关信息。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>entitlements.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取相应的描述文件信息，利用plsitbuddy分别修改了.pbxproj以及.entitlements文件中的相关权限配置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pod.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod repo update 以及 pod update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>version.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更新版本号，读取本地的一个用于记录版本号的文件。更新方式有2种方式，一种为版本号自增，一种为使用自定义的版本号。设置完更新文件即可。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>build.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.修复keychain，导入 login.keychain</span><br><span class=\"line\">2.archive 和 oclint</span><br><span class=\"line\">3.</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>fixKeychain.sh</p>\n</li>\n<li><p>buildArchiveOrOCLint.sh</p>\n</li>\n<li><p>dSYM.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将打包成功之后生成的.dSYM分别复制到项目路径以及dSYM导出路径下，并且将.dSYM文件压缩成zip包。</span><br><span class=\"line\">ps：切记项目 buildSetting 搜索『dwraf』找到 『Debug Information Format』,应设置为『DWRAF with dSYM File』, 否则编译不会生成 dSYM 文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reSign.sh</p>\n</li>\n</ul>\n</li>\n<li><p>plist.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个脚本是用来生成一个plist文件，用来提供给itms-services://协议使用的，其中itms-services://协议中最主要的也就是这个plist文件。在之后会生成一个html文件，会将这个itms-services://协议添加进&quot;下载&quot;标签的href中。这样在safari浏览器中打开这个网页，点击下载，就可以很方便的下载安装包。</span><br><span class=\"line\"></span><br><span class=\"line\">脚本参考代码如下：</span><br><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">Install_Plist_Name=$&#123;Ipa_Name&#125;_install.plist</span><br><span class=\"line\">Install_Plist_Path=&quot;$&#123;Install_Path&#125;/$&#123;Install_Plist_Name&#125;&quot;</span><br><span class=\"line\">Install_Ipa_URL=&quot;$&#123;Download_Ipa_URL&#125;/$&#123;Ipa_Name&#125;.ipa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">cat &lt;&lt; EOF &gt; $Install_Plist_Path</span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;items&lt;/key&gt;</span><br><span class=\"line\">\t&lt;array&gt;</span><br><span class=\"line\">    \t&lt;dict&gt;</span><br><span class=\"line\">        \t&lt;key&gt;assets&lt;/key&gt;</span><br><span class=\"line\">        \t&lt;array&gt;</span><br><span class=\"line\">\t            &lt;dict&gt;</span><br><span class=\"line\">\t                &lt;key&gt;kind&lt;/key&gt;</span><br><span class=\"line\">\t                &lt;string&gt;software-package&lt;/string&gt;</span><br><span class=\"line\">\t                &lt;key&gt;url&lt;/key&gt;</span><br><span class=\"line\">\t               \t&lt;string&gt;$Install_Ipa_URL&lt;/string&gt;</span><br><span class=\"line\">\t            &lt;/dict&gt;</span><br><span class=\"line\">            &lt;/array&gt;</span><br><span class=\"line\">            &lt;key&gt;metadata&lt;/key&gt;</span><br><span class=\"line\">            &lt;dict&gt;</span><br><span class=\"line\">                &lt;key&gt;bundle-identifier&lt;/key&gt;</span><br><span class=\"line\">                &lt;string&gt;$Bundle_Identifier&lt;/string&gt;</span><br><span class=\"line\">                &lt;key&gt;bundle-version&lt;/key&gt;</span><br><span class=\"line\">               \t&lt;string&gt;$New_BuildVersion&lt;/string&gt;</span><br><span class=\"line\">                &lt;key&gt;kind&lt;/key&gt;</span><br><span class=\"line\">               \t&lt;string&gt;software&lt;/string&gt;</span><br><span class=\"line\">                &lt;key&gt;title&lt;/key&gt;</span><br><span class=\"line\">               \t&lt;string&gt;$Bundle_App_Name&lt;/string&gt;</span><br><span class=\"line\">            &lt;/dict&gt;</span><br><span class=\"line\">        &lt;/dict&gt;</span><br><span class=\"line\">\t&lt;/array&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>html.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">生成一个静态页面用于展示打包信息以及绑定生成好的itms-services://协议，然后使用一个写好的js二维码生成库，生成一个网页链接二维码。</span><br><span class=\"line\">网页包含内容：</span><br><span class=\"line\">1.项目名称</span><br><span class=\"line\">2.证书名称</span><br><span class=\"line\">3.版本号</span><br><span class=\"line\">4.编译号</span><br><span class=\"line\">5.备注信息</span><br><span class=\"line\">6.二维码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>smail.sh</p>\n<ul>\n<li><p>emails.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用来生成邮件信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sendmail.py</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发送邮件的脚本</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>plistUpload.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">提交之前生成好的plist文件到一个https站点（iOS7之后不支持http）, 这里就使用了coding.net的仓库。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dSYMUpload</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为自家接入的是bugly，每次app上线后，手动上传dSYM文件很麻烦。所以这里弄了个脚本，根据Jenkins配置信息是否是否上传bugly。将之前生成好的.dSYM.zip自动上传到bugly。</span><br><span class=\"line\"></span><br><span class=\"line\">上传参考代码：</span><br><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">URLEncodeFunc() &#123;</span><br><span class=\"line\">\tlocal length=&quot;$&#123;#1&#125;&quot;</span><br><span class=\"line\">\tfor (( i = 0; i &lt; length; i++ )); do</span><br><span class=\"line\">\t\tlocal c=&quot;$&#123;1:i:1&#125;&quot;</span><br><span class=\"line\">\t\tcase $c in</span><br><span class=\"line\">\t\t\t[a-zA-Z0-9.~_-]) printf &quot;$c&quot; ;;</span><br><span class=\"line\">\t\t\t*) printf &quot;$c&quot; | xxd -p -c1 | while read x;do printf &quot;%%%s&quot; &quot;$x&quot;;done</span><br><span class=\"line\">\t\tesac</span><br><span class=\"line\">\tdone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $Jenkins_dSYM_Upload = true ]]; then</span><br><span class=\"line\">\techo &quot;\\n上传 dSYM 到 Bugly...&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t# Bugly 的 TS 说他们要的是这样的版本号格式</span><br><span class=\"line\">\tBugly_Version=&quot;$&#123;Bundle_Version&#125;($&#123;New_BuildVersion&#125;)&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t# pid默认为2</span><br><span class=\"line\">\tdSYM_Pid=&quot;2&quot;</span><br><span class=\"line\">\tdSYM_AppID=$&#123;Bugly_AppId&#125;</span><br><span class=\"line\">\tdSYM_AppKey=$&#123;Bugly_AppKey&#125;</span><br><span class=\"line\">\tdSYM_BundleId=$&#123;Bundle_Identifier&#125;</span><br><span class=\"line\">\tdSYM_Version=`URLEncodeFunc $&#123;Bugly_Version&#125;`</span><br><span class=\"line\">\tdSYM_ZipFileName=`URLEncodeFunc $&#123;dSYM_Path&#125;`</span><br><span class=\"line\"></span><br><span class=\"line\">\tjava -jar $&#123;Bugly_JAR_Path&#125; -i $&#123;dSYM_Path&#125; -u -id $&#123;dSYM_AppID&#125; -key $&#123;dSYM_AppKey&#125; -package $&#123;dSYM_BundleId&#125; -version $&#123;dSYM_Version&#125; 1&gt;/dev/null</span><br><span class=\"line\"></span><br><span class=\"line\">else</span><br><span class=\"line\">\techo &quot;\\n不上传 dSYM 到 bugly\\n&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">rm -rf $&#123;dSYM_Path&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>appstore.sh</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"layout":"[layout]","title":"VPS搭建个人博客/相册教程03_zing-gallery个人相册配置","date":"2017-11-22T10:40:51.000Z","_content":"\n\n\n> zing-gallery是github上一个基于node.js开源的web相册，完美适配了移动设备。\n\n---\n\n## 1、clone [zing-gallery](https://github.com/litten/zing-gallery.git)到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\n\n```\n1. # git clone https://github.com/litten/zing-gallery.git\n2. # git remote rm origin \n3. # git remote add origin git@xx.xx.xx.xx:repo/gallery.git # 修改远程仓库地址为自己服务器上创建的git仓库\n4. # git remote -v # 查看远程仓库地址\n5. # git add .\n6. # git commit\n7. # git push\n```\n\n<!-- more -->\n\n## 2、在linux上安装npm依赖\n\n### 2.1 ssh登录到vps\n\n### 2.2 cd 到gellery远程代码仓库目录下\n\n### 2.3 安装依赖\n\n```\nnpm install\n```\n\n### 2.4 开启node服务\n\n```\nnpm run start\n```\n\nnode会默认开启一个端口为3000的服务，端口号可以在app.js文件中修改。在浏览器中通过域名+端口访问相册页面。\n\n### 2.5 常见错误\n\n> npm install 和npm run start的时候经常报错，整理了这个过程中遇到的一些异常处理。\n\n* 端口被占用\n\n  ```\n  # 找出所有node应用\n  ps -ax | grep node\n  # kill node进程\n  sudo kill 端口号\n  ```\n\n* images库下载失败\n\n  ```\n  npm rebuild images --force\n  ```\n\n* libc.so.6: version GLIBC_2.14 not found\n\n  ```\n  1.查看系统版本和glibc库版本\n  # cat /etc/redhat-release \n  CentOS release 6.9 (Final)\n\n  #  strings /lib64/libc.so.6 |grep GLIBC_\n  GLIBC_2.2.5\n  GLIBC_2.2.6\n  GLIBC_2.3\n  GLIBC_2.3.2\n  GLIBC_2.3.3\n  GLIBC_2.3.4\n  GLIBC_2.4\n  GLIBC_2.5\n  GLIBC_2.6\n  GLIBC_2.7\n  GLIBC_2.8\n  GLIBC_2.9\n  GLIBC_2.10\n  GLIBC_2.11\n  GLIBC_2.12\n  GLIBC_PRIVATE\n\n  发现CentOS6.9最高支持glibc的版本为2.12。\n\n  2.升级glibc\n  # wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz \n  # wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz \n  # tar -xvf  glibc-2.14.tar.gz \n  # tar -xvf  glibc-ports-2.14.tar.gz\n  # mv glibc-ports-2.14 glibc-2.14/ports\n  # mkdir glibc-build-2.14\n  # cd glibc-build-2.14/ \n  # ../glibc-2.14/configure  --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin\n  # make\n  # make install \n\n  3.安装完成，查看/lib64/libc.so.6软连接\n  # ll /lib64/libc.so.6 \n  /lib64/libc.so.6 -> /lib64/libc-2.14.so\n\n  4.查看glibc支持的版本\n  # strings /lib64/libc.so.6 |grep GLIBC_\n  GLIBC_2.2.5\n  GLIBC_2.2.6\n  GLIBC_2.3\n  GLIBC_2.3.2\n  GLIBC_2.3.3\n  GLIBC_2.3.4\n  GLIBC_2.4\n  GLIBC_2.5\n  GLIBC_2.6\n  GLIBC_2.7\n  GLIBC_2.8\n  GLIBC_2.9\n  GLIBC_2.10\n  GLIBC_2.11\n  GLIBC_2.12\n  GLIBC_2.13\n  GLIBC_2.14\n  GLIBC_PRIVAT\n  ```\n\n  ​\n\n## 3、修改nginx配置，设置反向代理\n\n```\nserver\n    {\n        listen 80;\n        #listen [::]:80;\n        server_name ruidada.info ;\n        index index.html index.htm index.php default.html default.htm default.php;\n        root  /home/wwwroot/blog;\n        charset utf-8;\n        location /gallery/ {\n            proxy_pass http://127.0.0.1:3000/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_redirect off;\n        }\n\n        access_log  /home/wwwlogs/ruidada.info.log;\n    }\n```\n\n至此配置好反向代理之后。重启nginx服务。这个时候，就可以在浏览器中通过域名+/gallery/访问相册页面了。\n\n## 4、用supervisor开启管理相册进程\n\n> 由于相册服务需要你在每次服务器重启之后手动执行一下npm run start命令去开启node进程，有时该node进程被杀死，相册服务都无法开启了。这样为了方便在服务器重启或者该相册进程被kill之后能够自动重新开启，恢复正常的相册服务功能。所以需要使用到supervisor这个自动管理进程工具，且supervisor依赖于python环境。 查看python版本，如果没有安装python，可以在https://www.python.org/downloads/source/网站下载对应的python版本，解压安装即可。\n\n### 4.1 安装supervisor\n\n```\n1. # python -V \n2. # wget https://pypi.python.org/packages/80/37/964c0d53cbd328796b1aeb7abea4c0f7b0e8c7197ea9b0b9967b7d004def/supervisor-3.3.1.tar.gz\n3. # tar zxf supervisor-3.3.1.tar.gz\n4. # cd supervisor-3.3.1\n5. # python setup.py install  \n\t5.1 如果报错：Couldn't find index page for 'meld3' (maybe misspelled?)....\n        1. # wget https://pypi.python.org/packages/3e/ab/9615164b2a4a935e34a62646e9106445e9895464079c13c1ac1200dd88c8/meld3-0.6.7.tar.gz#md5=53e589482029ee84ffac9362db71eabe\n        2. # tar -zxvf meld3-0.6.7.tar.gz\n        3. # cd meld3-0.6.7\n        4. # python setup.py  install\n\t\t\trunning install_egg_info\n\t\t\tWriting /usr/lib/python2.6/site-packages/meld3-0.6.7-py2.6.egg-info\n\t5.2 Finished processing dependencies for supervisor==3.3.1...\n```\n\n\n\n### 4.2 supervisor相关命令介绍：\n\n* supervisortd：守护进程服务（用于接收进程管理命令）\n* supervisorctl：客户端（用于和守护进程通信，发送管理进程的指令）\n  * supervisord : 启动supervisor\n  * supervisorctl reload :修改完配置文件后重新启动supervisor\n  * supervisorctl status :查看supervisor监管的进程状态\n  * supervisorctl start 进程名 ：启动XXX进程\n  * supervisorctl stop 进程名 ：停止XXX进程\n  * supervisorctl stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文件。\n  * supervisorctl update：根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重\n* echo_supervisord_conf：生成初始配置文件\n\n### 4.3 配置\n\n```\n1.生成配置文件\n# mkdir /etc/supervisor // 新建一个文件夹\n# echo_supervisord_conf > /etc/supervisor/supervisord.conf\n2.启动\n# supervisord -c /etc/supervisor/supervisord.conf\n3.查看 supervisord 是否在运行：\n# ps aux | grep supervisord\n4.打开配置文件\n# vim /etc/supervisor/supervisord.conf\n在配置文件底部，配置include\n[include]\nfiles = /etc/supervisor/conf.d/*.conf\n5.新建一个gallery进程配置\n# mkdir conf.d\n# cd /etc/supervisor/conf.d \n# vim gallery.conf \n添加如下代码：\n[program:gallery]        ;进程名，对应supervisor客户端supervisorctl中对进\n程管理的名字\ncommand=npm run start    ;启动命令\nautostart=true           ;supervisord启动的时候启动\ndirectory=/home/wwwroot/gallery   ;进程的启动目录\nautorestart=true         ;进程异常退出后自动重启\nstartsecs=10             ;进程启动多少秒之后，此时状态如果是running，则认\n为启动成功\nstartretries=5           ;最大启动重试次数\n\n```\n\n### 4.4 重启配置 \n\n```\nsupervisorctl reload\n```\n\n---\n\n至此相册配置已经完成，在浏览器中通过域名+/gallery/，就可以打开你的相册页面啦。\n\n关于图片如何配置上传。参考[zing-gallery](https://github.com/litten/zing-gallery.git)的readme文件。\n\n上传图片之后，使用git push到自己的服务器上。就可以实现图片动态上传更新了。\n\n把自己的旅行的风景照片，生活中有趣的照片分享出去。","source":"_posts/VPS_02_03.md","raw":"---\nlayout: '[layout]'\ntitle: VPS搭建个人博客/相册教程03_zing-gallery个人相册配置\ndate: 2017-11-22 18:40:51\ncategories: \n- 教程\n- [教程, Hexo]\ntags: \n- 教程\n- hexo\n---\n\n\n\n> zing-gallery是github上一个基于node.js开源的web相册，完美适配了移动设备。\n\n---\n\n## 1、clone [zing-gallery](https://github.com/litten/zing-gallery.git)到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\n\n```\n1. # git clone https://github.com/litten/zing-gallery.git\n2. # git remote rm origin \n3. # git remote add origin git@xx.xx.xx.xx:repo/gallery.git # 修改远程仓库地址为自己服务器上创建的git仓库\n4. # git remote -v # 查看远程仓库地址\n5. # git add .\n6. # git commit\n7. # git push\n```\n\n<!-- more -->\n\n## 2、在linux上安装npm依赖\n\n### 2.1 ssh登录到vps\n\n### 2.2 cd 到gellery远程代码仓库目录下\n\n### 2.3 安装依赖\n\n```\nnpm install\n```\n\n### 2.4 开启node服务\n\n```\nnpm run start\n```\n\nnode会默认开启一个端口为3000的服务，端口号可以在app.js文件中修改。在浏览器中通过域名+端口访问相册页面。\n\n### 2.5 常见错误\n\n> npm install 和npm run start的时候经常报错，整理了这个过程中遇到的一些异常处理。\n\n* 端口被占用\n\n  ```\n  # 找出所有node应用\n  ps -ax | grep node\n  # kill node进程\n  sudo kill 端口号\n  ```\n\n* images库下载失败\n\n  ```\n  npm rebuild images --force\n  ```\n\n* libc.so.6: version GLIBC_2.14 not found\n\n  ```\n  1.查看系统版本和glibc库版本\n  # cat /etc/redhat-release \n  CentOS release 6.9 (Final)\n\n  #  strings /lib64/libc.so.6 |grep GLIBC_\n  GLIBC_2.2.5\n  GLIBC_2.2.6\n  GLIBC_2.3\n  GLIBC_2.3.2\n  GLIBC_2.3.3\n  GLIBC_2.3.4\n  GLIBC_2.4\n  GLIBC_2.5\n  GLIBC_2.6\n  GLIBC_2.7\n  GLIBC_2.8\n  GLIBC_2.9\n  GLIBC_2.10\n  GLIBC_2.11\n  GLIBC_2.12\n  GLIBC_PRIVATE\n\n  发现CentOS6.9最高支持glibc的版本为2.12。\n\n  2.升级glibc\n  # wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz \n  # wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz \n  # tar -xvf  glibc-2.14.tar.gz \n  # tar -xvf  glibc-ports-2.14.tar.gz\n  # mv glibc-ports-2.14 glibc-2.14/ports\n  # mkdir glibc-build-2.14\n  # cd glibc-build-2.14/ \n  # ../glibc-2.14/configure  --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin\n  # make\n  # make install \n\n  3.安装完成，查看/lib64/libc.so.6软连接\n  # ll /lib64/libc.so.6 \n  /lib64/libc.so.6 -> /lib64/libc-2.14.so\n\n  4.查看glibc支持的版本\n  # strings /lib64/libc.so.6 |grep GLIBC_\n  GLIBC_2.2.5\n  GLIBC_2.2.6\n  GLIBC_2.3\n  GLIBC_2.3.2\n  GLIBC_2.3.3\n  GLIBC_2.3.4\n  GLIBC_2.4\n  GLIBC_2.5\n  GLIBC_2.6\n  GLIBC_2.7\n  GLIBC_2.8\n  GLIBC_2.9\n  GLIBC_2.10\n  GLIBC_2.11\n  GLIBC_2.12\n  GLIBC_2.13\n  GLIBC_2.14\n  GLIBC_PRIVAT\n  ```\n\n  ​\n\n## 3、修改nginx配置，设置反向代理\n\n```\nserver\n    {\n        listen 80;\n        #listen [::]:80;\n        server_name ruidada.info ;\n        index index.html index.htm index.php default.html default.htm default.php;\n        root  /home/wwwroot/blog;\n        charset utf-8;\n        location /gallery/ {\n            proxy_pass http://127.0.0.1:3000/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_redirect off;\n        }\n\n        access_log  /home/wwwlogs/ruidada.info.log;\n    }\n```\n\n至此配置好反向代理之后。重启nginx服务。这个时候，就可以在浏览器中通过域名+/gallery/访问相册页面了。\n\n## 4、用supervisor开启管理相册进程\n\n> 由于相册服务需要你在每次服务器重启之后手动执行一下npm run start命令去开启node进程，有时该node进程被杀死，相册服务都无法开启了。这样为了方便在服务器重启或者该相册进程被kill之后能够自动重新开启，恢复正常的相册服务功能。所以需要使用到supervisor这个自动管理进程工具，且supervisor依赖于python环境。 查看python版本，如果没有安装python，可以在https://www.python.org/downloads/source/网站下载对应的python版本，解压安装即可。\n\n### 4.1 安装supervisor\n\n```\n1. # python -V \n2. # wget https://pypi.python.org/packages/80/37/964c0d53cbd328796b1aeb7abea4c0f7b0e8c7197ea9b0b9967b7d004def/supervisor-3.3.1.tar.gz\n3. # tar zxf supervisor-3.3.1.tar.gz\n4. # cd supervisor-3.3.1\n5. # python setup.py install  \n\t5.1 如果报错：Couldn't find index page for 'meld3' (maybe misspelled?)....\n        1. # wget https://pypi.python.org/packages/3e/ab/9615164b2a4a935e34a62646e9106445e9895464079c13c1ac1200dd88c8/meld3-0.6.7.tar.gz#md5=53e589482029ee84ffac9362db71eabe\n        2. # tar -zxvf meld3-0.6.7.tar.gz\n        3. # cd meld3-0.6.7\n        4. # python setup.py  install\n\t\t\trunning install_egg_info\n\t\t\tWriting /usr/lib/python2.6/site-packages/meld3-0.6.7-py2.6.egg-info\n\t5.2 Finished processing dependencies for supervisor==3.3.1...\n```\n\n\n\n### 4.2 supervisor相关命令介绍：\n\n* supervisortd：守护进程服务（用于接收进程管理命令）\n* supervisorctl：客户端（用于和守护进程通信，发送管理进程的指令）\n  * supervisord : 启动supervisor\n  * supervisorctl reload :修改完配置文件后重新启动supervisor\n  * supervisorctl status :查看supervisor监管的进程状态\n  * supervisorctl start 进程名 ：启动XXX进程\n  * supervisorctl stop 进程名 ：停止XXX进程\n  * supervisorctl stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文件。\n  * supervisorctl update：根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重\n* echo_supervisord_conf：生成初始配置文件\n\n### 4.3 配置\n\n```\n1.生成配置文件\n# mkdir /etc/supervisor // 新建一个文件夹\n# echo_supervisord_conf > /etc/supervisor/supervisord.conf\n2.启动\n# supervisord -c /etc/supervisor/supervisord.conf\n3.查看 supervisord 是否在运行：\n# ps aux | grep supervisord\n4.打开配置文件\n# vim /etc/supervisor/supervisord.conf\n在配置文件底部，配置include\n[include]\nfiles = /etc/supervisor/conf.d/*.conf\n5.新建一个gallery进程配置\n# mkdir conf.d\n# cd /etc/supervisor/conf.d \n# vim gallery.conf \n添加如下代码：\n[program:gallery]        ;进程名，对应supervisor客户端supervisorctl中对进\n程管理的名字\ncommand=npm run start    ;启动命令\nautostart=true           ;supervisord启动的时候启动\ndirectory=/home/wwwroot/gallery   ;进程的启动目录\nautorestart=true         ;进程异常退出后自动重启\nstartsecs=10             ;进程启动多少秒之后，此时状态如果是running，则认\n为启动成功\nstartretries=5           ;最大启动重试次数\n\n```\n\n### 4.4 重启配置 \n\n```\nsupervisorctl reload\n```\n\n---\n\n至此相册配置已经完成，在浏览器中通过域名+/gallery/，就可以打开你的相册页面啦。\n\n关于图片如何配置上传。参考[zing-gallery](https://github.com/litten/zing-gallery.git)的readme文件。\n\n上传图片之后，使用git push到自己的服务器上。就可以实现图片动态上传更新了。\n\n把自己的旅行的风景照片，生活中有趣的照片分享出去。","slug":"VPS_02_03","published":1,"updated":"2019-12-20T06:08:22.049Z","comments":1,"photos":[],"link":"","_id":"ck4dsux2z000codnq9cdde1ww","content":"<blockquote>\n<p>zing-gallery是github上一个基于node.js开源的web相册，完美适配了移动设备。</p>\n</blockquote>\n<hr>\n<h2 id=\"1、clone-zing-gallery到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\"><a href=\"#1、clone-zing-gallery到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\" class=\"headerlink\" title=\"1、clone zing-gallery到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\"></a>1、clone <a href=\"https://github.com/litten/zing-gallery.git\" target=\"_blank\" rel=\"noopener\">zing-gallery</a>到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. # git clone https://github.com/litten/zing-gallery.git</span><br><span class=\"line\">2. # git remote rm origin </span><br><span class=\"line\">3. # git remote add origin git@xx.xx.xx.xx:repo/gallery.git # 修改远程仓库地址为自己服务器上创建的git仓库</span><br><span class=\"line\">4. # git remote -v # 查看远程仓库地址</span><br><span class=\"line\">5. # git add .</span><br><span class=\"line\">6. # git commit</span><br><span class=\"line\">7. # git push</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"2、在linux上安装npm依赖\"><a href=\"#2、在linux上安装npm依赖\" class=\"headerlink\" title=\"2、在linux上安装npm依赖\"></a>2、在linux上安装npm依赖</h2><h3 id=\"2-1-ssh登录到vps\"><a href=\"#2-1-ssh登录到vps\" class=\"headerlink\" title=\"2.1 ssh登录到vps\"></a>2.1 ssh登录到vps</h3><h3 id=\"2-2-cd-到gellery远程代码仓库目录下\"><a href=\"#2-2-cd-到gellery远程代码仓库目录下\" class=\"headerlink\" title=\"2.2 cd 到gellery远程代码仓库目录下\"></a>2.2 cd 到gellery远程代码仓库目录下</h3><h3 id=\"2-3-安装依赖\"><a href=\"#2-3-安装依赖\" class=\"headerlink\" title=\"2.3 安装依赖\"></a>2.3 安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-开启node服务\"><a href=\"#2-4-开启node服务\" class=\"headerlink\" title=\"2.4 开启node服务\"></a>2.4 开启node服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n<p>node会默认开启一个端口为3000的服务，端口号可以在app.js文件中修改。在浏览器中通过域名+端口访问相册页面。</p>\n<h3 id=\"2-5-常见错误\"><a href=\"#2-5-常见错误\" class=\"headerlink\" title=\"2.5 常见错误\"></a>2.5 常见错误</h3><blockquote>\n<p>npm install 和npm run start的时候经常报错，整理了这个过程中遇到的一些异常处理。</p>\n</blockquote>\n<ul>\n<li><p>端口被占用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 找出所有node应用</span><br><span class=\"line\">ps -ax | grep node</span><br><span class=\"line\"># kill node进程</span><br><span class=\"line\">sudo kill 端口号</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>images库下载失败</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm rebuild images --force</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>libc.so.6: version GLIBC_2.14 not found</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看系统版本和glibc库版本</span><br><span class=\"line\"># cat /etc/redhat-release </span><br><span class=\"line\">CentOS release 6.9 (Final)</span><br><span class=\"line\"></span><br><span class=\"line\">#  strings /lib64/libc.so.6 |grep GLIBC_</span><br><span class=\"line\">GLIBC_2.2.5</span><br><span class=\"line\">GLIBC_2.2.6</span><br><span class=\"line\">GLIBC_2.3</span><br><span class=\"line\">GLIBC_2.3.2</span><br><span class=\"line\">GLIBC_2.3.3</span><br><span class=\"line\">GLIBC_2.3.4</span><br><span class=\"line\">GLIBC_2.4</span><br><span class=\"line\">GLIBC_2.5</span><br><span class=\"line\">GLIBC_2.6</span><br><span class=\"line\">GLIBC_2.7</span><br><span class=\"line\">GLIBC_2.8</span><br><span class=\"line\">GLIBC_2.9</span><br><span class=\"line\">GLIBC_2.10</span><br><span class=\"line\">GLIBC_2.11</span><br><span class=\"line\">GLIBC_2.12</span><br><span class=\"line\">GLIBC_PRIVATE</span><br><span class=\"line\"></span><br><span class=\"line\">发现CentOS6.9最高支持glibc的版本为2.12。</span><br><span class=\"line\"></span><br><span class=\"line\">2.升级glibc</span><br><span class=\"line\"># wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz </span><br><span class=\"line\"># wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz </span><br><span class=\"line\"># tar -xvf  glibc-2.14.tar.gz </span><br><span class=\"line\"># tar -xvf  glibc-ports-2.14.tar.gz</span><br><span class=\"line\"># mv glibc-ports-2.14 glibc-2.14/ports</span><br><span class=\"line\"># mkdir glibc-build-2.14</span><br><span class=\"line\"># cd glibc-build-2.14/ </span><br><span class=\"line\"># ../glibc-2.14/configure  --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</span><br><span class=\"line\"># make</span><br><span class=\"line\"># make install </span><br><span class=\"line\"></span><br><span class=\"line\">3.安装完成，查看/lib64/libc.so.6软连接</span><br><span class=\"line\"># ll /lib64/libc.so.6 </span><br><span class=\"line\">/lib64/libc.so.6 -&gt; /lib64/libc-2.14.so</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看glibc支持的版本</span><br><span class=\"line\"># strings /lib64/libc.so.6 |grep GLIBC_</span><br><span class=\"line\">GLIBC_2.2.5</span><br><span class=\"line\">GLIBC_2.2.6</span><br><span class=\"line\">GLIBC_2.3</span><br><span class=\"line\">GLIBC_2.3.2</span><br><span class=\"line\">GLIBC_2.3.3</span><br><span class=\"line\">GLIBC_2.3.4</span><br><span class=\"line\">GLIBC_2.4</span><br><span class=\"line\">GLIBC_2.5</span><br><span class=\"line\">GLIBC_2.6</span><br><span class=\"line\">GLIBC_2.7</span><br><span class=\"line\">GLIBC_2.8</span><br><span class=\"line\">GLIBC_2.9</span><br><span class=\"line\">GLIBC_2.10</span><br><span class=\"line\">GLIBC_2.11</span><br><span class=\"line\">GLIBC_2.12</span><br><span class=\"line\">GLIBC_2.13</span><br><span class=\"line\">GLIBC_2.14</span><br><span class=\"line\">GLIBC_PRIVAT</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"3、修改nginx配置，设置反向代理\"><a href=\"#3、修改nginx配置，设置反向代理\" class=\"headerlink\" title=\"3、修改nginx配置，设置反向代理\"></a>3、修改nginx配置，设置反向代理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        #listen [::]:80;</span><br><span class=\"line\">        server_name ruidada.info ;</span><br><span class=\"line\">        index index.html index.htm index.php default.html default.htm default.php;</span><br><span class=\"line\">        root  /home/wwwroot/blog;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        location /gallery/ &#123;</span><br><span class=\"line\">            proxy_pass http://127.0.0.1:3000/;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            proxy_redirect off;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        access_log  /home/wwwlogs/ruidada.info.log;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>至此配置好反向代理之后。重启nginx服务。这个时候，就可以在浏览器中通过域名+/gallery/访问相册页面了。</p>\n<h2 id=\"4、用supervisor开启管理相册进程\"><a href=\"#4、用supervisor开启管理相册进程\" class=\"headerlink\" title=\"4、用supervisor开启管理相册进程\"></a>4、用supervisor开启管理相册进程</h2><blockquote>\n<p>由于相册服务需要你在每次服务器重启之后手动执行一下npm run start命令去开启node进程，有时该node进程被杀死，相册服务都无法开启了。这样为了方便在服务器重启或者该相册进程被kill之后能够自动重新开启，恢复正常的相册服务功能。所以需要使用到supervisor这个自动管理进程工具，且supervisor依赖于python环境。 查看python版本，如果没有安装python，可以在<a href=\"https://www.python.org/downloads/source/网站下载对应的python版本，解压安装即可。\" target=\"_blank\" rel=\"noopener\">https://www.python.org/downloads/source/网站下载对应的python版本，解压安装即可。</a></p>\n</blockquote>\n<h3 id=\"4-1-安装supervisor\"><a href=\"#4-1-安装supervisor\" class=\"headerlink\" title=\"4.1 安装supervisor\"></a>4.1 安装supervisor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. # python -V </span><br><span class=\"line\">2. # wget https://pypi.python.org/packages/80/37/964c0d53cbd328796b1aeb7abea4c0f7b0e8c7197ea9b0b9967b7d004def/supervisor-3.3.1.tar.gz</span><br><span class=\"line\">3. # tar zxf supervisor-3.3.1.tar.gz</span><br><span class=\"line\">4. # cd supervisor-3.3.1</span><br><span class=\"line\">5. # python setup.py install  </span><br><span class=\"line\">\t5.1 如果报错：Couldn&apos;t find index page for &apos;meld3&apos; (maybe misspelled?)....</span><br><span class=\"line\">        1. # wget https://pypi.python.org/packages/3e/ab/9615164b2a4a935e34a62646e9106445e9895464079c13c1ac1200dd88c8/meld3-0.6.7.tar.gz#md5=53e589482029ee84ffac9362db71eabe</span><br><span class=\"line\">        2. # tar -zxvf meld3-0.6.7.tar.gz</span><br><span class=\"line\">        3. # cd meld3-0.6.7</span><br><span class=\"line\">        4. # python setup.py  install</span><br><span class=\"line\">\t\t\trunning install_egg_info</span><br><span class=\"line\">\t\t\tWriting /usr/lib/python2.6/site-packages/meld3-0.6.7-py2.6.egg-info</span><br><span class=\"line\">\t5.2 Finished processing dependencies for supervisor==3.3.1...</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-supervisor相关命令介绍：\"><a href=\"#4-2-supervisor相关命令介绍：\" class=\"headerlink\" title=\"4.2 supervisor相关命令介绍：\"></a>4.2 supervisor相关命令介绍：</h3><ul>\n<li>supervisortd：守护进程服务（用于接收进程管理命令）</li>\n<li>supervisorctl：客户端（用于和守护进程通信，发送管理进程的指令）<ul>\n<li>supervisord : 启动supervisor</li>\n<li>supervisorctl reload :修改完配置文件后重新启动supervisor</li>\n<li>supervisorctl status :查看supervisor监管的进程状态</li>\n<li>supervisorctl start 进程名 ：启动XXX进程</li>\n<li>supervisorctl stop 进程名 ：停止XXX进程</li>\n<li>supervisorctl stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文件。</li>\n<li>supervisorctl update：根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重</li>\n</ul>\n</li>\n<li>echo_supervisord_conf：生成初始配置文件</li>\n</ul>\n<h3 id=\"4-3-配置\"><a href=\"#4-3-配置\" class=\"headerlink\" title=\"4.3 配置\"></a>4.3 配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.生成配置文件</span><br><span class=\"line\"># mkdir /etc/supervisor // 新建一个文件夹</span><br><span class=\"line\"># echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span><br><span class=\"line\">2.启动</span><br><span class=\"line\"># supervisord -c /etc/supervisor/supervisord.conf</span><br><span class=\"line\">3.查看 supervisord 是否在运行：</span><br><span class=\"line\"># ps aux | grep supervisord</span><br><span class=\"line\">4.打开配置文件</span><br><span class=\"line\"># vim /etc/supervisor/supervisord.conf</span><br><span class=\"line\">在配置文件底部，配置include</span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = /etc/supervisor/conf.d/*.conf</span><br><span class=\"line\">5.新建一个gallery进程配置</span><br><span class=\"line\"># mkdir conf.d</span><br><span class=\"line\"># cd /etc/supervisor/conf.d </span><br><span class=\"line\"># vim gallery.conf </span><br><span class=\"line\">添加如下代码：</span><br><span class=\"line\">[program:gallery]        ;进程名，对应supervisor客户端supervisorctl中对进</span><br><span class=\"line\">程管理的名字</span><br><span class=\"line\">command=npm run start    ;启动命令</span><br><span class=\"line\">autostart=true           ;supervisord启动的时候启动</span><br><span class=\"line\">directory=/home/wwwroot/gallery   ;进程的启动目录</span><br><span class=\"line\">autorestart=true         ;进程异常退出后自动重启</span><br><span class=\"line\">startsecs=10             ;进程启动多少秒之后，此时状态如果是running，则认</span><br><span class=\"line\">为启动成功</span><br><span class=\"line\">startretries=5           ;最大启动重试次数</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-4-重启配置\"><a href=\"#4-4-重启配置\" class=\"headerlink\" title=\"4.4 重启配置\"></a>4.4 重启配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisorctl reload</span><br></pre></td></tr></table></figure>\n<hr>\n<p>至此相册配置已经完成，在浏览器中通过域名+/gallery/，就可以打开你的相册页面啦。</p>\n<p>关于图片如何配置上传。参考<a href=\"https://github.com/litten/zing-gallery.git\" target=\"_blank\" rel=\"noopener\">zing-gallery</a>的readme文件。</p>\n<p>上传图片之后，使用git push到自己的服务器上。就可以实现图片动态上传更新了。</p>\n<p>把自己的旅行的风景照片，生活中有趣的照片分享出去。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>zing-gallery是github上一个基于node.js开源的web相册，完美适配了移动设备。</p>\n</blockquote>\n<hr>\n<h2 id=\"1、clone-zing-gallery到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\"><a href=\"#1、clone-zing-gallery到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\" class=\"headerlink\" title=\"1、clone zing-gallery到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码\"></a>1、clone <a href=\"https://github.com/litten/zing-gallery.git\" target=\"_blank\" rel=\"noopener\">zing-gallery</a>到本地，修改远程仓库地址为自己的服务器上gallery仓库地址，push代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. # git clone https://github.com/litten/zing-gallery.git</span><br><span class=\"line\">2. # git remote rm origin </span><br><span class=\"line\">3. # git remote add origin git@xx.xx.xx.xx:repo/gallery.git # 修改远程仓库地址为自己服务器上创建的git仓库</span><br><span class=\"line\">4. # git remote -v # 查看远程仓库地址</span><br><span class=\"line\">5. # git add .</span><br><span class=\"line\">6. # git commit</span><br><span class=\"line\">7. # git push</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"2、在linux上安装npm依赖\"><a href=\"#2、在linux上安装npm依赖\" class=\"headerlink\" title=\"2、在linux上安装npm依赖\"></a>2、在linux上安装npm依赖</h2><h3 id=\"2-1-ssh登录到vps\"><a href=\"#2-1-ssh登录到vps\" class=\"headerlink\" title=\"2.1 ssh登录到vps\"></a>2.1 ssh登录到vps</h3><h3 id=\"2-2-cd-到gellery远程代码仓库目录下\"><a href=\"#2-2-cd-到gellery远程代码仓库目录下\" class=\"headerlink\" title=\"2.2 cd 到gellery远程代码仓库目录下\"></a>2.2 cd 到gellery远程代码仓库目录下</h3><h3 id=\"2-3-安装依赖\"><a href=\"#2-3-安装依赖\" class=\"headerlink\" title=\"2.3 安装依赖\"></a>2.3 安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-开启node服务\"><a href=\"#2-4-开启node服务\" class=\"headerlink\" title=\"2.4 开启node服务\"></a>2.4 开启node服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n<p>node会默认开启一个端口为3000的服务，端口号可以在app.js文件中修改。在浏览器中通过域名+端口访问相册页面。</p>\n<h3 id=\"2-5-常见错误\"><a href=\"#2-5-常见错误\" class=\"headerlink\" title=\"2.5 常见错误\"></a>2.5 常见错误</h3><blockquote>\n<p>npm install 和npm run start的时候经常报错，整理了这个过程中遇到的一些异常处理。</p>\n</blockquote>\n<ul>\n<li><p>端口被占用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 找出所有node应用</span><br><span class=\"line\">ps -ax | grep node</span><br><span class=\"line\"># kill node进程</span><br><span class=\"line\">sudo kill 端口号</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>images库下载失败</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm rebuild images --force</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>libc.so.6: version GLIBC_2.14 not found</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看系统版本和glibc库版本</span><br><span class=\"line\"># cat /etc/redhat-release </span><br><span class=\"line\">CentOS release 6.9 (Final)</span><br><span class=\"line\"></span><br><span class=\"line\">#  strings /lib64/libc.so.6 |grep GLIBC_</span><br><span class=\"line\">GLIBC_2.2.5</span><br><span class=\"line\">GLIBC_2.2.6</span><br><span class=\"line\">GLIBC_2.3</span><br><span class=\"line\">GLIBC_2.3.2</span><br><span class=\"line\">GLIBC_2.3.3</span><br><span class=\"line\">GLIBC_2.3.4</span><br><span class=\"line\">GLIBC_2.4</span><br><span class=\"line\">GLIBC_2.5</span><br><span class=\"line\">GLIBC_2.6</span><br><span class=\"line\">GLIBC_2.7</span><br><span class=\"line\">GLIBC_2.8</span><br><span class=\"line\">GLIBC_2.9</span><br><span class=\"line\">GLIBC_2.10</span><br><span class=\"line\">GLIBC_2.11</span><br><span class=\"line\">GLIBC_2.12</span><br><span class=\"line\">GLIBC_PRIVATE</span><br><span class=\"line\"></span><br><span class=\"line\">发现CentOS6.9最高支持glibc的版本为2.12。</span><br><span class=\"line\"></span><br><span class=\"line\">2.升级glibc</span><br><span class=\"line\"># wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz </span><br><span class=\"line\"># wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz </span><br><span class=\"line\"># tar -xvf  glibc-2.14.tar.gz </span><br><span class=\"line\"># tar -xvf  glibc-ports-2.14.tar.gz</span><br><span class=\"line\"># mv glibc-ports-2.14 glibc-2.14/ports</span><br><span class=\"line\"># mkdir glibc-build-2.14</span><br><span class=\"line\"># cd glibc-build-2.14/ </span><br><span class=\"line\"># ../glibc-2.14/configure  --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</span><br><span class=\"line\"># make</span><br><span class=\"line\"># make install </span><br><span class=\"line\"></span><br><span class=\"line\">3.安装完成，查看/lib64/libc.so.6软连接</span><br><span class=\"line\"># ll /lib64/libc.so.6 </span><br><span class=\"line\">/lib64/libc.so.6 -&gt; /lib64/libc-2.14.so</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看glibc支持的版本</span><br><span class=\"line\"># strings /lib64/libc.so.6 |grep GLIBC_</span><br><span class=\"line\">GLIBC_2.2.5</span><br><span class=\"line\">GLIBC_2.2.6</span><br><span class=\"line\">GLIBC_2.3</span><br><span class=\"line\">GLIBC_2.3.2</span><br><span class=\"line\">GLIBC_2.3.3</span><br><span class=\"line\">GLIBC_2.3.4</span><br><span class=\"line\">GLIBC_2.4</span><br><span class=\"line\">GLIBC_2.5</span><br><span class=\"line\">GLIBC_2.6</span><br><span class=\"line\">GLIBC_2.7</span><br><span class=\"line\">GLIBC_2.8</span><br><span class=\"line\">GLIBC_2.9</span><br><span class=\"line\">GLIBC_2.10</span><br><span class=\"line\">GLIBC_2.11</span><br><span class=\"line\">GLIBC_2.12</span><br><span class=\"line\">GLIBC_2.13</span><br><span class=\"line\">GLIBC_2.14</span><br><span class=\"line\">GLIBC_PRIVAT</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"3、修改nginx配置，设置反向代理\"><a href=\"#3、修改nginx配置，设置反向代理\" class=\"headerlink\" title=\"3、修改nginx配置，设置反向代理\"></a>3、修改nginx配置，设置反向代理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        #listen [::]:80;</span><br><span class=\"line\">        server_name ruidada.info ;</span><br><span class=\"line\">        index index.html index.htm index.php default.html default.htm default.php;</span><br><span class=\"line\">        root  /home/wwwroot/blog;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        location /gallery/ &#123;</span><br><span class=\"line\">            proxy_pass http://127.0.0.1:3000/;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            proxy_redirect off;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        access_log  /home/wwwlogs/ruidada.info.log;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>至此配置好反向代理之后。重启nginx服务。这个时候，就可以在浏览器中通过域名+/gallery/访问相册页面了。</p>\n<h2 id=\"4、用supervisor开启管理相册进程\"><a href=\"#4、用supervisor开启管理相册进程\" class=\"headerlink\" title=\"4、用supervisor开启管理相册进程\"></a>4、用supervisor开启管理相册进程</h2><blockquote>\n<p>由于相册服务需要你在每次服务器重启之后手动执行一下npm run start命令去开启node进程，有时该node进程被杀死，相册服务都无法开启了。这样为了方便在服务器重启或者该相册进程被kill之后能够自动重新开启，恢复正常的相册服务功能。所以需要使用到supervisor这个自动管理进程工具，且supervisor依赖于python环境。 查看python版本，如果没有安装python，可以在<a href=\"https://www.python.org/downloads/source/网站下载对应的python版本，解压安装即可。\" target=\"_blank\" rel=\"noopener\">https://www.python.org/downloads/source/网站下载对应的python版本，解压安装即可。</a></p>\n</blockquote>\n<h3 id=\"4-1-安装supervisor\"><a href=\"#4-1-安装supervisor\" class=\"headerlink\" title=\"4.1 安装supervisor\"></a>4.1 安装supervisor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. # python -V </span><br><span class=\"line\">2. # wget https://pypi.python.org/packages/80/37/964c0d53cbd328796b1aeb7abea4c0f7b0e8c7197ea9b0b9967b7d004def/supervisor-3.3.1.tar.gz</span><br><span class=\"line\">3. # tar zxf supervisor-3.3.1.tar.gz</span><br><span class=\"line\">4. # cd supervisor-3.3.1</span><br><span class=\"line\">5. # python setup.py install  </span><br><span class=\"line\">\t5.1 如果报错：Couldn&apos;t find index page for &apos;meld3&apos; (maybe misspelled?)....</span><br><span class=\"line\">        1. # wget https://pypi.python.org/packages/3e/ab/9615164b2a4a935e34a62646e9106445e9895464079c13c1ac1200dd88c8/meld3-0.6.7.tar.gz#md5=53e589482029ee84ffac9362db71eabe</span><br><span class=\"line\">        2. # tar -zxvf meld3-0.6.7.tar.gz</span><br><span class=\"line\">        3. # cd meld3-0.6.7</span><br><span class=\"line\">        4. # python setup.py  install</span><br><span class=\"line\">\t\t\trunning install_egg_info</span><br><span class=\"line\">\t\t\tWriting /usr/lib/python2.6/site-packages/meld3-0.6.7-py2.6.egg-info</span><br><span class=\"line\">\t5.2 Finished processing dependencies for supervisor==3.3.1...</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-supervisor相关命令介绍：\"><a href=\"#4-2-supervisor相关命令介绍：\" class=\"headerlink\" title=\"4.2 supervisor相关命令介绍：\"></a>4.2 supervisor相关命令介绍：</h3><ul>\n<li>supervisortd：守护进程服务（用于接收进程管理命令）</li>\n<li>supervisorctl：客户端（用于和守护进程通信，发送管理进程的指令）<ul>\n<li>supervisord : 启动supervisor</li>\n<li>supervisorctl reload :修改完配置文件后重新启动supervisor</li>\n<li>supervisorctl status :查看supervisor监管的进程状态</li>\n<li>supervisorctl start 进程名 ：启动XXX进程</li>\n<li>supervisorctl stop 进程名 ：停止XXX进程</li>\n<li>supervisorctl stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文件。</li>\n<li>supervisorctl update：根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重</li>\n</ul>\n</li>\n<li>echo_supervisord_conf：生成初始配置文件</li>\n</ul>\n<h3 id=\"4-3-配置\"><a href=\"#4-3-配置\" class=\"headerlink\" title=\"4.3 配置\"></a>4.3 配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.生成配置文件</span><br><span class=\"line\"># mkdir /etc/supervisor // 新建一个文件夹</span><br><span class=\"line\"># echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span><br><span class=\"line\">2.启动</span><br><span class=\"line\"># supervisord -c /etc/supervisor/supervisord.conf</span><br><span class=\"line\">3.查看 supervisord 是否在运行：</span><br><span class=\"line\"># ps aux | grep supervisord</span><br><span class=\"line\">4.打开配置文件</span><br><span class=\"line\"># vim /etc/supervisor/supervisord.conf</span><br><span class=\"line\">在配置文件底部，配置include</span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = /etc/supervisor/conf.d/*.conf</span><br><span class=\"line\">5.新建一个gallery进程配置</span><br><span class=\"line\"># mkdir conf.d</span><br><span class=\"line\"># cd /etc/supervisor/conf.d </span><br><span class=\"line\"># vim gallery.conf </span><br><span class=\"line\">添加如下代码：</span><br><span class=\"line\">[program:gallery]        ;进程名，对应supervisor客户端supervisorctl中对进</span><br><span class=\"line\">程管理的名字</span><br><span class=\"line\">command=npm run start    ;启动命令</span><br><span class=\"line\">autostart=true           ;supervisord启动的时候启动</span><br><span class=\"line\">directory=/home/wwwroot/gallery   ;进程的启动目录</span><br><span class=\"line\">autorestart=true         ;进程异常退出后自动重启</span><br><span class=\"line\">startsecs=10             ;进程启动多少秒之后，此时状态如果是running，则认</span><br><span class=\"line\">为启动成功</span><br><span class=\"line\">startretries=5           ;最大启动重试次数</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-4-重启配置\"><a href=\"#4-4-重启配置\" class=\"headerlink\" title=\"4.4 重启配置\"></a>4.4 重启配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisorctl reload</span><br></pre></td></tr></table></figure>\n<hr>\n<p>至此相册配置已经完成，在浏览器中通过域名+/gallery/，就可以打开你的相册页面啦。</p>\n<p>关于图片如何配置上传。参考<a href=\"https://github.com/litten/zing-gallery.git\" target=\"_blank\" rel=\"noopener\">zing-gallery</a>的readme文件。</p>\n<p>上传图片之后，使用git push到自己的服务器上。就可以实现图片动态上传更新了。</p>\n<p>把自己的旅行的风景照片，生活中有趣的照片分享出去。</p>"},{"layout":"[layout]","title":"VPS搭建个人博客/相册教程02_hexo静态博客配置","date":"2017-11-20T08:29:01.000Z","_content":"\n\n> hexo是一个很牛皮的用于生成静态网页的博客框架，且对MarkDown语法支持的很好。比较酷的是，它还有很多主题和插件支持，目前使用最多最受程序员欢迎的一个静态博客框架。\n\n---\n\n本机环境：macOS10.12 、node：v9.2.0、npm： 5.5.1\n\n## 1、本地部署\n\n### 1.1 安装全局的hexo命令行工具\n```\nnpm install hexo-cli -g # -g表示全局安装\n```\n\n<!-- more -->\n\n### 1.2 安装deployer工具\n\n```\nnpm install hexo-deployer-git --save\n```\n\n### 1.3 创建blog目录，并初始化hexo项目\n\n```\nhexo init blog\n```\n\n### 1.4 安装npm依赖\n\n```\ncd blog && npm install\n```\n\n### 1.5. 启动本地服务\n\n```\nhexo server\n```\n\n### 1.6 在浏览器中输入http://localhost:4000打开本地页面\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171220_9.png)\n\n## 2、文件结构\n\n打开hexo文件夹，查看文件目录。\n\n- _config.yml：重要的配置文件\n- themes：主题\n- public：存放的是生成的静态网页\n- source：博客文章目录\n- scaffolds：生成文章等的命令模板文件\n- db.json：source解析所得到的\n- node_modules：npm依赖包\n- package.json：项目所需模块项目的配置信息\n\n## 3、配置信息\n\n```\ndeploy:\n      type: git\n      message: update\n      repo:\n        s1: git@xx.xx.xx.xx:repo/hexo.git,master # git地址\n#######################################################################\n# 皮肤\ntheme: yilia\n\n# 1、网站\ntitle: Rui's Blog # 网站标题\nsubtitle: # 网站副标题\ndescription: # 网站描述(主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。)\nauthor: Rui # 您的名字\nlanguage: # 网站使用的语言\ntimezone: # 网站时区(Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC )\n################################################\n\n# 2、网址\nurl: //ruidada.info # 网址\nroot: / # 网站根目录\npermalink: :year/:month/:day/:title/ # 文章的 永久链接(:year/:month/:day/:title/）\npermalink_defaults: # 永久链接中各部分的默认值\n################################################\n\n# 3、目录\nsource_dir: source # 资源文件夹，这个文件夹用来存放内容。\npublic_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags # 标签文件夹\narchive_dir: archives # 归档文件夹\ncategory_dir: categories # 分类文件夹\ncode_dir: downloads/code # Include code 文件夹\ni18n_dir: :lang # 国际化（i18n）文件夹\nskip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n################################################\n\n# 4、文章\nnew_post_name: :title.md # 新文章的文件名称\ndefault_layout: post # 预设布局\ntitlecase: false # 把标题转换为 title case\nexternal_link: true # 在新标签中打开链接\nfilename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false # 显示草稿\npost_asset_folder: false # 启动 Asset 文件夹\nrelative_link: false # 把链接改为与根目录的相对位址\nfuture: true # 显示未来的文章\nhighlight: # 代码块的设置\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n# PS:默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。\n\n################################################\n\n# 5、分类&标签\ndefault_category: uncategorized # 默认分类\ncategory_map: # 分类别名\ntag_map: # 标签别名\n################################################\n\n# 6、日期/时间格式\ndate_format: YYYY-MM-DD # 日期格式\ntime_format: HH:mm:ss # 时间格式\n################################################\n\n# 7、分页\nper_page: 5 # 每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page # 分页目录\n################################################\n```\n\n\n\n## 4、相关命令介绍\n\n### 4.1 新建文章\n\n```\nhexo new \"postName\" # 会在source/_posts目录下生成一个postName.md文件。该文件会被显示在页面上，连接可以访问。\n```\n\n### 4.2 新建草稿\n\n```\nhexo new draft \"new draft\" # 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。\n```\n\n### 4.3 预览草稿\n\n```\n 1.hexo server --drafts\n 2.或者修改_config.yml文件将render_drafts设置为true\n```\n\n### 4.4 将草稿添加到发布中\n\n```\nhexo publish [layout] <filename>\n```\n\n### 4.5 新建页面\n\n```\nhexo new page \"pageName\"\n```\n\n### 4.6 清除\n\n```\nhexo clean # 删除public文件夹\n```\n\n### 4.7 开启预览访问端口\n\n```\nhexo server\n```\n\n### 4.8 生成静态页面\n\n```\nhexo generate # 该命令会在主目录的public文件夹中生成静态页面\n```\n\n### 4.9 将静态页面部署到远程服务器上\n\n```\nhexo deploy\n```\n\n\n\n## 5、修改主题\n\nhexo默认主题是landscape。我这里选择使用[yilia](https://github.com/litten/hexo-theme-yilia)主题，主要是个人觉得yilia比较简洁大方还比较酷，且完美适配了移动设备。\n\n### 5.1 下载主题包到themes文件夹中\n\n```\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n### 5.2 修改hexo根目录下的 _config.yml文件 ,设置theme: yilia\n\n```\ntheme: yilia\n```\n\n\n\n## 6、添加文章目录功能\n\n### 6.1 修改~/themes/yilia/source/main.0cf68a.css文件\n\n在themes\\yilia\\source文件夹下的main.xxxx.css文件中，末尾添加如下代码：\n\n```css\n/* 新添加的 */\n#container .show-toc-btn,#container .toc-article{display:block}\n.toc-article{z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px}.toc-article .toc-close{font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc}.toc-article .toc-close:hover{color:#000}.toc-article .toc{font-size:12px;padding:0;line-height:20px}.toc-article .toc .toc-number{color:#333}.toc-article .toc .toc-text:hover{text-decoration:underline;color:#2a6496}.toc-article li{list-style-type:none}.toc-article .toc-level-1{margin:4px 0}.toc-article .toc-child{}@-moz-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-webkit-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-o-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}.show-toc-btn{display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9}.show-toc-btn .btn-bg{margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%}.show-toc-btn .btn-text{color:#999;font-size:12px}.show-toc-btn:hover{cursor:pointer}.show-toc-btn:hover .btn-bg{background-position:0 -16px}.show-toc-btn:hover .btn-text{font-size:12px;color:#ea8010}\n.toc-article li ol, .toc-article li ul {\n    margin-left: 30px;\n}\n.toc-article ol, .toc-article ul {\n    margin: 10px 0;\n}\n```\n\n### 6.2 修改~/themes/yilia/layout/_partial/article.ejs文件\n\n在themes\\yilia\\layout\\_partial文件夹下article.ejs 文件中，在</header> <% } %>下面加入如下内容\n\n```js\n<!-- 目录内容 -->\n<% if (!index && post.toc){ %>\n    <p class=\"show-toc-btn\" id=\"show-toc-btn\" onclick=\"showToc();\" style=\"display:none\">\n          <span class=\"btn-bg\"></span>\n          <span class=\"btn-text\">文章导航</span>\n          </p>\n\t<div id=\"toc-article\" class=\"toc-article\">\n\t    <span id=\"toc-close\" class=\"toc-close\" title=\"隐藏导航\" onclick=\"showBtn();\">×</span>\n\t\t<strong class=\"toc-title\">文章目录</strong>\n           <%- toc(post.content) %>\n         </div>\n   <script type=\"text/javascript\">\n\tfunction showToc(){\n\t\tvar toc_article = document.getElementById(\"toc-article\");\n\t\tvar show_toc_btn = document.getElementById(\"show-toc-btn\");\n\t\ttoc_article.setAttribute(\"style\",\"display:block\");\n\t\tshow_toc_btn.setAttribute(\"style\",\"display:none\");\n\t\t};\n\tfunction showBtn(){\n\t\tvar toc_article = document.getElementById(\"toc-article\");\n\t\tvar show_toc_btn = document.getElementById(\"show-toc-btn\");\n\t\ttoc_article.setAttribute(\"style\",\"display:none\");\n\t\tshow_toc_btn.setAttribute(\"style\",\"display:block\");\n\t\t};\n   </script>\n      <% } %>\n<!-- 目录内容结束 -->\n```\n\n### 6.3 在文章开头设置toc：true\n\n```yaml\nlayout: '[layout]'\ntitle: VPS搭建个人博客/相册教程02_hexo静态博客配置\ndate: 2017-11-21 11:49:53\ntags:\n  - 教程\ntoc: true\n```\n\n\n\n## 7、添加访问统计功能(leanCloud)\n\n### 7.1 注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\n\n### 7.2 在yillia主题的_config.yml文件中添加如下配置\n\n```yaml\n# 添加浏览量\nleancloud_visitors:\n  enable: true\n  app_id: ************** // 填入获取AppID\n  app_key: ************** // 填入获取AppKey\n\n#添加一下js插件的 CDN地址\njs_cdn:\n  jquery: https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\n  av : //cdn1.lncld.net/static/js/2.5.0/av-min.js\n```\n\n### 7.3 修改主题下layout\\_parial/post目录下title.ejs文件，在后面添加显示阅读量的html代码\n\n```js\n<% if (theme.leancloud_visitors.enable){ %>\n  <a href=\"javascript:;\" class=\"archive-article-date\">\n      <i class=\"icon-smile icon\"></i> 阅读数:<span id=\"<%- url_for(post.path) %>\" class=\"pageViews\">0</span>次\n  </a>\n<% } %>\n```\n\n***PS: span 给的 id 是文章的 url 作为唯一的 key 值***\n\n### 7.4 修改主题下layout\\_parial目录下after.footer.ejs文件， 添加如下代码\n\n```js\n<script src=\"<%- theme.js_cdn.jquery %>\"></script>\n<% if (theme.leancloud_visitors.enable){ %>\n<%- partial('post/leancloud') %> \n<% } %>\n```\n\n***PS:这是自定一个js文件,放在 layout\\_parial\\post 目录 leancloud.ejs中***\n\n---\n\n***更多功能，未完待续。之后慢慢加上***。","source":"_posts/VPS_02_02.md","raw":"---\nlayout: '[layout]'\ntitle: VPS搭建个人博客/相册教程02_hexo静态博客配置\ndate: 2017-11-20 16:29:01\ncategories: \n- 教程\n- [教程, Hexo]\ntags: \n- 教程\n- hexo\n---\n\n\n> hexo是一个很牛皮的用于生成静态网页的博客框架，且对MarkDown语法支持的很好。比较酷的是，它还有很多主题和插件支持，目前使用最多最受程序员欢迎的一个静态博客框架。\n\n---\n\n本机环境：macOS10.12 、node：v9.2.0、npm： 5.5.1\n\n## 1、本地部署\n\n### 1.1 安装全局的hexo命令行工具\n```\nnpm install hexo-cli -g # -g表示全局安装\n```\n\n<!-- more -->\n\n### 1.2 安装deployer工具\n\n```\nnpm install hexo-deployer-git --save\n```\n\n### 1.3 创建blog目录，并初始化hexo项目\n\n```\nhexo init blog\n```\n\n### 1.4 安装npm依赖\n\n```\ncd blog && npm install\n```\n\n### 1.5. 启动本地服务\n\n```\nhexo server\n```\n\n### 1.6 在浏览器中输入http://localhost:4000打开本地页面\n\n![](http://ozpzewso9.bkt.clouddn.com/Snip20171220_9.png)\n\n## 2、文件结构\n\n打开hexo文件夹，查看文件目录。\n\n- _config.yml：重要的配置文件\n- themes：主题\n- public：存放的是生成的静态网页\n- source：博客文章目录\n- scaffolds：生成文章等的命令模板文件\n- db.json：source解析所得到的\n- node_modules：npm依赖包\n- package.json：项目所需模块项目的配置信息\n\n## 3、配置信息\n\n```\ndeploy:\n      type: git\n      message: update\n      repo:\n        s1: git@xx.xx.xx.xx:repo/hexo.git,master # git地址\n#######################################################################\n# 皮肤\ntheme: yilia\n\n# 1、网站\ntitle: Rui's Blog # 网站标题\nsubtitle: # 网站副标题\ndescription: # 网站描述(主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。)\nauthor: Rui # 您的名字\nlanguage: # 网站使用的语言\ntimezone: # 网站时区(Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC )\n################################################\n\n# 2、网址\nurl: //ruidada.info # 网址\nroot: / # 网站根目录\npermalink: :year/:month/:day/:title/ # 文章的 永久链接(:year/:month/:day/:title/）\npermalink_defaults: # 永久链接中各部分的默认值\n################################################\n\n# 3、目录\nsource_dir: source # 资源文件夹，这个文件夹用来存放内容。\npublic_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags # 标签文件夹\narchive_dir: archives # 归档文件夹\ncategory_dir: categories # 分类文件夹\ncode_dir: downloads/code # Include code 文件夹\ni18n_dir: :lang # 国际化（i18n）文件夹\nskip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n################################################\n\n# 4、文章\nnew_post_name: :title.md # 新文章的文件名称\ndefault_layout: post # 预设布局\ntitlecase: false # 把标题转换为 title case\nexternal_link: true # 在新标签中打开链接\nfilename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false # 显示草稿\npost_asset_folder: false # 启动 Asset 文件夹\nrelative_link: false # 把链接改为与根目录的相对位址\nfuture: true # 显示未来的文章\nhighlight: # 代码块的设置\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n# PS:默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。\n\n################################################\n\n# 5、分类&标签\ndefault_category: uncategorized # 默认分类\ncategory_map: # 分类别名\ntag_map: # 标签别名\n################################################\n\n# 6、日期/时间格式\ndate_format: YYYY-MM-DD # 日期格式\ntime_format: HH:mm:ss # 时间格式\n################################################\n\n# 7、分页\nper_page: 5 # 每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page # 分页目录\n################################################\n```\n\n\n\n## 4、相关命令介绍\n\n### 4.1 新建文章\n\n```\nhexo new \"postName\" # 会在source/_posts目录下生成一个postName.md文件。该文件会被显示在页面上，连接可以访问。\n```\n\n### 4.2 新建草稿\n\n```\nhexo new draft \"new draft\" # 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。\n```\n\n### 4.3 预览草稿\n\n```\n 1.hexo server --drafts\n 2.或者修改_config.yml文件将render_drafts设置为true\n```\n\n### 4.4 将草稿添加到发布中\n\n```\nhexo publish [layout] <filename>\n```\n\n### 4.5 新建页面\n\n```\nhexo new page \"pageName\"\n```\n\n### 4.6 清除\n\n```\nhexo clean # 删除public文件夹\n```\n\n### 4.7 开启预览访问端口\n\n```\nhexo server\n```\n\n### 4.8 生成静态页面\n\n```\nhexo generate # 该命令会在主目录的public文件夹中生成静态页面\n```\n\n### 4.9 将静态页面部署到远程服务器上\n\n```\nhexo deploy\n```\n\n\n\n## 5、修改主题\n\nhexo默认主题是landscape。我这里选择使用[yilia](https://github.com/litten/hexo-theme-yilia)主题，主要是个人觉得yilia比较简洁大方还比较酷，且完美适配了移动设备。\n\n### 5.1 下载主题包到themes文件夹中\n\n```\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n### 5.2 修改hexo根目录下的 _config.yml文件 ,设置theme: yilia\n\n```\ntheme: yilia\n```\n\n\n\n## 6、添加文章目录功能\n\n### 6.1 修改~/themes/yilia/source/main.0cf68a.css文件\n\n在themes\\yilia\\source文件夹下的main.xxxx.css文件中，末尾添加如下代码：\n\n```css\n/* 新添加的 */\n#container .show-toc-btn,#container .toc-article{display:block}\n.toc-article{z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px}.toc-article .toc-close{font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc}.toc-article .toc-close:hover{color:#000}.toc-article .toc{font-size:12px;padding:0;line-height:20px}.toc-article .toc .toc-number{color:#333}.toc-article .toc .toc-text:hover{text-decoration:underline;color:#2a6496}.toc-article li{list-style-type:none}.toc-article .toc-level-1{margin:4px 0}.toc-article .toc-child{}@-moz-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-webkit-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@-o-keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}@keyframes cd-bounce-1{0%{opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}60%{opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)}100%{-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}}.show-toc-btn{display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9}.show-toc-btn .btn-bg{margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%}.show-toc-btn .btn-text{color:#999;font-size:12px}.show-toc-btn:hover{cursor:pointer}.show-toc-btn:hover .btn-bg{background-position:0 -16px}.show-toc-btn:hover .btn-text{font-size:12px;color:#ea8010}\n.toc-article li ol, .toc-article li ul {\n    margin-left: 30px;\n}\n.toc-article ol, .toc-article ul {\n    margin: 10px 0;\n}\n```\n\n### 6.2 修改~/themes/yilia/layout/_partial/article.ejs文件\n\n在themes\\yilia\\layout\\_partial文件夹下article.ejs 文件中，在</header> <% } %>下面加入如下内容\n\n```js\n<!-- 目录内容 -->\n<% if (!index && post.toc){ %>\n    <p class=\"show-toc-btn\" id=\"show-toc-btn\" onclick=\"showToc();\" style=\"display:none\">\n          <span class=\"btn-bg\"></span>\n          <span class=\"btn-text\">文章导航</span>\n          </p>\n\t<div id=\"toc-article\" class=\"toc-article\">\n\t    <span id=\"toc-close\" class=\"toc-close\" title=\"隐藏导航\" onclick=\"showBtn();\">×</span>\n\t\t<strong class=\"toc-title\">文章目录</strong>\n           <%- toc(post.content) %>\n         </div>\n   <script type=\"text/javascript\">\n\tfunction showToc(){\n\t\tvar toc_article = document.getElementById(\"toc-article\");\n\t\tvar show_toc_btn = document.getElementById(\"show-toc-btn\");\n\t\ttoc_article.setAttribute(\"style\",\"display:block\");\n\t\tshow_toc_btn.setAttribute(\"style\",\"display:none\");\n\t\t};\n\tfunction showBtn(){\n\t\tvar toc_article = document.getElementById(\"toc-article\");\n\t\tvar show_toc_btn = document.getElementById(\"show-toc-btn\");\n\t\ttoc_article.setAttribute(\"style\",\"display:none\");\n\t\tshow_toc_btn.setAttribute(\"style\",\"display:block\");\n\t\t};\n   </script>\n      <% } %>\n<!-- 目录内容结束 -->\n```\n\n### 6.3 在文章开头设置toc：true\n\n```yaml\nlayout: '[layout]'\ntitle: VPS搭建个人博客/相册教程02_hexo静态博客配置\ndate: 2017-11-21 11:49:53\ntags:\n  - 教程\ntoc: true\n```\n\n\n\n## 7、添加访问统计功能(leanCloud)\n\n### 7.1 注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\n\n### 7.2 在yillia主题的_config.yml文件中添加如下配置\n\n```yaml\n# 添加浏览量\nleancloud_visitors:\n  enable: true\n  app_id: ************** // 填入获取AppID\n  app_key: ************** // 填入获取AppKey\n\n#添加一下js插件的 CDN地址\njs_cdn:\n  jquery: https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\n  av : //cdn1.lncld.net/static/js/2.5.0/av-min.js\n```\n\n### 7.3 修改主题下layout\\_parial/post目录下title.ejs文件，在后面添加显示阅读量的html代码\n\n```js\n<% if (theme.leancloud_visitors.enable){ %>\n  <a href=\"javascript:;\" class=\"archive-article-date\">\n      <i class=\"icon-smile icon\"></i> 阅读数:<span id=\"<%- url_for(post.path) %>\" class=\"pageViews\">0</span>次\n  </a>\n<% } %>\n```\n\n***PS: span 给的 id 是文章的 url 作为唯一的 key 值***\n\n### 7.4 修改主题下layout\\_parial目录下after.footer.ejs文件， 添加如下代码\n\n```js\n<script src=\"<%- theme.js_cdn.jquery %>\"></script>\n<% if (theme.leancloud_visitors.enable){ %>\n<%- partial('post/leancloud') %> \n<% } %>\n```\n\n***PS:这是自定一个js文件,放在 layout\\_parial\\post 目录 leancloud.ejs中***\n\n---\n\n***更多功能，未完待续。之后慢慢加上***。","slug":"VPS_02_02","published":1,"updated":"2019-12-20T06:08:22.049Z","comments":1,"photos":[],"link":"","_id":"ck4dsux30000dodnqyl9tioc7","content":"<blockquote>\n<p>hexo是一个很牛皮的用于生成静态网页的博客框架，且对MarkDown语法支持的很好。比较酷的是，它还有很多主题和插件支持，目前使用最多最受程序员欢迎的一个静态博客框架。</p>\n</blockquote>\n<hr>\n<p>本机环境：macOS10.12 、node：v9.2.0、npm： 5.5.1</p>\n<h2 id=\"1、本地部署\"><a href=\"#1、本地部署\" class=\"headerlink\" title=\"1、本地部署\"></a>1、本地部署</h2><h3 id=\"1-1-安装全局的hexo命令行工具\"><a href=\"#1-1-安装全局的hexo命令行工具\" class=\"headerlink\" title=\"1.1 安装全局的hexo命令行工具\"></a>1.1 安装全局的hexo命令行工具</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g # -g表示全局安装</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"1-2-安装deployer工具\"><a href=\"#1-2-安装deployer工具\" class=\"headerlink\" title=\"1.2 安装deployer工具\"></a>1.2 安装deployer工具</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-创建blog目录，并初始化hexo项目\"><a href=\"#1-3-创建blog目录，并初始化hexo项目\" class=\"headerlink\" title=\"1.3 创建blog目录，并初始化hexo项目\"></a>1.3 创建blog目录，并初始化hexo项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-安装npm依赖\"><a href=\"#1-4-安装npm依赖\" class=\"headerlink\" title=\"1.4 安装npm依赖\"></a>1.4 安装npm依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd blog &amp;&amp; npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-5-启动本地服务\"><a href=\"#1-5-启动本地服务\" class=\"headerlink\" title=\"1.5. 启动本地服务\"></a>1.5. 启动本地服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-6-在浏览器中输入http-localhost-4000打开本地页面\"><a href=\"#1-6-在浏览器中输入http-localhost-4000打开本地页面\" class=\"headerlink\" title=\"1.6 在浏览器中输入http://localhost:4000打开本地页面\"></a>1.6 在浏览器中输入<a href=\"http://localhost:4000打开本地页面\" target=\"_blank\" rel=\"noopener\">http://localhost:4000打开本地页面</a></h3><p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171220_9.png\" alt=\"\"></p>\n<h2 id=\"2、文件结构\"><a href=\"#2、文件结构\" class=\"headerlink\" title=\"2、文件结构\"></a>2、文件结构</h2><p>打开hexo文件夹，查看文件目录。</p>\n<ul>\n<li>_config.yml：重要的配置文件</li>\n<li>themes：主题</li>\n<li>public：存放的是生成的静态网页</li>\n<li>source：博客文章目录</li>\n<li>scaffolds：生成文章等的命令模板文件</li>\n<li>db.json：source解析所得到的</li>\n<li>node_modules：npm依赖包</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n<h2 id=\"3、配置信息\"><a href=\"#3、配置信息\" class=\"headerlink\" title=\"3、配置信息\"></a>3、配置信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">      type: git</span><br><span class=\"line\">      message: update</span><br><span class=\"line\">      repo:</span><br><span class=\"line\">        s1: git@xx.xx.xx.xx:repo/hexo.git,master # git地址</span><br><span class=\"line\">#######################################################################</span><br><span class=\"line\"># 皮肤</span><br><span class=\"line\">theme: yilia</span><br><span class=\"line\"></span><br><span class=\"line\"># 1、网站</span><br><span class=\"line\">title: Rui&apos;s Blog # 网站标题</span><br><span class=\"line\">subtitle: # 网站副标题</span><br><span class=\"line\">description: # 网站描述(主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。)</span><br><span class=\"line\">author: Rui # 您的名字</span><br><span class=\"line\">language: # 网站使用的语言</span><br><span class=\"line\">timezone: # 网站时区(Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC )</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 2、网址</span><br><span class=\"line\">url: //ruidada.info # 网址</span><br><span class=\"line\">root: / # 网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/ # 文章的 永久链接(:year/:month/:day/:title/）</span><br><span class=\"line\">permalink_defaults: # 永久链接中各部分的默认值</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 3、目录</span><br><span class=\"line\">source_dir: source # 资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags # 标签文件夹</span><br><span class=\"line\">archive_dir: archives # 归档文件夹</span><br><span class=\"line\">category_dir: categories # 分类文件夹</span><br><span class=\"line\">code_dir: downloads/code # Include code 文件夹</span><br><span class=\"line\">i18n_dir: :lang # 国际化（i18n）文件夹</span><br><span class=\"line\">skip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 4、文章</span><br><span class=\"line\">new_post_name: :title.md # 新文章的文件名称</span><br><span class=\"line\">default_layout: post # 预设布局</span><br><span class=\"line\">titlecase: false # 把标题转换为 title case</span><br><span class=\"line\">external_link: true # 在新标签中打开链接</span><br><span class=\"line\">filename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false # 显示草稿</span><br><span class=\"line\">post_asset_folder: false # 启动 Asset 文件夹</span><br><span class=\"line\">relative_link: false # 把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true # 显示未来的文章</span><br><span class=\"line\">highlight: # 代码块的设置</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  auto_detect: false</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"># PS:默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</span><br><span class=\"line\"></span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 5、分类&amp;标签</span><br><span class=\"line\">default_category: uncategorized # 默认分类</span><br><span class=\"line\">category_map: # 分类别名</span><br><span class=\"line\">tag_map: # 标签别名</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 6、日期/时间格式</span><br><span class=\"line\">date_format: YYYY-MM-DD # 日期格式</span><br><span class=\"line\">time_format: HH:mm:ss # 时间格式</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 7、分页</span><br><span class=\"line\">per_page: 5 # 每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page # 分页目录</span><br><span class=\"line\">################################################</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、相关命令介绍\"><a href=\"#4、相关命令介绍\" class=\"headerlink\" title=\"4、相关命令介绍\"></a>4、相关命令介绍</h2><h3 id=\"4-1-新建文章\"><a href=\"#4-1-新建文章\" class=\"headerlink\" title=\"4.1 新建文章\"></a>4.1 新建文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; # 会在source/_posts目录下生成一个postName.md文件。该文件会被显示在页面上，连接可以访问。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-新建草稿\"><a href=\"#4-2-新建草稿\" class=\"headerlink\" title=\"4.2 新建草稿\"></a>4.2 新建草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new draft &quot;new draft&quot; # 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-预览草稿\"><a href=\"#4-3-预览草稿\" class=\"headerlink\" title=\"4.3 预览草稿\"></a>4.3 预览草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.hexo server --drafts</span><br><span class=\"line\">2.或者修改_config.yml文件将render_drafts设置为true</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-4-将草稿添加到发布中\"><a href=\"#4-4-将草稿添加到发布中\" class=\"headerlink\" title=\"4.4 将草稿添加到发布中\"></a>4.4 将草稿添加到发布中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-5-新建页面\"><a href=\"#4-5-新建页面\" class=\"headerlink\" title=\"4.5 新建页面\"></a>4.5 新建页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &quot;pageName&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-6-清除\"><a href=\"#4-6-清除\" class=\"headerlink\" title=\"4.6 清除\"></a>4.6 清除</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean # 删除public文件夹</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-7-开启预览访问端口\"><a href=\"#4-7-开启预览访问端口\" class=\"headerlink\" title=\"4.7 开启预览访问端口\"></a>4.7 开启预览访问端口</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-8-生成静态页面\"><a href=\"#4-8-生成静态页面\" class=\"headerlink\" title=\"4.8 生成静态页面\"></a>4.8 生成静态页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate # 该命令会在主目录的public文件夹中生成静态页面</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-9-将静态页面部署到远程服务器上\"><a href=\"#4-9-将静态页面部署到远程服务器上\" class=\"headerlink\" title=\"4.9 将静态页面部署到远程服务器上\"></a>4.9 将静态页面部署到远程服务器上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、修改主题\"><a href=\"#5、修改主题\" class=\"headerlink\" title=\"5、修改主题\"></a>5、修改主题</h2><p>hexo默认主题是landscape。我这里选择使用<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">yilia</a>主题，主要是个人觉得yilia比较简洁大方还比较酷，且完美适配了移动设备。</p>\n<h3 id=\"5-1-下载主题包到themes文件夹中\"><a href=\"#5-1-下载主题包到themes文件夹中\" class=\"headerlink\" title=\"5.1 下载主题包到themes文件夹中\"></a>5.1 下载主题包到themes文件夹中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-修改hexo根目录下的-config-yml文件-设置theme-yilia\"><a href=\"#5-2-修改hexo根目录下的-config-yml文件-设置theme-yilia\" class=\"headerlink\" title=\"5.2 修改hexo根目录下的 _config.yml文件 ,设置theme: yilia\"></a>5.2 修改hexo根目录下的 _config.yml文件 ,设置theme: yilia</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: yilia</span><br></pre></td></tr></table></figure>\n<h2 id=\"6、添加文章目录功能\"><a href=\"#6、添加文章目录功能\" class=\"headerlink\" title=\"6、添加文章目录功能\"></a>6、添加文章目录功能</h2><h3 id=\"6-1-修改-themes-yilia-source-main-0cf68a-css文件\"><a href=\"#6-1-修改-themes-yilia-source-main-0cf68a-css文件\" class=\"headerlink\" title=\"6.1 修改~/themes/yilia/source/main.0cf68a.css文件\"></a>6.1 修改~/themes/yilia/source/main.0cf68a.css文件</h3><p>在themes\\yilia\\source文件夹下的main.xxxx.css文件中，末尾添加如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 新添加的 */</span></span><br><span class=\"line\"><span class=\"selector-id\">#container</span> <span class=\"selector-class\">.show-toc-btn</span>,<span class=\"selector-id\">#container</span> <span class=\"selector-class\">.toc-article</span>&#123;<span class=\"attribute\">display</span>:block&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toc-article</span>&#123;<span class=\"attribute\">z-index</span>:<span class=\"number\">100</span>;<span class=\"attribute\">background</span>:<span class=\"number\">#fff</span>;<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;<span class=\"attribute\">max-width</span>:<span class=\"number\">250px</span>;<span class=\"attribute\">min-width</span>:<span class=\"number\">150px</span>;<span class=\"attribute\">max-height</span>:<span class=\"number\">500px</span>;<span class=\"attribute\">overflow-y</span>:auto;<span class=\"attribute\">-webkit-box-shadow</span>:<span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">2px</span> <span class=\"number\">#ccc</span>;<span class=\"attribute\">box-shadow</span>:<span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">2px</span> <span class=\"number\">#ccc</span>;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>;<span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;<span class=\"attribute\">position</span>:fixed;<span class=\"attribute\">right</span>:<span class=\"number\">35px</span>;<span class=\"attribute\">top</span>:<span class=\"number\">129px</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-close</span>&#123;<span class=\"attribute\">font-weight</span>:<span class=\"number\">700</span>;<span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;<span class=\"attribute\">cursor</span>:pointer;<span class=\"attribute\">float</span>:right;<span class=\"attribute\">color</span>:<span class=\"number\">#ccc</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-close</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc</span>&#123;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>;<span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;<span class=\"attribute\">line-height</span>:<span class=\"number\">20px</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc</span> <span class=\"selector-class\">.toc-number</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#333</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc</span> <span class=\"selector-class\">.toc-text</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">text-decoration</span>:underline;<span class=\"attribute\">color</span>:<span class=\"number\">#2a6496</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">li</span>&#123;<span class=\"attribute\">list-style-type</span>:none&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-level-1</span>&#123;<span class=\"attribute\">margin</span>:<span class=\"number\">4px</span> <span class=\"number\">0</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-child</span>&#123;&#125;@-<span class=\"keyword\">moz</span>-<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;@-<span class=\"keyword\">webkit</span>-<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;@-<span class=\"keyword\">o</span>-<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;@<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;<span class=\"selector-class\">.show-toc-btn</span>&#123;<span class=\"attribute\">display</span>:none;<span class=\"attribute\">z-index</span>:<span class=\"number\">10</span>;<span class=\"attribute\">width</span>:<span class=\"number\">30px</span>;<span class=\"attribute\">min-height</span>:<span class=\"number\">14px</span>;<span class=\"attribute\">overflow</span>:hidden;<span class=\"attribute\">padding</span>:<span class=\"number\">4px</span> <span class=\"number\">6px</span> <span class=\"number\">8px</span> <span class=\"number\">5px</span>;<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ddd</span>;<span class=\"attribute\">border-right</span>:none;<span class=\"attribute\">position</span>:fixed;<span class=\"attribute\">right</span>:<span class=\"number\">40px</span>;<span class=\"attribute\">text-align</span>:center;<span class=\"attribute\">background-color</span>:<span class=\"number\">#f9f9f9</span>&#125;<span class=\"selector-class\">.show-toc-btn</span> <span class=\"selector-class\">.btn-bg</span>&#123;<span class=\"attribute\">margin-top</span>:<span class=\"number\">2px</span>;<span class=\"attribute\">display</span>:block;<span class=\"attribute\">width</span>:<span class=\"number\">16px</span>;<span class=\"attribute\">height</span>:<span class=\"number\">14px</span>;<span class=\"attribute\">background</span>:<span class=\"built_in\">url</span>(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;<span class=\"attribute\">-webkit-background-size</span>:<span class=\"number\">100%</span>;<span class=\"attribute\">-moz-background-size</span>:<span class=\"number\">100%</span>;<span class=\"attribute\">background-size</span>:<span class=\"number\">100%</span>&#125;<span class=\"selector-class\">.show-toc-btn</span> <span class=\"selector-class\">.btn-text</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#999</span>;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>&#125;<span class=\"selector-class\">.show-toc-btn</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">cursor</span>:pointer&#125;<span class=\"selector-class\">.show-toc-btn</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.btn-bg</span>&#123;<span class=\"attribute\">background-position</span>:<span class=\"number\">0</span> -<span class=\"number\">16px</span>&#125;<span class=\"selector-class\">.show-toc-btn</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.btn-text</span>&#123;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>;<span class=\"attribute\">color</span>:<span class=\"number\">#ea8010</span>&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">ol</span>, <span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">ol</span>, <span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-修改-themes-yilia-layout-partial-article-ejs文件\"><a href=\"#6-2-修改-themes-yilia-layout-partial-article-ejs文件\" class=\"headerlink\" title=\"6.2 修改~/themes/yilia/layout/_partial/article.ejs文件\"></a>6.2 修改~/themes/yilia/layout/_partial/article.ejs文件</h3><p>在themes\\yilia\\layout_partial文件夹下article.ejs 文件中，在 &lt;% } %&gt;下面加入如下内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 目录内容 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class=\"line\">    &lt;p <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"show-toc-btn\"</span> id=<span class=\"string\">\"show-toc-btn\"</span> onclick=<span class=\"string\">\"showToc();\"</span> style=<span class=\"string\">\"display:none\"</span>&gt;</span><br><span class=\"line\">          &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"btn-bg\"</span>&gt;&lt;/span&gt;</span><br><span class=\"line\">          &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"btn-text\"</span>&gt;文章导航&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>p&gt;</span><br><span class=\"line\">\t&lt;div id=<span class=\"string\">\"toc-article\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"toc-article\"</span>&gt;</span><br><span class=\"line\">\t    &lt;span id=<span class=\"string\">\"toc-close\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"toc-close\"</span> title=<span class=\"string\">\"隐藏导航\"</span> onclick=<span class=\"string\">\"showBtn();\"</span>&gt;×&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;strong class=\"toc-title\"&gt;文章目录&lt;/</span>strong&gt;</span><br><span class=\"line\">           &lt;%- toc(post.content) %&gt;</span><br><span class=\"line\">         &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">   &lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">\tfunction showToc()&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar toc_article = document.getElementById(\"</span>toc-article<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar show_toc_btn = document.getElementById(\"</span>show-toc-btn<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\ttoc_article.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:block<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tshow_toc_btn.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:none<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"string\">\tfunction showBtn()&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar toc_article = document.getElementById(\"</span>toc-article<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar show_toc_btn = document.getElementById(\"</span>show-toc-btn<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\ttoc_article.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:none<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tshow_toc_btn.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:block<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"string\">   &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;% &#125; %&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!-- 目录内容结束 --&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-3-在文章开头设置toc：true\"><a href=\"#6-3-在文章开头设置toc：true\" class=\"headerlink\" title=\"6.3 在文章开头设置toc：true\"></a>6.3 在文章开头设置toc：true</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">layout:</span> <span class=\"string\">'[layout]'</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">VPS搭建个人博客/相册教程02_hexo静态博客配置</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2017</span><span class=\"bullet\">-11</span><span class=\"bullet\">-21</span> <span class=\"number\">11</span><span class=\"string\">:49:53</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">教程</span></span><br><span class=\"line\"><span class=\"attr\">toc:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7、添加访问统计功能-leanCloud\"><a href=\"#7、添加访问统计功能-leanCloud\" class=\"headerlink\" title=\"7、添加访问统计功能(leanCloud)\"></a>7、添加访问统计功能(leanCloud)</h2><h3 id=\"7-1-注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\"><a href=\"#7-1-注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\" class=\"headerlink\" title=\"7.1 注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\"></a>7.1 注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。</h3><h3 id=\"7-2-在yillia主题的-config-yml文件中添加如下配置\"><a href=\"#7-2-在yillia主题的-config-yml文件中添加如下配置\" class=\"headerlink\" title=\"7.2 在yillia主题的_config.yml文件中添加如下配置\"></a>7.2 在yillia主题的_config.yml文件中添加如下配置</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加浏览量</span></span><br><span class=\"line\"><span class=\"attr\">leancloud_visitors:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">**************</span> <span class=\"string\">//</span> <span class=\"string\">填入获取AppID</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">**************</span> <span class=\"string\">//</span> <span class=\"string\">填入获取AppKey</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#添加一下js插件的 CDN地址</span></span><br><span class=\"line\"><span class=\"attr\">js_cdn:</span></span><br><span class=\"line\"><span class=\"attr\">  jquery:</span> <span class=\"attr\">https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js</span></span><br><span class=\"line\">  <span class=\"string\">av</span> <span class=\"string\">:</span> <span class=\"string\">//cdn1.lncld.net/static/js/2.5.0/av-min.js</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-3-修改主题下layout-parial-post目录下title-ejs文件，在后面添加显示阅读量的html代码\"><a href=\"#7-3-修改主题下layout-parial-post目录下title-ejs文件，在后面添加显示阅读量的html代码\" class=\"headerlink\" title=\"7.3 修改主题下layout_parial/post目录下title.ejs文件，在后面添加显示阅读量的html代码\"></a>7.3 修改主题下layout_parial/post目录下title.ejs文件，在后面添加显示阅读量的html代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (theme.leancloud_visitors.enable)&#123; %&gt;</span><br><span class=\"line\">  &lt;a href=<span class=\"string\">\"javascript:;\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"archive-article-date\"</span>&gt;</span><br><span class=\"line\">      &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"icon-smile icon\"</span>&gt;&lt;/i&gt; 阅读数:&lt;span id=\"&lt;%- url_for(post.path) %&gt;\" class=\"pageViews\"&gt;0&lt;/span&gt;次</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong><em>PS: span 给的 id 是文章的 url 作为唯一的 key 值</em></strong></p>\n<h3 id=\"7-4-修改主题下layout-parial目录下after-footer-ejs文件，-添加如下代码\"><a href=\"#7-4-修改主题下layout-parial目录下after-footer-ejs文件，-添加如下代码\" class=\"headerlink\" title=\"7.4 修改主题下layout_parial目录下after.footer.ejs文件， 添加如下代码\"></a>7.4 修改主题下layout_parial目录下after.footer.ejs文件， 添加如下代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"&lt;%- theme.js_cdn.jquery %&gt;\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (theme.leancloud_visitors.enable)&#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'post/leancloud'</span>) %&gt; </span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p><strong><em>PS:这是自定一个js文件,放在 layout_parial\\post 目录 leancloud.ejs中</em></strong></p>\n<hr>\n<p><strong><em>更多功能，未完待续。之后慢慢加上</em></strong>。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>hexo是一个很牛皮的用于生成静态网页的博客框架，且对MarkDown语法支持的很好。比较酷的是，它还有很多主题和插件支持，目前使用最多最受程序员欢迎的一个静态博客框架。</p>\n</blockquote>\n<hr>\n<p>本机环境：macOS10.12 、node：v9.2.0、npm： 5.5.1</p>\n<h2 id=\"1、本地部署\"><a href=\"#1、本地部署\" class=\"headerlink\" title=\"1、本地部署\"></a>1、本地部署</h2><h3 id=\"1-1-安装全局的hexo命令行工具\"><a href=\"#1-1-安装全局的hexo命令行工具\" class=\"headerlink\" title=\"1.1 安装全局的hexo命令行工具\"></a>1.1 安装全局的hexo命令行工具</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g # -g表示全局安装</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"1-2-安装deployer工具\"><a href=\"#1-2-安装deployer工具\" class=\"headerlink\" title=\"1.2 安装deployer工具\"></a>1.2 安装deployer工具</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-创建blog目录，并初始化hexo项目\"><a href=\"#1-3-创建blog目录，并初始化hexo项目\" class=\"headerlink\" title=\"1.3 创建blog目录，并初始化hexo项目\"></a>1.3 创建blog目录，并初始化hexo项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-安装npm依赖\"><a href=\"#1-4-安装npm依赖\" class=\"headerlink\" title=\"1.4 安装npm依赖\"></a>1.4 安装npm依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd blog &amp;&amp; npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-5-启动本地服务\"><a href=\"#1-5-启动本地服务\" class=\"headerlink\" title=\"1.5. 启动本地服务\"></a>1.5. 启动本地服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-6-在浏览器中输入http-localhost-4000打开本地页面\"><a href=\"#1-6-在浏览器中输入http-localhost-4000打开本地页面\" class=\"headerlink\" title=\"1.6 在浏览器中输入http://localhost:4000打开本地页面\"></a>1.6 在浏览器中输入<a href=\"http://localhost:4000打开本地页面\" target=\"_blank\" rel=\"noopener\">http://localhost:4000打开本地页面</a></h3><p><img src=\"http://ozpzewso9.bkt.clouddn.com/Snip20171220_9.png\" alt=\"\"></p>\n<h2 id=\"2、文件结构\"><a href=\"#2、文件结构\" class=\"headerlink\" title=\"2、文件结构\"></a>2、文件结构</h2><p>打开hexo文件夹，查看文件目录。</p>\n<ul>\n<li>_config.yml：重要的配置文件</li>\n<li>themes：主题</li>\n<li>public：存放的是生成的静态网页</li>\n<li>source：博客文章目录</li>\n<li>scaffolds：生成文章等的命令模板文件</li>\n<li>db.json：source解析所得到的</li>\n<li>node_modules：npm依赖包</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n<h2 id=\"3、配置信息\"><a href=\"#3、配置信息\" class=\"headerlink\" title=\"3、配置信息\"></a>3、配置信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">      type: git</span><br><span class=\"line\">      message: update</span><br><span class=\"line\">      repo:</span><br><span class=\"line\">        s1: git@xx.xx.xx.xx:repo/hexo.git,master # git地址</span><br><span class=\"line\">#######################################################################</span><br><span class=\"line\"># 皮肤</span><br><span class=\"line\">theme: yilia</span><br><span class=\"line\"></span><br><span class=\"line\"># 1、网站</span><br><span class=\"line\">title: Rui&apos;s Blog # 网站标题</span><br><span class=\"line\">subtitle: # 网站副标题</span><br><span class=\"line\">description: # 网站描述(主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。)</span><br><span class=\"line\">author: Rui # 您的名字</span><br><span class=\"line\">language: # 网站使用的语言</span><br><span class=\"line\">timezone: # 网站时区(Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC )</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 2、网址</span><br><span class=\"line\">url: //ruidada.info # 网址</span><br><span class=\"line\">root: / # 网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/ # 文章的 永久链接(:year/:month/:day/:title/）</span><br><span class=\"line\">permalink_defaults: # 永久链接中各部分的默认值</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 3、目录</span><br><span class=\"line\">source_dir: source # 资源文件夹，这个文件夹用来存放内容。</span><br><span class=\"line\">public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class=\"line\">tag_dir: tags # 标签文件夹</span><br><span class=\"line\">archive_dir: archives # 归档文件夹</span><br><span class=\"line\">category_dir: categories # 分类文件夹</span><br><span class=\"line\">code_dir: downloads/code # Include code 文件夹</span><br><span class=\"line\">i18n_dir: :lang # 国际化（i18n）文件夹</span><br><span class=\"line\">skip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 4、文章</span><br><span class=\"line\">new_post_name: :title.md # 新文章的文件名称</span><br><span class=\"line\">default_layout: post # 预设布局</span><br><span class=\"line\">titlecase: false # 把标题转换为 title case</span><br><span class=\"line\">external_link: true # 在新标签中打开链接</span><br><span class=\"line\">filename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false # 显示草稿</span><br><span class=\"line\">post_asset_folder: false # 启动 Asset 文件夹</span><br><span class=\"line\">relative_link: false # 把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true # 显示未来的文章</span><br><span class=\"line\">highlight: # 代码块的设置</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  auto_detect: false</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"># PS:默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</span><br><span class=\"line\"></span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 5、分类&amp;标签</span><br><span class=\"line\">default_category: uncategorized # 默认分类</span><br><span class=\"line\">category_map: # 分类别名</span><br><span class=\"line\">tag_map: # 标签别名</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 6、日期/时间格式</span><br><span class=\"line\">date_format: YYYY-MM-DD # 日期格式</span><br><span class=\"line\">time_format: HH:mm:ss # 时间格式</span><br><span class=\"line\">################################################</span><br><span class=\"line\"></span><br><span class=\"line\"># 7、分页</span><br><span class=\"line\">per_page: 5 # 每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page # 分页目录</span><br><span class=\"line\">################################################</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、相关命令介绍\"><a href=\"#4、相关命令介绍\" class=\"headerlink\" title=\"4、相关命令介绍\"></a>4、相关命令介绍</h2><h3 id=\"4-1-新建文章\"><a href=\"#4-1-新建文章\" class=\"headerlink\" title=\"4.1 新建文章\"></a>4.1 新建文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; # 会在source/_posts目录下生成一个postName.md文件。该文件会被显示在页面上，连接可以访问。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-新建草稿\"><a href=\"#4-2-新建草稿\" class=\"headerlink\" title=\"4.2 新建草稿\"></a>4.2 新建草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new draft &quot;new draft&quot; # 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-预览草稿\"><a href=\"#4-3-预览草稿\" class=\"headerlink\" title=\"4.3 预览草稿\"></a>4.3 预览草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.hexo server --drafts</span><br><span class=\"line\">2.或者修改_config.yml文件将render_drafts设置为true</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-4-将草稿添加到发布中\"><a href=\"#4-4-将草稿添加到发布中\" class=\"headerlink\" title=\"4.4 将草稿添加到发布中\"></a>4.4 将草稿添加到发布中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-5-新建页面\"><a href=\"#4-5-新建页面\" class=\"headerlink\" title=\"4.5 新建页面\"></a>4.5 新建页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &quot;pageName&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-6-清除\"><a href=\"#4-6-清除\" class=\"headerlink\" title=\"4.6 清除\"></a>4.6 清除</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean # 删除public文件夹</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-7-开启预览访问端口\"><a href=\"#4-7-开启预览访问端口\" class=\"headerlink\" title=\"4.7 开启预览访问端口\"></a>4.7 开启预览访问端口</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-8-生成静态页面\"><a href=\"#4-8-生成静态页面\" class=\"headerlink\" title=\"4.8 生成静态页面\"></a>4.8 生成静态页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate # 该命令会在主目录的public文件夹中生成静态页面</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-9-将静态页面部署到远程服务器上\"><a href=\"#4-9-将静态页面部署到远程服务器上\" class=\"headerlink\" title=\"4.9 将静态页面部署到远程服务器上\"></a>4.9 将静态页面部署到远程服务器上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、修改主题\"><a href=\"#5、修改主题\" class=\"headerlink\" title=\"5、修改主题\"></a>5、修改主题</h2><p>hexo默认主题是landscape。我这里选择使用<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">yilia</a>主题，主要是个人觉得yilia比较简洁大方还比较酷，且完美适配了移动设备。</p>\n<h3 id=\"5-1-下载主题包到themes文件夹中\"><a href=\"#5-1-下载主题包到themes文件夹中\" class=\"headerlink\" title=\"5.1 下载主题包到themes文件夹中\"></a>5.1 下载主题包到themes文件夹中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-修改hexo根目录下的-config-yml文件-设置theme-yilia\"><a href=\"#5-2-修改hexo根目录下的-config-yml文件-设置theme-yilia\" class=\"headerlink\" title=\"5.2 修改hexo根目录下的 _config.yml文件 ,设置theme: yilia\"></a>5.2 修改hexo根目录下的 _config.yml文件 ,设置theme: yilia</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: yilia</span><br></pre></td></tr></table></figure>\n<h2 id=\"6、添加文章目录功能\"><a href=\"#6、添加文章目录功能\" class=\"headerlink\" title=\"6、添加文章目录功能\"></a>6、添加文章目录功能</h2><h3 id=\"6-1-修改-themes-yilia-source-main-0cf68a-css文件\"><a href=\"#6-1-修改-themes-yilia-source-main-0cf68a-css文件\" class=\"headerlink\" title=\"6.1 修改~/themes/yilia/source/main.0cf68a.css文件\"></a>6.1 修改~/themes/yilia/source/main.0cf68a.css文件</h3><p>在themes\\yilia\\source文件夹下的main.xxxx.css文件中，末尾添加如下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 新添加的 */</span></span><br><span class=\"line\"><span class=\"selector-id\">#container</span> <span class=\"selector-class\">.show-toc-btn</span>,<span class=\"selector-id\">#container</span> <span class=\"selector-class\">.toc-article</span>&#123;<span class=\"attribute\">display</span>:block&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toc-article</span>&#123;<span class=\"attribute\">z-index</span>:<span class=\"number\">100</span>;<span class=\"attribute\">background</span>:<span class=\"number\">#fff</span>;<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;<span class=\"attribute\">max-width</span>:<span class=\"number\">250px</span>;<span class=\"attribute\">min-width</span>:<span class=\"number\">150px</span>;<span class=\"attribute\">max-height</span>:<span class=\"number\">500px</span>;<span class=\"attribute\">overflow-y</span>:auto;<span class=\"attribute\">-webkit-box-shadow</span>:<span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">2px</span> <span class=\"number\">#ccc</span>;<span class=\"attribute\">box-shadow</span>:<span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">2px</span> <span class=\"number\">#ccc</span>;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>;<span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;<span class=\"attribute\">position</span>:fixed;<span class=\"attribute\">right</span>:<span class=\"number\">35px</span>;<span class=\"attribute\">top</span>:<span class=\"number\">129px</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-close</span>&#123;<span class=\"attribute\">font-weight</span>:<span class=\"number\">700</span>;<span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;<span class=\"attribute\">cursor</span>:pointer;<span class=\"attribute\">float</span>:right;<span class=\"attribute\">color</span>:<span class=\"number\">#ccc</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-close</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#000</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc</span>&#123;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>;<span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;<span class=\"attribute\">line-height</span>:<span class=\"number\">20px</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc</span> <span class=\"selector-class\">.toc-number</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#333</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc</span> <span class=\"selector-class\">.toc-text</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">text-decoration</span>:underline;<span class=\"attribute\">color</span>:<span class=\"number\">#2a6496</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">li</span>&#123;<span class=\"attribute\">list-style-type</span>:none&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-level-1</span>&#123;<span class=\"attribute\">margin</span>:<span class=\"number\">4px</span> <span class=\"number\">0</span>&#125;<span class=\"selector-class\">.toc-article</span> <span class=\"selector-class\">.toc-child</span>&#123;&#125;@-<span class=\"keyword\">moz</span>-<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;@-<span class=\"keyword\">webkit</span>-<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;@-<span class=\"keyword\">o</span>-<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;@<span class=\"keyword\">keyframes</span> cd-bounce-<span class=\"number\">1</span>&#123;0%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;60%&#123;<span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1.01);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1.01)&#125;100%&#123;<span class=\"attribute\">-o-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">-ms-transform</span>:<span class=\"built_in\">scale</span>(1);<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(1)&#125;&#125;<span class=\"selector-class\">.show-toc-btn</span>&#123;<span class=\"attribute\">display</span>:none;<span class=\"attribute\">z-index</span>:<span class=\"number\">10</span>;<span class=\"attribute\">width</span>:<span class=\"number\">30px</span>;<span class=\"attribute\">min-height</span>:<span class=\"number\">14px</span>;<span class=\"attribute\">overflow</span>:hidden;<span class=\"attribute\">padding</span>:<span class=\"number\">4px</span> <span class=\"number\">6px</span> <span class=\"number\">8px</span> <span class=\"number\">5px</span>;<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ddd</span>;<span class=\"attribute\">border-right</span>:none;<span class=\"attribute\">position</span>:fixed;<span class=\"attribute\">right</span>:<span class=\"number\">40px</span>;<span class=\"attribute\">text-align</span>:center;<span class=\"attribute\">background-color</span>:<span class=\"number\">#f9f9f9</span>&#125;<span class=\"selector-class\">.show-toc-btn</span> <span class=\"selector-class\">.btn-bg</span>&#123;<span class=\"attribute\">margin-top</span>:<span class=\"number\">2px</span>;<span class=\"attribute\">display</span>:block;<span class=\"attribute\">width</span>:<span class=\"number\">16px</span>;<span class=\"attribute\">height</span>:<span class=\"number\">14px</span>;<span class=\"attribute\">background</span>:<span class=\"built_in\">url</span>(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;<span class=\"attribute\">-webkit-background-size</span>:<span class=\"number\">100%</span>;<span class=\"attribute\">-moz-background-size</span>:<span class=\"number\">100%</span>;<span class=\"attribute\">background-size</span>:<span class=\"number\">100%</span>&#125;<span class=\"selector-class\">.show-toc-btn</span> <span class=\"selector-class\">.btn-text</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#999</span>;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>&#125;<span class=\"selector-class\">.show-toc-btn</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">cursor</span>:pointer&#125;<span class=\"selector-class\">.show-toc-btn</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.btn-bg</span>&#123;<span class=\"attribute\">background-position</span>:<span class=\"number\">0</span> -<span class=\"number\">16px</span>&#125;<span class=\"selector-class\">.show-toc-btn</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.btn-text</span>&#123;<span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>;<span class=\"attribute\">color</span>:<span class=\"number\">#ea8010</span>&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">ol</span>, <span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">ol</span>, <span class=\"selector-class\">.toc-article</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-修改-themes-yilia-layout-partial-article-ejs文件\"><a href=\"#6-2-修改-themes-yilia-layout-partial-article-ejs文件\" class=\"headerlink\" title=\"6.2 修改~/themes/yilia/layout/_partial/article.ejs文件\"></a>6.2 修改~/themes/yilia/layout/_partial/article.ejs文件</h3><p>在themes\\yilia\\layout_partial文件夹下article.ejs 文件中，在 &lt;% } %&gt;下面加入如下内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 目录内容 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class=\"line\">    &lt;p <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"show-toc-btn\"</span> id=<span class=\"string\">\"show-toc-btn\"</span> onclick=<span class=\"string\">\"showToc();\"</span> style=<span class=\"string\">\"display:none\"</span>&gt;</span><br><span class=\"line\">          &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"btn-bg\"</span>&gt;&lt;/span&gt;</span><br><span class=\"line\">          &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"btn-text\"</span>&gt;文章导航&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>p&gt;</span><br><span class=\"line\">\t&lt;div id=<span class=\"string\">\"toc-article\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"toc-article\"</span>&gt;</span><br><span class=\"line\">\t    &lt;span id=<span class=\"string\">\"toc-close\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"toc-close\"</span> title=<span class=\"string\">\"隐藏导航\"</span> onclick=<span class=\"string\">\"showBtn();\"</span>&gt;×&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;strong class=\"toc-title\"&gt;文章目录&lt;/</span>strong&gt;</span><br><span class=\"line\">           &lt;%- toc(post.content) %&gt;</span><br><span class=\"line\">         &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">   &lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">\tfunction showToc()&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar toc_article = document.getElementById(\"</span>toc-article<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar show_toc_btn = document.getElementById(\"</span>show-toc-btn<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\ttoc_article.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:block<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tshow_toc_btn.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:none<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"string\">\tfunction showBtn()&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar toc_article = document.getElementById(\"</span>toc-article<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tvar show_toc_btn = document.getElementById(\"</span>show-toc-btn<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\ttoc_article.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:none<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\tshow_toc_btn.setAttribute(\"</span>style<span class=\"string\">\",\"</span>display:block<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"string\">   &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;% &#125; %&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!-- 目录内容结束 --&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-3-在文章开头设置toc：true\"><a href=\"#6-3-在文章开头设置toc：true\" class=\"headerlink\" title=\"6.3 在文章开头设置toc：true\"></a>6.3 在文章开头设置toc：true</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">layout:</span> <span class=\"string\">'[layout]'</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">VPS搭建个人博客/相册教程02_hexo静态博客配置</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2017</span><span class=\"bullet\">-11</span><span class=\"bullet\">-21</span> <span class=\"number\">11</span><span class=\"string\">:49:53</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">教程</span></span><br><span class=\"line\"><span class=\"attr\">toc:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7、添加访问统计功能-leanCloud\"><a href=\"#7、添加访问统计功能-leanCloud\" class=\"headerlink\" title=\"7、添加访问统计功能(leanCloud)\"></a>7、添加访问统计功能(leanCloud)</h2><h3 id=\"7-1-注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\"><a href=\"#7-1-注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\" class=\"headerlink\" title=\"7.1 注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。\"></a>7.1 注册leanCloud，创建一个应用，新建一个class标识计数，获取AppID和AppKey。</h3><h3 id=\"7-2-在yillia主题的-config-yml文件中添加如下配置\"><a href=\"#7-2-在yillia主题的-config-yml文件中添加如下配置\" class=\"headerlink\" title=\"7.2 在yillia主题的_config.yml文件中添加如下配置\"></a>7.2 在yillia主题的_config.yml文件中添加如下配置</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加浏览量</span></span><br><span class=\"line\"><span class=\"attr\">leancloud_visitors:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">**************</span> <span class=\"string\">//</span> <span class=\"string\">填入获取AppID</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">**************</span> <span class=\"string\">//</span> <span class=\"string\">填入获取AppKey</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#添加一下js插件的 CDN地址</span></span><br><span class=\"line\"><span class=\"attr\">js_cdn:</span></span><br><span class=\"line\"><span class=\"attr\">  jquery:</span> <span class=\"attr\">https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js</span></span><br><span class=\"line\">  <span class=\"string\">av</span> <span class=\"string\">:</span> <span class=\"string\">//cdn1.lncld.net/static/js/2.5.0/av-min.js</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-3-修改主题下layout-parial-post目录下title-ejs文件，在后面添加显示阅读量的html代码\"><a href=\"#7-3-修改主题下layout-parial-post目录下title-ejs文件，在后面添加显示阅读量的html代码\" class=\"headerlink\" title=\"7.3 修改主题下layout_parial/post目录下title.ejs文件，在后面添加显示阅读量的html代码\"></a>7.3 修改主题下layout_parial/post目录下title.ejs文件，在后面添加显示阅读量的html代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (theme.leancloud_visitors.enable)&#123; %&gt;</span><br><span class=\"line\">  &lt;a href=<span class=\"string\">\"javascript:;\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"archive-article-date\"</span>&gt;</span><br><span class=\"line\">      &lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"icon-smile icon\"</span>&gt;&lt;/i&gt; 阅读数:&lt;span id=\"&lt;%- url_for(post.path) %&gt;\" class=\"pageViews\"&gt;0&lt;/span&gt;次</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong><em>PS: span 给的 id 是文章的 url 作为唯一的 key 值</em></strong></p>\n<h3 id=\"7-4-修改主题下layout-parial目录下after-footer-ejs文件，-添加如下代码\"><a href=\"#7-4-修改主题下layout-parial目录下after-footer-ejs文件，-添加如下代码\" class=\"headerlink\" title=\"7.4 修改主题下layout_parial目录下after.footer.ejs文件， 添加如下代码\"></a>7.4 修改主题下layout_parial目录下after.footer.ejs文件， 添加如下代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"&lt;%- theme.js_cdn.jquery %&gt;\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span> (theme.leancloud_visitors.enable)&#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'post/leancloud'</span>) %&gt; </span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p><strong><em>PS:这是自定一个js文件,放在 layout_parial\\post 目录 leancloud.ejs中</em></strong></p>\n<hr>\n<p><strong><em>更多功能，未完待续。之后慢慢加上</em></strong>。</p>"},{"layout":"post","title":"Main函数之前的那些事儿02：App启动速度优化","date":"2016-05-10T05:36:00.000Z","_content":"> **公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间**\n>\n> - main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间\n> - main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。\n\n## 分析\n\n尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。\n\n### **+load优化思路**\n\n<!-- more -->\n\n* 在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。\n* 加载时机（分为3个时刻）\n  1. 系统调用完所有class的load方法之后，且在main函数执行之前。（__attribute__((constructor))）\n  2. 程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）\n  3. 程序didFinishLaunch之后。（在2之后延迟5s）\n* 结合GCD实现同步异步执行\n  有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）\n* 优先级问题\n  同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）\n\n## **demo**\n\n```\n//\n//  XRLoadManager.h\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import <Foundation/Foundation.h>\ntypedef NS_ENUM(NSUInteger, LoadAt) {\n    /**\n     *  准备执行main函数，优先级最高\n     */\n    LoadAtPreMain = 0,\n    /**\n     *  应用进入活跃状态, 在PreMain之后\n     */\n    LoadAtAppLaunched,\n    /**\n     *  遥远的时间, 大致在 becomeActive 执行完后 5s\n     */\n    LoadAtIdleTime,\n    \n    /////\n    LoadAtN\n};\n\n@interface XRLoadManager : NSObject\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;\n\n@end\n\n```\n\n```\n//\n//  XRLoadManager.m\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import \"XRLoadManager.h\"\n#import <UIKit/UIKit.h>\n#import <Foundation/Foundation.h>\n\n@interface _XRLoadObject : NSObject\n@property (nonatomic, assign) LoadAt at;\n@property (nonatomic, assign) NSInteger sort;\n@property (nonatomic, assign) BOOL mainThread;\n@property (nonatomic, copy) void (^block) (void);\n@end\n\n@implementation _XRLoadObject\n\n@end\n\n@implementation XRLoadManager\nstatic NSMutableArray *loadables[LoadAtN];\n\n\n+ (void)load_init {\n    static dispatch_once_t once;\n    dispatch_once(&once, ^{\n        for (int i = 0; i < LoadAtN; i++) {\n            loadables[i] = [NSMutableArray array];\n        }\n    });\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];\n}\n\n+ (void)load_deInit {\n    for (int i = 0; i < LoadAtN; i++) {\n        NSMutableArray *array = loadables[i];\n        [array removeAllObjects];\n    }\n}\n\n+ (void)handleAppLaunched:(NSNotification *)note {\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    \n    [self run_launched];\n    \n    // run idle\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^{\n        [self run_idleTime];\n        [self load_deInit];\n    });\n}\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:NO block:block];\n}\n\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:YES block:block];\n}\n\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block {\n    [self load_some:at sort:sort mainthread:YES block:block];\n}\n\n+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block {\n    assert(block);\n    _XRLoadObject *obj = [[_XRLoadObject alloc] init];\n    obj.at = at;\n    obj.sort = sort;\n    obj.mainThread = mainthread;\n    obj.block = block;\n    [self load_init];\n    [loadables[at] addObject:obj];\n}\n\n+ (void)run_preMain {\n    [self run_block_array:LoadAtPreMain];\n}\n\n+ (void)run_launched {\n    [self run_block_array:LoadAtAppLaunched];\n}\n\n+ (void)run_idleTime {\n    [self run_block_array:LoadAtIdleTime];\n}\n\n+ (void)run_block_array:(LoadAt)at {\n    \n    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) {\n        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) {\n            if (!obj1.mainThread && obj2.mainThread) {\n                return NSOrderedDescending;\n            }\n            if (obj1.mainThread && !obj2.mainThread) {\n                return NSOrderedAscending;\n            }\n            if (obj1.sort > obj2.sort) {\n                return NSOrderedDescending;\n            }\n            if (obj1.sort == obj2.sort) {\n                return NSOrderedSame;\n            }\n            return NSOrderedAscending;\n        }];\n        for (_XRLoadObject *obj in array) {\n            if (obj.mainThread) {\n                if ([NSThread isMainThread]) {\n                    obj.block();\n                } else {\n                    dispatch_async(dispatch_get_main_queue(), obj.block);\n                }\n            } else {\n                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);\n            }\n        }\n    };\n    if (at == LoadAtPreMain) {\n        sortLoadBlock(loadables[LoadAtPreMain]);\n    }else if (at == LoadAtAppLaunched) {\n        sortLoadBlock(loadables[LoadAtAppLaunched]);\n    }else if (at == LoadAtIdleTime) {\n        sortLoadBlock(loadables[LoadAtIdleTime]);\n    }\n    \n}\n\n@end\n\n__attribute__((constructor))\nstatic void initlize(void) {\n    [XRLoadManager run_preMain];\n}\n```\n","source":"_posts/iOS-03.md","raw":"---\nlayout: post\ntitle: \"Main函数之前的那些事儿02：App启动速度优化\"\ndate: 2016-05-10 13:36\ncategories: \n- 技术\n- [技术, iOS]\ntags: \n- 技术\n- iOS\n---\n> **公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间**\n>\n> - main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间\n> - main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。\n\n## 分析\n\n尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。\n\n### **+load优化思路**\n\n<!-- more -->\n\n* 在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。\n* 加载时机（分为3个时刻）\n  1. 系统调用完所有class的load方法之后，且在main函数执行之前。（__attribute__((constructor))）\n  2. 程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）\n  3. 程序didFinishLaunch之后。（在2之后延迟5s）\n* 结合GCD实现同步异步执行\n  有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）\n* 优先级问题\n  同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）\n\n## **demo**\n\n```\n//\n//  XRLoadManager.h\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import <Foundation/Foundation.h>\ntypedef NS_ENUM(NSUInteger, LoadAt) {\n    /**\n     *  准备执行main函数，优先级最高\n     */\n    LoadAtPreMain = 0,\n    /**\n     *  应用进入活跃状态, 在PreMain之后\n     */\n    LoadAtAppLaunched,\n    /**\n     *  遥远的时间, 大致在 becomeActive 执行完后 5s\n     */\n    LoadAtIdleTime,\n    \n    /////\n    LoadAtN\n};\n\n@interface XRLoadManager : NSObject\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block;\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;\n\n@end\n\n```\n\n```\n//\n//  XRLoadManager.m\n//  xr_load\n//\n//  Created by ARui on 2017/4/19.\n//  Copyright © 2017年 XR. All rights reserved.\n//\n\n#import \"XRLoadManager.h\"\n#import <UIKit/UIKit.h>\n#import <Foundation/Foundation.h>\n\n@interface _XRLoadObject : NSObject\n@property (nonatomic, assign) LoadAt at;\n@property (nonatomic, assign) NSInteger sort;\n@property (nonatomic, assign) BOOL mainThread;\n@property (nonatomic, copy) void (^block) (void);\n@end\n\n@implementation _XRLoadObject\n\n@end\n\n@implementation XRLoadManager\nstatic NSMutableArray *loadables[LoadAtN];\n\n\n+ (void)load_init {\n    static dispatch_once_t once;\n    dispatch_once(&once, ^{\n        for (int i = 0; i < LoadAtN; i++) {\n            loadables[i] = [NSMutableArray array];\n        }\n    });\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];\n}\n\n+ (void)load_deInit {\n    for (int i = 0; i < LoadAtN; i++) {\n        NSMutableArray *array = loadables[i];\n        [array removeAllObjects];\n    }\n}\n\n+ (void)handleAppLaunched:(NSNotification *)note {\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n    \n    [self run_launched];\n    \n    // run idle\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^{\n        [self run_idleTime];\n        [self load_deInit];\n    });\n}\n\n+ (void)load_async:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:NO block:block];\n}\n\n+ (void)load_main:(LoadAt)at block:(void(^)(void))block {\n    [self load_some:at sort:100 mainthread:YES block:block];\n}\n\n+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block {\n    [self load_some:at sort:sort mainthread:YES block:block];\n}\n\n+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block {\n    assert(block);\n    _XRLoadObject *obj = [[_XRLoadObject alloc] init];\n    obj.at = at;\n    obj.sort = sort;\n    obj.mainThread = mainthread;\n    obj.block = block;\n    [self load_init];\n    [loadables[at] addObject:obj];\n}\n\n+ (void)run_preMain {\n    [self run_block_array:LoadAtPreMain];\n}\n\n+ (void)run_launched {\n    [self run_block_array:LoadAtAppLaunched];\n}\n\n+ (void)run_idleTime {\n    [self run_block_array:LoadAtIdleTime];\n}\n\n+ (void)run_block_array:(LoadAt)at {\n    \n    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) {\n        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) {\n            if (!obj1.mainThread && obj2.mainThread) {\n                return NSOrderedDescending;\n            }\n            if (obj1.mainThread && !obj2.mainThread) {\n                return NSOrderedAscending;\n            }\n            if (obj1.sort > obj2.sort) {\n                return NSOrderedDescending;\n            }\n            if (obj1.sort == obj2.sort) {\n                return NSOrderedSame;\n            }\n            return NSOrderedAscending;\n        }];\n        for (_XRLoadObject *obj in array) {\n            if (obj.mainThread) {\n                if ([NSThread isMainThread]) {\n                    obj.block();\n                } else {\n                    dispatch_async(dispatch_get_main_queue(), obj.block);\n                }\n            } else {\n                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);\n            }\n        }\n    };\n    if (at == LoadAtPreMain) {\n        sortLoadBlock(loadables[LoadAtPreMain]);\n    }else if (at == LoadAtAppLaunched) {\n        sortLoadBlock(loadables[LoadAtAppLaunched]);\n    }else if (at == LoadAtIdleTime) {\n        sortLoadBlock(loadables[LoadAtIdleTime]);\n    }\n    \n}\n\n@end\n\n__attribute__((constructor))\nstatic void initlize(void) {\n    [XRLoadManager run_preMain];\n}\n```\n","slug":"iOS-03","published":1,"updated":"2019-12-20T06:08:22.049Z","comments":1,"photos":[],"link":"","_id":"ck4dsux33000godnqj0mwrf9q","content":"<blockquote>\n<p><strong>公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间</strong></p>\n<ul>\n<li>main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间</li>\n<li>main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li>\n</ul>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</p>\n<h3 id=\"load优化思路\"><a href=\"#load优化思路\" class=\"headerlink\" title=\"+load优化思路\"></a><strong>+load优化思路</strong></h3><a id=\"more\"></a>\n<ul>\n<li>在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。</li>\n<li>加载时机（分为3个时刻）<ol>\n<li>系统调用完所有class的load方法之后，且在main函数执行之前。（<strong>attribute</strong>((constructor))）</li>\n<li>程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）</li>\n<li>程序didFinishLaunch之后。（在2之后延迟5s）</li>\n</ol>\n</li>\n<li>结合GCD实现同步异步执行<br>有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）</li>\n<li>优先级问题<br>同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）</li>\n</ul>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a><strong>demo</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.h</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">typedef NS_ENUM(NSUInteger, LoadAt) &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  准备执行main函数，优先级最高</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtPreMain = 0,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  应用进入活跃状态, 在PreMain之后</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtAppLaunched,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  遥远的时间, 大致在 becomeActive 执行完后 5s</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtIdleTime,</span><br><span class=\"line\">    </span><br><span class=\"line\">    /////</span><br><span class=\"line\">    LoadAtN</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XRLoadManager : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.m</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;XRLoadManager.h&quot;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface _XRLoadObject : NSObject</span><br><span class=\"line\">@property (nonatomic, assign) LoadAt at;</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger sort;</span><br><span class=\"line\">@property (nonatomic, assign) BOOL mainThread;</span><br><span class=\"line\">@property (nonatomic, copy) void (^block) (void);</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation _XRLoadObject</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XRLoadManager</span><br><span class=\"line\">static NSMutableArray *loadables[LoadAtN];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_init &#123;</span><br><span class=\"line\">    static dispatch_once_t once;</span><br><span class=\"line\">    dispatch_once(&amp;once, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">            loadables[i] = [NSMutableArray array];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_deInit &#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">        NSMutableArray *array = loadables[i];</span><br><span class=\"line\">        [array removeAllObjects];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)handleAppLaunched:(NSNotification *)note &#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self run_launched];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // run idle</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        [self run_idleTime];</span><br><span class=\"line\">        [self load_deInit];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:NO block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:sort mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block &#123;</span><br><span class=\"line\">    assert(block);</span><br><span class=\"line\">    _XRLoadObject *obj = [[_XRLoadObject alloc] init];</span><br><span class=\"line\">    obj.at = at;</span><br><span class=\"line\">    obj.sort = sort;</span><br><span class=\"line\">    obj.mainThread = mainthread;</span><br><span class=\"line\">    obj.block = block;</span><br><span class=\"line\">    [self load_init];</span><br><span class=\"line\">    [loadables[at] addObject:obj];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_preMain &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtPreMain];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_launched &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtAppLaunched];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_idleTime &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtIdleTime];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_block_array:(LoadAt)at &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) &#123;</span><br><span class=\"line\">        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) &#123;</span><br><span class=\"line\">            if (!obj1.mainThread &amp;&amp; obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.mainThread &amp;&amp; !obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedAscending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort &gt; obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort == obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return NSOrderedAscending;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        for (_XRLoadObject *obj in array) &#123;</span><br><span class=\"line\">            if (obj.mainThread) &#123;</span><br><span class=\"line\">                if ([NSThread isMainThread]) &#123;</span><br><span class=\"line\">                    obj.block();</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dispatch_async(dispatch_get_main_queue(), obj.block);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if (at == LoadAtPreMain) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtPreMain]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtAppLaunched) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtAppLaunched]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtIdleTime) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtIdleTime]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((constructor))</span><br><span class=\"line\">static void initlize(void) &#123;</span><br><span class=\"line\">    [XRLoadManager run_preMain];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>公式：App总启动时间 = main()函数之前的加载时间 + main()之后的加载时间</strong></p>\n<ul>\n<li>main()之前的加载时间：dylib链接动态库的时间+自身App可执行文件的加载时间</li>\n<li>main()之后的加载时间：main方法执行之后到AppDelegate的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li>\n</ul>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>尽量别在+load方法里搞事情，且对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</p>\n<h3 id=\"load优化思路\"><a href=\"#load优化思路\" class=\"headerlink\" title=\"+load优化思路\"></a><strong>+load优化思路</strong></h3>","more":"<ul>\n<li>在load方法中需要执行的代码通过block的方式添加进一个全局的数组中，然后在对应的时刻，执行该block。</li>\n<li>加载时机（分为3个时刻）<ol>\n<li>系统调用完所有class的load方法之后，且在main函数执行之前。（<strong>attribute</strong>((constructor))）</li>\n<li>程序didFinishLaunch。（UIApplicationDidBecomeActiveNotification通知）</li>\n<li>程序didFinishLaunch之后。（在2之后延迟5s）</li>\n</ol>\n</li>\n<li>结合GCD实现同步异步执行<br>有些代码需要在主线程同步执行，有的则可以异步去执行。（提供2种类型的接口）</li>\n<li>优先级问题<br>同步执行的过程中，有的class的load方法要在其他的class的load方法之前去执行，就需要一个优先级控制。（通过参数，数组排序实现）</li>\n</ul>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a><strong>demo</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.h</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">typedef NS_ENUM(NSUInteger, LoadAt) &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  准备执行main函数，优先级最高</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtPreMain = 0,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  应用进入活跃状态, 在PreMain之后</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtAppLaunched,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  遥远的时间, 大致在 becomeActive 执行完后 5s</span><br><span class=\"line\">     */</span><br><span class=\"line\">    LoadAtIdleTime,</span><br><span class=\"line\">    </span><br><span class=\"line\">    /////</span><br><span class=\"line\">    LoadAtN</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XRLoadManager : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block;</span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">//  XRLoadManager.m</span><br><span class=\"line\">//  xr_load</span><br><span class=\"line\">//</span><br><span class=\"line\">//  Created by ARui on 2017/4/19.</span><br><span class=\"line\">//  Copyright © 2017年 XR. All rights reserved.</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;XRLoadManager.h&quot;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface _XRLoadObject : NSObject</span><br><span class=\"line\">@property (nonatomic, assign) LoadAt at;</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger sort;</span><br><span class=\"line\">@property (nonatomic, assign) BOOL mainThread;</span><br><span class=\"line\">@property (nonatomic, copy) void (^block) (void);</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation _XRLoadObject</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XRLoadManager</span><br><span class=\"line\">static NSMutableArray *loadables[LoadAtN];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_init &#123;</span><br><span class=\"line\">    static dispatch_once_t once;</span><br><span class=\"line\">    dispatch_once(&amp;once, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">            loadables[i] = [NSMutableArray array];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleAppLaunched:) name:UIApplicationDidBecomeActiveNotification object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_deInit &#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; LoadAtN; i++) &#123;</span><br><span class=\"line\">        NSMutableArray *array = loadables[i];</span><br><span class=\"line\">        [array removeAllObjects];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)handleAppLaunched:(NSNotification *)note &#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self run_launched];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // run idle</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        [self run_idleTime];</span><br><span class=\"line\">        [self load_deInit];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_async:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:NO block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:100 mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_main:(LoadAt)at sort:(NSInteger)sort block:(void(^)(void))block &#123;</span><br><span class=\"line\">    [self load_some:at sort:sort mainthread:YES block:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load_some:(LoadAt)at sort:(NSInteger)sort mainthread:(BOOL)mainthread block:(void(^)(void))block &#123;</span><br><span class=\"line\">    assert(block);</span><br><span class=\"line\">    _XRLoadObject *obj = [[_XRLoadObject alloc] init];</span><br><span class=\"line\">    obj.at = at;</span><br><span class=\"line\">    obj.sort = sort;</span><br><span class=\"line\">    obj.mainThread = mainthread;</span><br><span class=\"line\">    obj.block = block;</span><br><span class=\"line\">    [self load_init];</span><br><span class=\"line\">    [loadables[at] addObject:obj];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_preMain &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtPreMain];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_launched &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtAppLaunched];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_idleTime &#123;</span><br><span class=\"line\">    [self run_block_array:LoadAtIdleTime];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)run_block_array:(LoadAt)at &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void(^sortLoadBlock)(NSMutableArray *array) = ^(NSMutableArray *array) &#123;</span><br><span class=\"line\">        [array sortUsingComparator:^NSComparisonResult(_XRLoadObject* _Nonnull obj1, _XRLoadObject* _Nonnull obj2) &#123;</span><br><span class=\"line\">            if (!obj1.mainThread &amp;&amp; obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.mainThread &amp;&amp; !obj2.mainThread) &#123;</span><br><span class=\"line\">                return NSOrderedAscending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort &gt; obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedDescending;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (obj1.sort == obj2.sort) &#123;</span><br><span class=\"line\">                return NSOrderedSame;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return NSOrderedAscending;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        for (_XRLoadObject *obj in array) &#123;</span><br><span class=\"line\">            if (obj.mainThread) &#123;</span><br><span class=\"line\">                if ([NSThread isMainThread]) &#123;</span><br><span class=\"line\">                    obj.block();</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dispatch_async(dispatch_get_main_queue(), obj.block);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                dispatch_async(dispatch_get_global_queue(0, 0), obj.block);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if (at == LoadAtPreMain) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtPreMain]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtAppLaunched) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtAppLaunched]);</span><br><span class=\"line\">    &#125;else if (at == LoadAtIdleTime) &#123;</span><br><span class=\"line\">        sortLoadBlock(loadables[LoadAtIdleTime]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((constructor))</span><br><span class=\"line\">static void initlize(void) &#123;</span><br><span class=\"line\">    [XRLoadManager run_preMain];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"日常开发01：一行代码搞定全屏滑动返回手势","date":"2016-01-10T05:36:30.000Z","_content":"\n开发过程中我们经常会遇到这种需求，给某个页面添加全屏的滑动返回。当然iOS7之后，系统有提供一个边缘滑动返回的手势。很明显无法完成需求。产品要的是全屏。\n\n* 思路1：\n   既然UINavigationController有提供interactivePopGestureRecognizer手势。 UIGestureRecognizer采用的是target-action。这样我们可以找到手势的target和action。然后新建一个自己的手势实例，替换为系统手势的action实现就是了。\n\n   <!-- more -->\n\n   ```\n       id target = self.interactivePopGestureRecognizer.delegate\n\n           UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];\n\n        pan.delegate = self;\n\n           [self.view addGestureRecognizer:pan];\n\n           self.interactivePopGestureRecognizer.enabled = NO;\n\n   ```\n\n   ​\n\n* 思路2：\n  能不能不写那么多的代码？在研究interactivePopGestureRecognizer手势的过程中。通过运行时层层打印。\n  * _recognizer：\n    ![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1488967-5c04f8190606dbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  * _recognizer._settings：\n      ![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1488967-2a283ed9c0d7385b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  * _recognizer._settings._edgeSettings：\n    ![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1488967-b451632afa82d5b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n猜测_edgeSettings属性就是我们要找的设置返回手势响应范围的。\n```        \n[self.interactivePopGestureRecognizer setValue:@([UIScreen mainScreen].bounds.size.width) forKeyPath:@\"_recognizer._settings._edgeSettings._edgeRegionSize\"];  \n```\n","source":"_posts/ios-daily-01.md","raw":"---\nlayout: post\ntitle: \"日常开发01：一行代码搞定全屏滑动返回手势\"\ndate: 2016-01-10 13:36:30\ncategories: \n- 技术\n- [技术, iOS]\ntags: \n- 技术\n- iOS\n- 日常\n---\n\n开发过程中我们经常会遇到这种需求，给某个页面添加全屏的滑动返回。当然iOS7之后，系统有提供一个边缘滑动返回的手势。很明显无法完成需求。产品要的是全屏。\n\n* 思路1：\n   既然UINavigationController有提供interactivePopGestureRecognizer手势。 UIGestureRecognizer采用的是target-action。这样我们可以找到手势的target和action。然后新建一个自己的手势实例，替换为系统手势的action实现就是了。\n\n   <!-- more -->\n\n   ```\n       id target = self.interactivePopGestureRecognizer.delegate\n\n           UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];\n\n        pan.delegate = self;\n\n           [self.view addGestureRecognizer:pan];\n\n           self.interactivePopGestureRecognizer.enabled = NO;\n\n   ```\n\n   ​\n\n* 思路2：\n  能不能不写那么多的代码？在研究interactivePopGestureRecognizer手势的过程中。通过运行时层层打印。\n  * _recognizer：\n    ![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1488967-5c04f8190606dbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  * _recognizer._settings：\n      ![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1488967-2a283ed9c0d7385b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  * _recognizer._settings._edgeSettings：\n    ![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1488967-b451632afa82d5b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n猜测_edgeSettings属性就是我们要找的设置返回手势响应范围的。\n```        \n[self.interactivePopGestureRecognizer setValue:@([UIScreen mainScreen].bounds.size.width) forKeyPath:@\"_recognizer._settings._edgeSettings._edgeRegionSize\"];  \n```\n","slug":"ios-daily-01","published":1,"updated":"2019-12-20T06:08:22.050Z","comments":1,"photos":[],"link":"","_id":"ck4dsux34000iodnqiunw3bqf","content":"<p>开发过程中我们经常会遇到这种需求，给某个页面添加全屏的滑动返回。当然iOS7之后，系统有提供一个边缘滑动返回的手势。很明显无法完成需求。产品要的是全屏。</p>\n<ul>\n<li><p>思路1：<br> 既然UINavigationController有提供interactivePopGestureRecognizer手势。 UIGestureRecognizer采用的是target-action。这样我们可以找到手势的target和action。然后新建一个自己的手势实例，替换为系统手势的action实现就是了。</p>\n <a id=\"more\"></a>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       id target = self.interactivePopGestureRecognizer.delegate</span><br><span class=\"line\"></span><br><span class=\"line\">           UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];</span><br><span class=\"line\"></span><br><span class=\"line\">        pan.delegate = self;</span><br><span class=\"line\"></span><br><span class=\"line\">           [self.view addGestureRecognizer:pan];</span><br><span class=\"line\"></span><br><span class=\"line\">           self.interactivePopGestureRecognizer.enabled = NO;</span><br></pre></td></tr></table></figure>\n<p> ​</p>\n</li>\n<li><p>思路2：<br>能不能不写那么多的代码？在研究interactivePopGestureRecognizer手势的过程中。通过运行时层层打印。</p>\n<ul>\n<li>_recognizer：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-5c04f8190606dbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></li>\n<li>_recognizer._settings：<br>  <img src=\"http://upload-images.jianshu.io/upload_images/1488967-2a283ed9c0d7385b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></li>\n<li>_recognizer._settings._edgeSettings：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-b451632afa82d5b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></li>\n</ul>\n</li>\n</ul>\n<p>猜测_edgeSettings属性就是我们要找的设置返回手势响应范围的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.interactivePopGestureRecognizer setValue:@([UIScreen mainScreen].bounds.size.width) forKeyPath:@&quot;_recognizer._settings._edgeSettings._edgeRegionSize&quot;];</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>开发过程中我们经常会遇到这种需求，给某个页面添加全屏的滑动返回。当然iOS7之后，系统有提供一个边缘滑动返回的手势。很明显无法完成需求。产品要的是全屏。</p>\n<ul>\n<li><p>思路1：<br> 既然UINavigationController有提供interactivePopGestureRecognizer手势。 UIGestureRecognizer采用的是target-action。这样我们可以找到手势的target和action。然后新建一个自己的手势实例，替换为系统手势的action实现就是了。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       id target = self.interactivePopGestureRecognizer.delegate</span><br><span class=\"line\"></span><br><span class=\"line\">           UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];</span><br><span class=\"line\"></span><br><span class=\"line\">        pan.delegate = self;</span><br><span class=\"line\"></span><br><span class=\"line\">           [self.view addGestureRecognizer:pan];</span><br><span class=\"line\"></span><br><span class=\"line\">           self.interactivePopGestureRecognizer.enabled = NO;</span><br></pre></td></tr></table></figure>\n<p> ​</p>\n</li>\n<li><p>思路2：<br>能不能不写那么多的代码？在研究interactivePopGestureRecognizer手势的过程中。通过运行时层层打印。</p>\n<ul>\n<li>_recognizer：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-5c04f8190606dbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></li>\n<li>_recognizer._settings：<br>  <img src=\"http://upload-images.jianshu.io/upload_images/1488967-2a283ed9c0d7385b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></li>\n<li>_recognizer._settings._edgeSettings：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-b451632afa82d5b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></li>\n</ul>\n</li>\n</ul>\n<p>猜测_edgeSettings属性就是我们要找的设置返回手势响应范围的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.interactivePopGestureRecognizer setValue:@([UIScreen mainScreen].bounds.size.width) forKeyPath:@&quot;_recognizer._settings._edgeSettings._edgeRegionSize&quot;];</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"Main函数之前的那些事儿01：dylb","date":"2016-05-10T00:10:00.000Z","_content":">前言：\n>甩几个问题出来，答案从问题开始。\n>1.类的+load方法系统是怎么调用的？\n>2.一个类+load方法系统为什么只会调用一次？为什么不能在+load方法中调用super？\n>3.为什么fishhook库只能hook应用挂载的外部动态库里的函数？\n>\n>然后这些问题就引出了dylb这个鬼，然后就一脸懵逼了。iOS应用中可执行文件是什么？有那些是可执行文件？动态库是在程序启动后由dylb链接，那么静态库又是什么时候链接的？dylb是通过镜像的形式加载二进制文件的，镜像是什么鬼？运行时环境也是在mian之前初始化的，dylb和运行时环境有没有什么不可描述的关系？\n\n---\n\n**编译-链接-运行**\n源文件-->编译-->目标文件-->（静态链接）链接静态库文件-->生成可执行文件\napp启动-->加载可执行文件-->（动态链接）链接动态库文件-->初始化运行时环境-->main()\n\n<!-- more -->\n\n**Helloworld**\n![Snip20170505_2.png](http://upload-images.jianshu.io/upload_images/1488967-838b458845226301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![Snip20170505_4.png](http://upload-images.jianshu.io/upload_images/1488967-1447ca6d90136428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n1.分别创建了Foo.h,Foo.m,helloworld.m三个文件\n2.编译Foo.m和helloworld.m文件，生成Foo.o和helloworld.o两个目标文件\n3.链接Foundation库，如果不指定默认生成a.out的可执行文件\n4.执行可执行文件\n\n**Mach-O文件类型**\n  *  1.可执行文件（mh_execute）(.app)\n     简单理解为:静态库中所有的.o文件+app编译产生的所有.o文件的集合\n  *  2.动态库（mh_dylib）（.dylib）\n  *  3.包（mh_bundle）(.bundle)\n      简单理解，就是资源文件包 \n  *  4.静态库（staticlib）(.a/.framework)\n     .a:一堆.o文件的集合\n      .framework：一堆.o文件的集合+资源文件+头文件\n  *  5.可重定位的对象文件（mh_object）(.o)\n     编译后，每一个.m/.c/.mm等文件都会生成为一种.o格式的目标文件。\n\n**Mach-O文件结构**\n\n![Mach-O文件结构.png](http://upload-images.jianshu.io/upload_images/1488967-459b57d7460696ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680)\n\n* 1.标题:指定文件的目标体系结构，如PPC，PPC64，IA-32或x86-64。\n* 2.加载命令：在虚拟内存中指定文件的逻辑结构和文件的布局。\n* 3.原始段数据：包含在加载命令中定义的段的原始数据。\n\n**静态库（.a /.framework）**\n链接时期由静态链接器将静态库中的.o文件完整复制到可执行文件中。\n\n***PS:CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考这里，或者使用CocoasPods-Packager这个插件。（所以每次pod install后，特么编译项目都贼慢，为毛，因为编译器需要编译项目本身代码+各自pod库中的代码，最后将pod库中的代码生成.a文件。然后再编译就会快很多啊，因为编译时期就没有编译pod库了，而是直接连接一个个pod的.a库）***\n\n**动态库(.dylib/.framework)**\n由dylb动态加载进内存。且多个app共享一份动态库，动态库基本上都是由系统提供。\n动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。\n\n***PS:iOS 平台不支持使用动态库，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，动态下载代码又是被苹果明令禁止的。***\n\n**静态链接(static linking)**\n静态连接器就是将项目自身编译好的.o文件集合和一些静态库的.o文件集合进行整合，然后提取出每个.o文件中的用到的一些外部符号引用，并且对这些符号进行重定位，最终生成一个完整的可执行文件。\n\n***PS:生成并非是真正的可执行文件，因为此时并不包含一些动态库中的代码，保存的只是一些对外部库中的符号引用。***\n\n**动态连接(dylb)**\n\n![forumImage20161207173929050.png](http://upload-images.jianshu.io/upload_images/1488967-add412737218082e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n内核初始化环境之后，初始化的dylb环境，由dylb加载一些系统库以及动态库到内存中之后，然后初始化运行时环境，接下来由运行时环境接管，通过运行时环境调用所有class的+load方法。_dylb_start之前的部分属于xnu内核的东西，看不太懂。\n\n*  动态链接库加载流程\n  *  load dylibs image 读取库镜像文件\n      * 1.分析所依赖的动态库\n      * 2.找到动态库的mach-o文件\n      * 3.打开文件\n      * 4.验证文件\n      * 5.在系统核心注册文件签名\n      * 6.对动态库的每一个segment调用mmap()\n  *  Rebase image\n  *  Bind image\n  *  Objc setup\n      * 1.注册Objc类 (class registration)\n      * 2.把category的定义插入方法列表 (category registration)\n      * 3.保证每一个selector唯一 (selctor uniquing）\n\n  *  initializers\n    * 1.Objc的+load()函数\n    * 2.C++的构造函数属性函数 形如**attribute**((constructor)) void DoSomeInitializationWork()\n    * 3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度\n\n在load dylibs image中可以看到dylb去读取镜像文件，加载进内存，并且对Mach-O文件进行解析。而镜像也就是指Mach-O文件。且不同类型的Mach-O文件由不同的ImageLoader子类实例进行加载。\n\n![forumImage20161207151029417.png](http://upload-images.jianshu.io/upload_images/1488967-ba7a0f193fdb7a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nRebase image和Bind image是对镜像文件进行一些优化计算之类的操作。\n\n* 运行时处理+load加载\n\n![forumImage20161207173728453.png](http://upload-images.jianshu.io/upload_images/1488967-64d6772684462a77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n 运行时初始化的时候，会向dylb注册镜像加载的回调。也就是每当有dylb有新的镜像加载进内场的时候，新的镜像都会被map到runtime中，并且由runtime处理+load的加载。\n\n利用https://github.com/RetVal 封装好的 debug 版最新源码可以进行断点调试，就可以看到系统在调用Test类的+load()方法之前的调用栈。打印如下：\n```\n    frame #0: 0x0000000100000f37 debug-objc`+[Test load](self=Test, _cmd=\"load\") + 23 at Test.m:13\n    frame #1: 0x00000001000b84e6 libobjc.A.dylib`call_class_loads() + 198 at objc-loadmethod.mm:209\n    frame #2: 0x00000001000a2a4d libobjc.A.dylib`::call_load_methods() + 77 at objc-loadmethod.mm:361\n    frame #3: 0x00000001000a28ba libobjc.A.dylib`::load_images(path=\"/Users/xurui/Library/Developer/Xcode/DerivedData/objc-eaekfqpmgbdaycbpoisopskbjiqq/Build/Products/Debug/debug-objc\", mh=0x0000000100000000) + 106 at objc-runtime-new.mm:2051\n  * frame #4: 0x0000000100007072 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 439\n    frame #5: 0x00000001000161dc dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 320\n    frame #6: 0x0000000100015268 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 138\n    frame #7: 0x00000001000152fd dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 75\n    frame #8: 0x000000010000747a dyld`dyld::initializeMainExecutable() + 195\n    frame #9: 0x000000010000b7e0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3928\n    frame #10: 0x0000000100006249 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 470\n    frame #11: 0x0000000100006036 dyld`_dyld_start + 54\n\n```\n4-11步骤主要执行的是_dyld_start的一些初始化操作。\n主要看0-3步骤。\n* load_images\n  源码解读：\n```\nvoid load_images(const char *path __unused, const struct mach_header *mh)\n{\n    // 没有查询到传入 Class 中的 load 方法，视为锁定状态\n    // 则无需给其加载权限，直接返回\n    if (!hasLoadMethods((const headerType *)mh)) return;\n    // 定义可递归锁对象\n    // 由于 load_images 方法由 dyld 进行回调，所以数据需上锁才能保证线程安全\n    // 为了防止多次加锁造成的死锁情况，使用可递归锁解决\n    recursive_mutex_locker_t lock(loadMethodLock);\n\n    // 收集所有的 +load 方法\n    {\n        // 对 Darwin 提供的线程写锁的封装类\n        rwlock_writer_t lock2(runtimeLock);\n        // 提前准备好满足 +load 方法调用条件的 Class\n        prepare_load_methods((const headerType *)mh);\n    }\n\n    // 调用 +load 方法 (without runtimeLock - re-entrant)\n    call_load_methods();\n}\n```\n* prepare_load_methods\n  源码解读：\n```\nvoid prepare_load_methods(const headerType *mhdr)\n{\n    size_t count, i;\n\n    runtimeLock.assertWriting();\n    // 收集 Class 中的 +load 方法\n    // 获取所有的类的列表\n    classref_t *classlist = \n        _getObjc2NonlazyClassList(mhdr, &count);\n    for (i = 0; i < count; i++) {\n        // 通过 remapClass 获取类指针\n        // schedul_class_load 递归到父类逐层载入\n        schedule_class_load(remapClass(classlist[i]));\n    }\n    // 收集 Category 中的 +load 方法\n    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &count);\n    for (i = 0; i < count; i++) {\n        category_t *cat = categorylist[i];\n        // 通过 remapClass 获取 Category 对象存有的 Class 对象\n        Class cls = remapClass(cat->cls);\n        if (!cls) continue;\n        // 对类进行第一次初始化，主要用来分配可读写数据空间并返回真正的类结构\n        realizeClass(cls);\n        assert(cls->ISA()->isRealized());\n        // 将需要执行 load 的 Category 添加到一个全局列表中\n        add_category_to_loadable_list(cat);\n    }\n}\n```\n* call_load_methods() \n  源码解读：\n```\nvoid call_load_methods(void)\n{\n    // 是否已经录入\n    static bool loading = NO;\n    // 是否有关联的 Category\n    bool more_categories;\n\n    loadMethodLock.assertLocked();\n\n    // 由于 loading 是全局静态布尔量，如果已经录入方法则直接退出\n    if (loading) return;\n    loading = YES;\n    // 声明一个 autoreleasePool 对象\n    // 使用 push 操作其目的是为了创建一个新的 autoreleasePool 对象\n    void *pool = objc_autoreleasePoolPush();\n\n    do {\n        // 重复调用 load 方法，直到没有\n        while (loadable_classes_used > 0) {\n            call_class_loads();\n        }\n\n        // 调用 Category 中的 load 方法\n        more_categories = call_category_loads();\n\n        // 继续调用，直到所有 Class 全部完成\n    } while (loadable_classes_used > 0  ||  more_categories);\n    // 将创建的 autoreleasePool 对象释放\n    objc_autoreleasePoolPop(pool);\n    // 更改全局标记，表示已经录入\n    loading = NO;\n}\n```\n* call_class_loads() \n  源码解读：\n```\nstatic void call_class_loads(void)\n{\n    // 声明下标偏移\n    int i;\n    \n    // 分离加载的 Class 列表\n    struct loadable_class *classes = loadable_classes;\n    // 调用标记\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // 调用列表中的 Class 类的 load 方法\n    for (i = 0; i < used; i++) {\n        // 获取 Class 指针\n        Class cls = classes[i].cls;\n        // 获取方法对象\n        load_method_t load_method = (load_method_t)classes[i].method;\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        // 方法调用\n        (*load_method)(cls, SEL_load);\n    }\n    \n    // 释放 Class 列表\n    if (classes) free(classes);\n}\n```\n+load方法的调用过程，在runtime接收到有dylb有新的镜像加载的回调之后，通过laodImage()将所有的class加载进内存中，并且按照继承结构，递归获取所有class的+load方法，将该class的+load方法添加进一个全局的loadable_classes的结构体中存放，将该class的分类中的+load方法添加一个全局的loadable_categories的结构体中存放。最后通过call_load_methods()函数查找class在内存中对应的结构体中的+load方法，依次执行+load方法的过程。\n\n\n参考\nhttps://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\nhttp://blog.sunnyxx.com/2014/08/30/objc-pre-main/\nhttps://techblog.toutiao.com/2017/01/17/iosspeed/\n","source":"_posts/iOS-02.md","raw":"---\nlayout: post\ntitle: \"Main函数之前的那些事儿01：dylb\"\ndate: 2016-05-10 08:10\ncategories: \n- 技术\n- [技术, iOS]\ntags: \n- 技术\n- iOS\n---\n>前言：\n>甩几个问题出来，答案从问题开始。\n>1.类的+load方法系统是怎么调用的？\n>2.一个类+load方法系统为什么只会调用一次？为什么不能在+load方法中调用super？\n>3.为什么fishhook库只能hook应用挂载的外部动态库里的函数？\n>\n>然后这些问题就引出了dylb这个鬼，然后就一脸懵逼了。iOS应用中可执行文件是什么？有那些是可执行文件？动态库是在程序启动后由dylb链接，那么静态库又是什么时候链接的？dylb是通过镜像的形式加载二进制文件的，镜像是什么鬼？运行时环境也是在mian之前初始化的，dylb和运行时环境有没有什么不可描述的关系？\n\n---\n\n**编译-链接-运行**\n源文件-->编译-->目标文件-->（静态链接）链接静态库文件-->生成可执行文件\napp启动-->加载可执行文件-->（动态链接）链接动态库文件-->初始化运行时环境-->main()\n\n<!-- more -->\n\n**Helloworld**\n![Snip20170505_2.png](http://upload-images.jianshu.io/upload_images/1488967-838b458845226301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![Snip20170505_4.png](http://upload-images.jianshu.io/upload_images/1488967-1447ca6d90136428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n1.分别创建了Foo.h,Foo.m,helloworld.m三个文件\n2.编译Foo.m和helloworld.m文件，生成Foo.o和helloworld.o两个目标文件\n3.链接Foundation库，如果不指定默认生成a.out的可执行文件\n4.执行可执行文件\n\n**Mach-O文件类型**\n  *  1.可执行文件（mh_execute）(.app)\n     简单理解为:静态库中所有的.o文件+app编译产生的所有.o文件的集合\n  *  2.动态库（mh_dylib）（.dylib）\n  *  3.包（mh_bundle）(.bundle)\n      简单理解，就是资源文件包 \n  *  4.静态库（staticlib）(.a/.framework)\n     .a:一堆.o文件的集合\n      .framework：一堆.o文件的集合+资源文件+头文件\n  *  5.可重定位的对象文件（mh_object）(.o)\n     编译后，每一个.m/.c/.mm等文件都会生成为一种.o格式的目标文件。\n\n**Mach-O文件结构**\n\n![Mach-O文件结构.png](http://upload-images.jianshu.io/upload_images/1488967-459b57d7460696ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680)\n\n* 1.标题:指定文件的目标体系结构，如PPC，PPC64，IA-32或x86-64。\n* 2.加载命令：在虚拟内存中指定文件的逻辑结构和文件的布局。\n* 3.原始段数据：包含在加载命令中定义的段的原始数据。\n\n**静态库（.a /.framework）**\n链接时期由静态链接器将静态库中的.o文件完整复制到可执行文件中。\n\n***PS:CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考这里，或者使用CocoasPods-Packager这个插件。（所以每次pod install后，特么编译项目都贼慢，为毛，因为编译器需要编译项目本身代码+各自pod库中的代码，最后将pod库中的代码生成.a文件。然后再编译就会快很多啊，因为编译时期就没有编译pod库了，而是直接连接一个个pod的.a库）***\n\n**动态库(.dylib/.framework)**\n由dylb动态加载进内存。且多个app共享一份动态库，动态库基本上都是由系统提供。\n动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。\n\n***PS:iOS 平台不支持使用动态库，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，动态下载代码又是被苹果明令禁止的。***\n\n**静态链接(static linking)**\n静态连接器就是将项目自身编译好的.o文件集合和一些静态库的.o文件集合进行整合，然后提取出每个.o文件中的用到的一些外部符号引用，并且对这些符号进行重定位，最终生成一个完整的可执行文件。\n\n***PS:生成并非是真正的可执行文件，因为此时并不包含一些动态库中的代码，保存的只是一些对外部库中的符号引用。***\n\n**动态连接(dylb)**\n\n![forumImage20161207173929050.png](http://upload-images.jianshu.io/upload_images/1488967-add412737218082e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n内核初始化环境之后，初始化的dylb环境，由dylb加载一些系统库以及动态库到内存中之后，然后初始化运行时环境，接下来由运行时环境接管，通过运行时环境调用所有class的+load方法。_dylb_start之前的部分属于xnu内核的东西，看不太懂。\n\n*  动态链接库加载流程\n  *  load dylibs image 读取库镜像文件\n      * 1.分析所依赖的动态库\n      * 2.找到动态库的mach-o文件\n      * 3.打开文件\n      * 4.验证文件\n      * 5.在系统核心注册文件签名\n      * 6.对动态库的每一个segment调用mmap()\n  *  Rebase image\n  *  Bind image\n  *  Objc setup\n      * 1.注册Objc类 (class registration)\n      * 2.把category的定义插入方法列表 (category registration)\n      * 3.保证每一个selector唯一 (selctor uniquing）\n\n  *  initializers\n    * 1.Objc的+load()函数\n    * 2.C++的构造函数属性函数 形如**attribute**((constructor)) void DoSomeInitializationWork()\n    * 3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度\n\n在load dylibs image中可以看到dylb去读取镜像文件，加载进内存，并且对Mach-O文件进行解析。而镜像也就是指Mach-O文件。且不同类型的Mach-O文件由不同的ImageLoader子类实例进行加载。\n\n![forumImage20161207151029417.png](http://upload-images.jianshu.io/upload_images/1488967-ba7a0f193fdb7a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nRebase image和Bind image是对镜像文件进行一些优化计算之类的操作。\n\n* 运行时处理+load加载\n\n![forumImage20161207173728453.png](http://upload-images.jianshu.io/upload_images/1488967-64d6772684462a77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n 运行时初始化的时候，会向dylb注册镜像加载的回调。也就是每当有dylb有新的镜像加载进内场的时候，新的镜像都会被map到runtime中，并且由runtime处理+load的加载。\n\n利用https://github.com/RetVal 封装好的 debug 版最新源码可以进行断点调试，就可以看到系统在调用Test类的+load()方法之前的调用栈。打印如下：\n```\n    frame #0: 0x0000000100000f37 debug-objc`+[Test load](self=Test, _cmd=\"load\") + 23 at Test.m:13\n    frame #1: 0x00000001000b84e6 libobjc.A.dylib`call_class_loads() + 198 at objc-loadmethod.mm:209\n    frame #2: 0x00000001000a2a4d libobjc.A.dylib`::call_load_methods() + 77 at objc-loadmethod.mm:361\n    frame #3: 0x00000001000a28ba libobjc.A.dylib`::load_images(path=\"/Users/xurui/Library/Developer/Xcode/DerivedData/objc-eaekfqpmgbdaycbpoisopskbjiqq/Build/Products/Debug/debug-objc\", mh=0x0000000100000000) + 106 at objc-runtime-new.mm:2051\n  * frame #4: 0x0000000100007072 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 439\n    frame #5: 0x00000001000161dc dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 320\n    frame #6: 0x0000000100015268 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 138\n    frame #7: 0x00000001000152fd dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 75\n    frame #8: 0x000000010000747a dyld`dyld::initializeMainExecutable() + 195\n    frame #9: 0x000000010000b7e0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3928\n    frame #10: 0x0000000100006249 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 470\n    frame #11: 0x0000000100006036 dyld`_dyld_start + 54\n\n```\n4-11步骤主要执行的是_dyld_start的一些初始化操作。\n主要看0-3步骤。\n* load_images\n  源码解读：\n```\nvoid load_images(const char *path __unused, const struct mach_header *mh)\n{\n    // 没有查询到传入 Class 中的 load 方法，视为锁定状态\n    // 则无需给其加载权限，直接返回\n    if (!hasLoadMethods((const headerType *)mh)) return;\n    // 定义可递归锁对象\n    // 由于 load_images 方法由 dyld 进行回调，所以数据需上锁才能保证线程安全\n    // 为了防止多次加锁造成的死锁情况，使用可递归锁解决\n    recursive_mutex_locker_t lock(loadMethodLock);\n\n    // 收集所有的 +load 方法\n    {\n        // 对 Darwin 提供的线程写锁的封装类\n        rwlock_writer_t lock2(runtimeLock);\n        // 提前准备好满足 +load 方法调用条件的 Class\n        prepare_load_methods((const headerType *)mh);\n    }\n\n    // 调用 +load 方法 (without runtimeLock - re-entrant)\n    call_load_methods();\n}\n```\n* prepare_load_methods\n  源码解读：\n```\nvoid prepare_load_methods(const headerType *mhdr)\n{\n    size_t count, i;\n\n    runtimeLock.assertWriting();\n    // 收集 Class 中的 +load 方法\n    // 获取所有的类的列表\n    classref_t *classlist = \n        _getObjc2NonlazyClassList(mhdr, &count);\n    for (i = 0; i < count; i++) {\n        // 通过 remapClass 获取类指针\n        // schedul_class_load 递归到父类逐层载入\n        schedule_class_load(remapClass(classlist[i]));\n    }\n    // 收集 Category 中的 +load 方法\n    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &count);\n    for (i = 0; i < count; i++) {\n        category_t *cat = categorylist[i];\n        // 通过 remapClass 获取 Category 对象存有的 Class 对象\n        Class cls = remapClass(cat->cls);\n        if (!cls) continue;\n        // 对类进行第一次初始化，主要用来分配可读写数据空间并返回真正的类结构\n        realizeClass(cls);\n        assert(cls->ISA()->isRealized());\n        // 将需要执行 load 的 Category 添加到一个全局列表中\n        add_category_to_loadable_list(cat);\n    }\n}\n```\n* call_load_methods() \n  源码解读：\n```\nvoid call_load_methods(void)\n{\n    // 是否已经录入\n    static bool loading = NO;\n    // 是否有关联的 Category\n    bool more_categories;\n\n    loadMethodLock.assertLocked();\n\n    // 由于 loading 是全局静态布尔量，如果已经录入方法则直接退出\n    if (loading) return;\n    loading = YES;\n    // 声明一个 autoreleasePool 对象\n    // 使用 push 操作其目的是为了创建一个新的 autoreleasePool 对象\n    void *pool = objc_autoreleasePoolPush();\n\n    do {\n        // 重复调用 load 方法，直到没有\n        while (loadable_classes_used > 0) {\n            call_class_loads();\n        }\n\n        // 调用 Category 中的 load 方法\n        more_categories = call_category_loads();\n\n        // 继续调用，直到所有 Class 全部完成\n    } while (loadable_classes_used > 0  ||  more_categories);\n    // 将创建的 autoreleasePool 对象释放\n    objc_autoreleasePoolPop(pool);\n    // 更改全局标记，表示已经录入\n    loading = NO;\n}\n```\n* call_class_loads() \n  源码解读：\n```\nstatic void call_class_loads(void)\n{\n    // 声明下标偏移\n    int i;\n    \n    // 分离加载的 Class 列表\n    struct loadable_class *classes = loadable_classes;\n    // 调用标记\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // 调用列表中的 Class 类的 load 方法\n    for (i = 0; i < used; i++) {\n        // 获取 Class 指针\n        Class cls = classes[i].cls;\n        // 获取方法对象\n        load_method_t load_method = (load_method_t)classes[i].method;\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        // 方法调用\n        (*load_method)(cls, SEL_load);\n    }\n    \n    // 释放 Class 列表\n    if (classes) free(classes);\n}\n```\n+load方法的调用过程，在runtime接收到有dylb有新的镜像加载的回调之后，通过laodImage()将所有的class加载进内存中，并且按照继承结构，递归获取所有class的+load方法，将该class的+load方法添加进一个全局的loadable_classes的结构体中存放，将该class的分类中的+load方法添加一个全局的loadable_categories的结构体中存放。最后通过call_load_methods()函数查找class在内存中对应的结构体中的+load方法，依次执行+load方法的过程。\n\n\n参考\nhttps://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\nhttp://blog.sunnyxx.com/2014/08/30/objc-pre-main/\nhttps://techblog.toutiao.com/2017/01/17/iosspeed/\n","slug":"iOS-02","published":1,"updated":"2019-12-20T06:08:22.049Z","comments":1,"photos":[],"link":"","_id":"ck4dsux36000modnqpf1i755h","content":"<blockquote>\n<p>前言：<br>甩几个问题出来，答案从问题开始。<br>1.类的+load方法系统是怎么调用的？<br>2.一个类+load方法系统为什么只会调用一次？为什么不能在+load方法中调用super？<br>3.为什么fishhook库只能hook应用挂载的外部动态库里的函数？</p>\n<p>然后这些问题就引出了dylb这个鬼，然后就一脸懵逼了。iOS应用中可执行文件是什么？有那些是可执行文件？动态库是在程序启动后由dylb链接，那么静态库又是什么时候链接的？dylb是通过镜像的形式加载二进制文件的，镜像是什么鬼？运行时环境也是在mian之前初始化的，dylb和运行时环境有没有什么不可描述的关系？</p>\n</blockquote>\n<hr>\n<p><strong>编译-链接-运行</strong><br>源文件–&gt;编译–&gt;目标文件–&gt;（静态链接）链接静态库文件–&gt;生成可执行文件<br>app启动–&gt;加载可执行文件–&gt;（动态链接）链接动态库文件–&gt;初始化运行时环境–&gt;main()</p>\n<a id=\"more\"></a>\n<p><strong>Helloworld</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-838b458845226301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170505_2.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-1447ca6d90136428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170505_4.png\"></p>\n<p>1.分别创建了Foo.h,Foo.m,helloworld.m三个文件<br>2.编译Foo.m和helloworld.m文件，生成Foo.o和helloworld.o两个目标文件<br>3.链接Foundation库，如果不指定默认生成a.out的可执行文件<br>4.执行可执行文件</p>\n<p><strong>Mach-O文件类型</strong></p>\n<ul>\n<li>1.可执行文件（mh_execute）(.app)<br>简单理解为:静态库中所有的.o文件+app编译产生的所有.o文件的集合</li>\n<li>2.动态库（mh_dylib）（.dylib）</li>\n<li>3.包（mh_bundle）(.bundle)<br> 简单理解，就是资源文件包 </li>\n<li>4.静态库（staticlib）(.a/.framework)<br>.a:一堆.o文件的集合<br> .framework：一堆.o文件的集合+资源文件+头文件</li>\n<li>5.可重定位的对象文件（mh_object）(.o)<br>编译后，每一个.m/.c/.mm等文件都会生成为一种.o格式的目标文件。</li>\n</ul>\n<p><strong>Mach-O文件结构</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-459b57d7460696ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680\" alt=\"Mach-O文件结构.png\"></p>\n<ul>\n<li>1.标题:指定文件的目标体系结构，如PPC，PPC64，IA-32或x86-64。</li>\n<li>2.加载命令：在虚拟内存中指定文件的逻辑结构和文件的布局。</li>\n<li>3.原始段数据：包含在加载命令中定义的段的原始数据。</li>\n</ul>\n<p><strong>静态库（.a /.framework）</strong><br>链接时期由静态链接器将静态库中的.o文件完整复制到可执行文件中。</p>\n<p><strong><em>PS:CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考这里，或者使用CocoasPods-Packager这个插件。（所以每次pod install后，特么编译项目都贼慢，为毛，因为编译器需要编译项目本身代码+各自pod库中的代码，最后将pod库中的代码生成.a文件。然后再编译就会快很多啊，因为编译时期就没有编译pod库了，而是直接连接一个个pod的.a库）</em></strong></p>\n<p><strong>动态库(.dylib/.framework)</strong><br>由dylb动态加载进内存。且多个app共享一份动态库，动态库基本上都是由系统提供。<br>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。</p>\n<p><strong><em>PS:iOS 平台不支持使用动态库，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，动态下载代码又是被苹果明令禁止的。</em></strong></p>\n<p><strong>静态链接(static linking)</strong><br>静态连接器就是将项目自身编译好的.o文件集合和一些静态库的.o文件集合进行整合，然后提取出每个.o文件中的用到的一些外部符号引用，并且对这些符号进行重定位，最终生成一个完整的可执行文件。</p>\n<p><strong><em>PS:生成并非是真正的可执行文件，因为此时并不包含一些动态库中的代码，保存的只是一些对外部库中的符号引用。</em></strong></p>\n<p><strong>动态连接(dylb)</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-add412737218082e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forumImage20161207173929050.png\"></p>\n<p>内核初始化环境之后，初始化的dylb环境，由dylb加载一些系统库以及动态库到内存中之后，然后初始化运行时环境，接下来由运行时环境接管，通过运行时环境调用所有class的+load方法。_dylb_start之前的部分属于xnu内核的东西，看不太懂。</p>\n<ul>\n<li><p>动态链接库加载流程</p>\n<ul>\n<li>load dylibs image 读取库镜像文件<ul>\n<li>1.分析所依赖的动态库</li>\n<li>2.找到动态库的mach-o文件</li>\n<li>3.打开文件</li>\n<li>4.验证文件</li>\n<li>5.在系统核心注册文件签名</li>\n<li>6.对动态库的每一个segment调用mmap()</li>\n</ul>\n</li>\n<li>Rebase image</li>\n<li>Bind image</li>\n<li><p>Objc setup</p>\n<ul>\n<li>1.注册Objc类 (class registration)</li>\n<li>2.把category的定义插入方法列表 (category registration)</li>\n<li>3.保证每一个selector唯一 (selctor uniquing）</li>\n</ul>\n</li>\n<li><p>initializers</p>\n<ul>\n<li>1.Objc的+load()函数</li>\n<li>2.C++的构造函数属性函数 形如<strong>attribute</strong>((constructor)) void DoSomeInitializationWork()</li>\n<li>3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在load dylibs image中可以看到dylb去读取镜像文件，加载进内存，并且对Mach-O文件进行解析。而镜像也就是指Mach-O文件。且不同类型的Mach-O文件由不同的ImageLoader子类实例进行加载。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-ba7a0f193fdb7a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forumImage20161207151029417.png\"></p>\n<p>Rebase image和Bind image是对镜像文件进行一些优化计算之类的操作。</p>\n<ul>\n<li>运行时处理+load加载</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-64d6772684462a77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forumImage20161207173728453.png\"></p>\n<p> 运行时初始化的时候，会向dylb注册镜像加载的回调。也就是每当有dylb有新的镜像加载进内场的时候，新的镜像都会被map到runtime中，并且由runtime处理+load的加载。</p>\n<p>利用<a href=\"https://github.com/RetVal\" target=\"_blank\" rel=\"noopener\">https://github.com/RetVal</a> 封装好的 debug 版最新源码可以进行断点调试，就可以看到系统在调用Test类的+load()方法之前的调用栈。打印如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  frame #0: 0x0000000100000f37 debug-objc`+[Test load](self=Test, _cmd=&quot;load&quot;) + 23 at Test.m:13</span><br><span class=\"line\">  frame #1: 0x00000001000b84e6 libobjc.A.dylib`call_class_loads() + 198 at objc-loadmethod.mm:209</span><br><span class=\"line\">  frame #2: 0x00000001000a2a4d libobjc.A.dylib`::call_load_methods() + 77 at objc-loadmethod.mm:361</span><br><span class=\"line\">  frame #3: 0x00000001000a28ba libobjc.A.dylib`::load_images(path=&quot;/Users/xurui/Library/Developer/Xcode/DerivedData/objc-eaekfqpmgbdaycbpoisopskbjiqq/Build/Products/Debug/debug-objc&quot;, mh=0x0000000100000000) + 106 at objc-runtime-new.mm:2051</span><br><span class=\"line\">* frame #4: 0x0000000100007072 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 439</span><br><span class=\"line\">  frame #5: 0x00000001000161dc dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 320</span><br><span class=\"line\">  frame #6: 0x0000000100015268 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 138</span><br><span class=\"line\">  frame #7: 0x00000001000152fd dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 75</span><br><span class=\"line\">  frame #8: 0x000000010000747a dyld`dyld::initializeMainExecutable() + 195</span><br><span class=\"line\">  frame #9: 0x000000010000b7e0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3928</span><br><span class=\"line\">  frame #10: 0x0000000100006249 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 470</span><br><span class=\"line\">  frame #11: 0x0000000100006036 dyld`_dyld_start + 54</span><br></pre></td></tr></table></figure></p>\n<p>4-11步骤主要执行的是_dyld_start的一些初始化操作。<br>主要看0-3步骤。</p>\n<ul>\n<li><p>load_images<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 没有查询到传入 Class 中的 load 方法，视为锁定状态</span><br><span class=\"line\">    // 则无需给其加载权限，直接返回</span><br><span class=\"line\">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class=\"line\">    // 定义可递归锁对象</span><br><span class=\"line\">    // 由于 load_images 方法由 dyld 进行回调，所以数据需上锁才能保证线程安全</span><br><span class=\"line\">    // 为了防止多次加锁造成的死锁情况，使用可递归锁解决</span><br><span class=\"line\">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 收集所有的 +load 方法</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 对 Darwin 提供的线程写锁的封装类</span><br><span class=\"line\">        rwlock_writer_t lock2(runtimeLock);</span><br><span class=\"line\">        // 提前准备好满足 +load 方法调用条件的 Class</span><br><span class=\"line\">        prepare_load_methods((const headerType *)mh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用 +load 方法 (without runtimeLock - re-entrant)</span><br><span class=\"line\">    call_load_methods();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>prepare_load_methods<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void prepare_load_methods(const headerType *mhdr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t count, i;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertWriting();</span><br><span class=\"line\">    // 收集 Class 中的 +load 方法</span><br><span class=\"line\">    // 获取所有的类的列表</span><br><span class=\"line\">    classref_t *classlist = </span><br><span class=\"line\">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class=\"line\">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">        // 通过 remapClass 获取类指针</span><br><span class=\"line\">        // schedul_class_load 递归到父类逐层载入</span><br><span class=\"line\">        schedule_class_load(remapClass(classlist[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 收集 Category 中的 +load 方法</span><br><span class=\"line\">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class=\"line\">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">        category_t *cat = categorylist[i];</span><br><span class=\"line\">        // 通过 remapClass 获取 Category 对象存有的 Class 对象</span><br><span class=\"line\">        Class cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\">        if (!cls) continue;</span><br><span class=\"line\">        // 对类进行第一次初始化，主要用来分配可读写数据空间并返回真正的类结构</span><br><span class=\"line\">        realizeClass(cls);</span><br><span class=\"line\">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class=\"line\">        // 将需要执行 load 的 Category 添加到一个全局列表中</span><br><span class=\"line\">        add_category_to_loadable_list(cat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>call_load_methods()<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void call_load_methods(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 是否已经录入</span><br><span class=\"line\">    static bool loading = NO;</span><br><span class=\"line\">    // 是否有关联的 Category</span><br><span class=\"line\">    bool more_categories;</span><br><span class=\"line\"></span><br><span class=\"line\">    loadMethodLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 由于 loading 是全局静态布尔量，如果已经录入方法则直接退出</span><br><span class=\"line\">    if (loading) return;</span><br><span class=\"line\">    loading = YES;</span><br><span class=\"line\">    // 声明一个 autoreleasePool 对象</span><br><span class=\"line\">    // 使用 push 操作其目的是为了创建一个新的 autoreleasePool 对象</span><br><span class=\"line\">    void *pool = objc_autoreleasePoolPush();</span><br><span class=\"line\"></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        // 重复调用 load 方法，直到没有</span><br><span class=\"line\">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class=\"line\">            call_class_loads();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用 Category 中的 load 方法</span><br><span class=\"line\">        more_categories = call_category_loads();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 继续调用，直到所有 Class 全部完成</span><br><span class=\"line\">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class=\"line\">    // 将创建的 autoreleasePool 对象释放</span><br><span class=\"line\">    objc_autoreleasePoolPop(pool);</span><br><span class=\"line\">    // 更改全局标记，表示已经录入</span><br><span class=\"line\">    loading = NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>call_class_loads()<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void call_class_loads(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 声明下标偏移</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 分离加载的 Class 列表</span><br><span class=\"line\">    struct loadable_class *classes = loadable_classes;</span><br><span class=\"line\">    // 调用标记</span><br><span class=\"line\">    int used = loadable_classes_used;</span><br><span class=\"line\">    loadable_classes = nil;</span><br><span class=\"line\">    loadable_classes_allocated = 0;</span><br><span class=\"line\">    loadable_classes_used = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 调用列表中的 Class 类的 load 方法</span><br><span class=\"line\">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class=\"line\">        // 获取 Class 指针</span><br><span class=\"line\">        Class cls = classes[i].cls;</span><br><span class=\"line\">        // 获取方法对象</span><br><span class=\"line\">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class=\"line\">        if (!cls) continue; </span><br><span class=\"line\"></span><br><span class=\"line\">        if (PrintLoading) &#123;</span><br><span class=\"line\">            _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 方法调用</span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 释放 Class 列表</span><br><span class=\"line\">    if (classes) free(classes);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>+load方法的调用过程，在runtime接收到有dylb有新的镜像加载的回调之后，通过laodImage()将所有的class加载进内存中，并且按照继承结构，递归获取所有class的+load方法，将该class的+load方法添加进一个全局的loadable_classes的结构体中存放，将该class的分类中的+load方法添加一个全局的loadable_categories的结构体中存放。最后通过call_load_methods()函数查找class在内存中对应的结构体中的+load方法，依次执行+load方法的过程。</p>\n<p>参考<br><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\" target=\"_blank\" rel=\"noopener\">https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html</a><br><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\" target=\"_blank\" rel=\"noopener\">http://blog.sunnyxx.com/2014/08/30/objc-pre-main/</a><br><a href=\"https://techblog.toutiao.com/2017/01/17/iosspeed/\" target=\"_blank\" rel=\"noopener\">https://techblog.toutiao.com/2017/01/17/iosspeed/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>前言：<br>甩几个问题出来，答案从问题开始。<br>1.类的+load方法系统是怎么调用的？<br>2.一个类+load方法系统为什么只会调用一次？为什么不能在+load方法中调用super？<br>3.为什么fishhook库只能hook应用挂载的外部动态库里的函数？</p>\n<p>然后这些问题就引出了dylb这个鬼，然后就一脸懵逼了。iOS应用中可执行文件是什么？有那些是可执行文件？动态库是在程序启动后由dylb链接，那么静态库又是什么时候链接的？dylb是通过镜像的形式加载二进制文件的，镜像是什么鬼？运行时环境也是在mian之前初始化的，dylb和运行时环境有没有什么不可描述的关系？</p>\n</blockquote>\n<hr>\n<p><strong>编译-链接-运行</strong><br>源文件–&gt;编译–&gt;目标文件–&gt;（静态链接）链接静态库文件–&gt;生成可执行文件<br>app启动–&gt;加载可执行文件–&gt;（动态链接）链接动态库文件–&gt;初始化运行时环境–&gt;main()</p>","more":"<p><strong>Helloworld</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-838b458845226301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170505_2.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-1447ca6d90136428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170505_4.png\"></p>\n<p>1.分别创建了Foo.h,Foo.m,helloworld.m三个文件<br>2.编译Foo.m和helloworld.m文件，生成Foo.o和helloworld.o两个目标文件<br>3.链接Foundation库，如果不指定默认生成a.out的可执行文件<br>4.执行可执行文件</p>\n<p><strong>Mach-O文件类型</strong></p>\n<ul>\n<li>1.可执行文件（mh_execute）(.app)<br>简单理解为:静态库中所有的.o文件+app编译产生的所有.o文件的集合</li>\n<li>2.动态库（mh_dylib）（.dylib）</li>\n<li>3.包（mh_bundle）(.bundle)<br> 简单理解，就是资源文件包 </li>\n<li>4.静态库（staticlib）(.a/.framework)<br>.a:一堆.o文件的集合<br> .framework：一堆.o文件的集合+资源文件+头文件</li>\n<li>5.可重定位的对象文件（mh_object）(.o)<br>编译后，每一个.m/.c/.mm等文件都会生成为一种.o格式的目标文件。</li>\n</ul>\n<p><strong>Mach-O文件结构</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-459b57d7460696ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680\" alt=\"Mach-O文件结构.png\"></p>\n<ul>\n<li>1.标题:指定文件的目标体系结构，如PPC，PPC64，IA-32或x86-64。</li>\n<li>2.加载命令：在虚拟内存中指定文件的逻辑结构和文件的布局。</li>\n<li>3.原始段数据：包含在加载命令中定义的段的原始数据。</li>\n</ul>\n<p><strong>静态库（.a /.framework）</strong><br>链接时期由静态链接器将静态库中的.o文件完整复制到可执行文件中。</p>\n<p><strong><em>PS:CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考这里，或者使用CocoasPods-Packager这个插件。（所以每次pod install后，特么编译项目都贼慢，为毛，因为编译器需要编译项目本身代码+各自pod库中的代码，最后将pod库中的代码生成.a文件。然后再编译就会快很多啊，因为编译时期就没有编译pod库了，而是直接连接一个个pod的.a库）</em></strong></p>\n<p><strong>动态库(.dylib/.framework)</strong><br>由dylb动态加载进内存。且多个app共享一份动态库，动态库基本上都是由系统提供。<br>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。</p>\n<p><strong><em>PS:iOS 平台不支持使用动态库，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，动态下载代码又是被苹果明令禁止的。</em></strong></p>\n<p><strong>静态链接(static linking)</strong><br>静态连接器就是将项目自身编译好的.o文件集合和一些静态库的.o文件集合进行整合，然后提取出每个.o文件中的用到的一些外部符号引用，并且对这些符号进行重定位，最终生成一个完整的可执行文件。</p>\n<p><strong><em>PS:生成并非是真正的可执行文件，因为此时并不包含一些动态库中的代码，保存的只是一些对外部库中的符号引用。</em></strong></p>\n<p><strong>动态连接(dylb)</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-add412737218082e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forumImage20161207173929050.png\"></p>\n<p>内核初始化环境之后，初始化的dylb环境，由dylb加载一些系统库以及动态库到内存中之后，然后初始化运行时环境，接下来由运行时环境接管，通过运行时环境调用所有class的+load方法。_dylb_start之前的部分属于xnu内核的东西，看不太懂。</p>\n<ul>\n<li><p>动态链接库加载流程</p>\n<ul>\n<li>load dylibs image 读取库镜像文件<ul>\n<li>1.分析所依赖的动态库</li>\n<li>2.找到动态库的mach-o文件</li>\n<li>3.打开文件</li>\n<li>4.验证文件</li>\n<li>5.在系统核心注册文件签名</li>\n<li>6.对动态库的每一个segment调用mmap()</li>\n</ul>\n</li>\n<li>Rebase image</li>\n<li>Bind image</li>\n<li><p>Objc setup</p>\n<ul>\n<li>1.注册Objc类 (class registration)</li>\n<li>2.把category的定义插入方法列表 (category registration)</li>\n<li>3.保证每一个selector唯一 (selctor uniquing）</li>\n</ul>\n</li>\n<li><p>initializers</p>\n<ul>\n<li>1.Objc的+load()函数</li>\n<li>2.C++的构造函数属性函数 形如<strong>attribute</strong>((constructor)) void DoSomeInitializationWork()</li>\n<li>3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在load dylibs image中可以看到dylb去读取镜像文件，加载进内存，并且对Mach-O文件进行解析。而镜像也就是指Mach-O文件。且不同类型的Mach-O文件由不同的ImageLoader子类实例进行加载。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-ba7a0f193fdb7a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forumImage20161207151029417.png\"></p>\n<p>Rebase image和Bind image是对镜像文件进行一些优化计算之类的操作。</p>\n<ul>\n<li>运行时处理+load加载</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-64d6772684462a77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"forumImage20161207173728453.png\"></p>\n<p> 运行时初始化的时候，会向dylb注册镜像加载的回调。也就是每当有dylb有新的镜像加载进内场的时候，新的镜像都会被map到runtime中，并且由runtime处理+load的加载。</p>\n<p>利用<a href=\"https://github.com/RetVal\" target=\"_blank\" rel=\"noopener\">https://github.com/RetVal</a> 封装好的 debug 版最新源码可以进行断点调试，就可以看到系统在调用Test类的+load()方法之前的调用栈。打印如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  frame #0: 0x0000000100000f37 debug-objc`+[Test load](self=Test, _cmd=&quot;load&quot;) + 23 at Test.m:13</span><br><span class=\"line\">  frame #1: 0x00000001000b84e6 libobjc.A.dylib`call_class_loads() + 198 at objc-loadmethod.mm:209</span><br><span class=\"line\">  frame #2: 0x00000001000a2a4d libobjc.A.dylib`::call_load_methods() + 77 at objc-loadmethod.mm:361</span><br><span class=\"line\">  frame #3: 0x00000001000a28ba libobjc.A.dylib`::load_images(path=&quot;/Users/xurui/Library/Developer/Xcode/DerivedData/objc-eaekfqpmgbdaycbpoisopskbjiqq/Build/Products/Debug/debug-objc&quot;, mh=0x0000000100000000) + 106 at objc-runtime-new.mm:2051</span><br><span class=\"line\">* frame #4: 0x0000000100007072 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 439</span><br><span class=\"line\">  frame #5: 0x00000001000161dc dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 320</span><br><span class=\"line\">  frame #6: 0x0000000100015268 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 138</span><br><span class=\"line\">  frame #7: 0x00000001000152fd dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 75</span><br><span class=\"line\">  frame #8: 0x000000010000747a dyld`dyld::initializeMainExecutable() + 195</span><br><span class=\"line\">  frame #9: 0x000000010000b7e0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3928</span><br><span class=\"line\">  frame #10: 0x0000000100006249 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 470</span><br><span class=\"line\">  frame #11: 0x0000000100006036 dyld`_dyld_start + 54</span><br></pre></td></tr></table></figure></p>\n<p>4-11步骤主要执行的是_dyld_start的一些初始化操作。<br>主要看0-3步骤。</p>\n<ul>\n<li><p>load_images<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 没有查询到传入 Class 中的 load 方法，视为锁定状态</span><br><span class=\"line\">    // 则无需给其加载权限，直接返回</span><br><span class=\"line\">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class=\"line\">    // 定义可递归锁对象</span><br><span class=\"line\">    // 由于 load_images 方法由 dyld 进行回调，所以数据需上锁才能保证线程安全</span><br><span class=\"line\">    // 为了防止多次加锁造成的死锁情况，使用可递归锁解决</span><br><span class=\"line\">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 收集所有的 +load 方法</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 对 Darwin 提供的线程写锁的封装类</span><br><span class=\"line\">        rwlock_writer_t lock2(runtimeLock);</span><br><span class=\"line\">        // 提前准备好满足 +load 方法调用条件的 Class</span><br><span class=\"line\">        prepare_load_methods((const headerType *)mh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用 +load 方法 (without runtimeLock - re-entrant)</span><br><span class=\"line\">    call_load_methods();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>prepare_load_methods<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void prepare_load_methods(const headerType *mhdr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t count, i;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertWriting();</span><br><span class=\"line\">    // 收集 Class 中的 +load 方法</span><br><span class=\"line\">    // 获取所有的类的列表</span><br><span class=\"line\">    classref_t *classlist = </span><br><span class=\"line\">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class=\"line\">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">        // 通过 remapClass 获取类指针</span><br><span class=\"line\">        // schedul_class_load 递归到父类逐层载入</span><br><span class=\"line\">        schedule_class_load(remapClass(classlist[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 收集 Category 中的 +load 方法</span><br><span class=\"line\">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class=\"line\">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">        category_t *cat = categorylist[i];</span><br><span class=\"line\">        // 通过 remapClass 获取 Category 对象存有的 Class 对象</span><br><span class=\"line\">        Class cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\">        if (!cls) continue;</span><br><span class=\"line\">        // 对类进行第一次初始化，主要用来分配可读写数据空间并返回真正的类结构</span><br><span class=\"line\">        realizeClass(cls);</span><br><span class=\"line\">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class=\"line\">        // 将需要执行 load 的 Category 添加到一个全局列表中</span><br><span class=\"line\">        add_category_to_loadable_list(cat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>call_load_methods()<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void call_load_methods(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 是否已经录入</span><br><span class=\"line\">    static bool loading = NO;</span><br><span class=\"line\">    // 是否有关联的 Category</span><br><span class=\"line\">    bool more_categories;</span><br><span class=\"line\"></span><br><span class=\"line\">    loadMethodLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 由于 loading 是全局静态布尔量，如果已经录入方法则直接退出</span><br><span class=\"line\">    if (loading) return;</span><br><span class=\"line\">    loading = YES;</span><br><span class=\"line\">    // 声明一个 autoreleasePool 对象</span><br><span class=\"line\">    // 使用 push 操作其目的是为了创建一个新的 autoreleasePool 对象</span><br><span class=\"line\">    void *pool = objc_autoreleasePoolPush();</span><br><span class=\"line\"></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        // 重复调用 load 方法，直到没有</span><br><span class=\"line\">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class=\"line\">            call_class_loads();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用 Category 中的 load 方法</span><br><span class=\"line\">        more_categories = call_category_loads();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 继续调用，直到所有 Class 全部完成</span><br><span class=\"line\">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class=\"line\">    // 将创建的 autoreleasePool 对象释放</span><br><span class=\"line\">    objc_autoreleasePoolPop(pool);</span><br><span class=\"line\">    // 更改全局标记，表示已经录入</span><br><span class=\"line\">    loading = NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>call_class_loads()<br>源码解读：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void call_class_loads(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 声明下标偏移</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 分离加载的 Class 列表</span><br><span class=\"line\">    struct loadable_class *classes = loadable_classes;</span><br><span class=\"line\">    // 调用标记</span><br><span class=\"line\">    int used = loadable_classes_used;</span><br><span class=\"line\">    loadable_classes = nil;</span><br><span class=\"line\">    loadable_classes_allocated = 0;</span><br><span class=\"line\">    loadable_classes_used = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 调用列表中的 Class 类的 load 方法</span><br><span class=\"line\">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class=\"line\">        // 获取 Class 指针</span><br><span class=\"line\">        Class cls = classes[i].cls;</span><br><span class=\"line\">        // 获取方法对象</span><br><span class=\"line\">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class=\"line\">        if (!cls) continue; </span><br><span class=\"line\"></span><br><span class=\"line\">        if (PrintLoading) &#123;</span><br><span class=\"line\">            _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 方法调用</span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 释放 Class 列表</span><br><span class=\"line\">    if (classes) free(classes);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>+load方法的调用过程，在runtime接收到有dylb有新的镜像加载的回调之后，通过laodImage()将所有的class加载进内存中，并且按照继承结构，递归获取所有class的+load方法，将该class的+load方法添加进一个全局的loadable_classes的结构体中存放，将该class的分类中的+load方法添加一个全局的loadable_categories的结构体中存放。最后通过call_load_methods()函数查找class在内存中对应的结构体中的+load方法，依次执行+load方法的过程。</p>\n<p>参考<br><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\" target=\"_blank\" rel=\"noopener\">https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html</a><br><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\" target=\"_blank\" rel=\"noopener\">http://blog.sunnyxx.com/2014/08/30/objc-pre-main/</a><br><a href=\"https://techblog.toutiao.com/2017/01/17/iosspeed/\" target=\"_blank\" rel=\"noopener\">https://techblog.toutiao.com/2017/01/17/iosspeed/</a></p>"},{"layout":"post","title":"AtomSDK分享（安全模式及crash保护）","date":"2017-08-19T12:44:00.000Z","_content":"![Atom.jpg](http://upload-images.jianshu.io/upload_images/1488967-4b6a2f23f722bb43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450)\n\n> 前言：\n> APP的Crash率一直是评估app稳定性的一个重要指标，也是程序员的噩梦。每次提测之前跑完用例，都是信誓旦旦的\"放心，代码不可能存在bug。\"。在iOS还存在热补丁的时候，大部分iOS程序狗都有过半夜写着JSPatch代码的体验，那个时候确实可以做到不存在bug。然而热补丁被苹果大大封杀了，我们就开始焦虑了。KPI怎么搞？问题来了，如果App出现不可挽救的闪退怎么办？比如启动就崩溃，随便点点就闪退。怎么办？怎么办？怎么办？\n\n<!-- more -->\n\n## 开发目的\n\n主要的动机有2点。\n\n一是为了防止app在启动时期crash的情况发生，因为这种crash一旦产生必然会使得app陷入无法启动的绝境。\n\n另一个是为了降低运行时期app的crash率，主要是利用oc的动态特性，通过切面编程，使得业务层在无感知的情况下，app能够在运行时期自动捕获异常，修复异常，从而避免crash的出现。\n\n## 功能简介\n\n> 功能主要分为两个模块\n\n### 安全模式\n\n冷启动时期内程序能够检测连续闪退，在出现连续闪退时，能够进行自我修复，一共分为三级保护，触发一级保护时会删除沙盒中的一些网络数据的缓存。二级保护则会删除沙盒中的rn包以及一些资源文件。三级保护会去清空沙盒，从而使得app进入一种初始化状态。\n\n### 进程守护\n\n* 1.unrecognized selector crash\n* 2.KVO crash\n* 3.NSNotification crash\n* 4.NSTimer crash\n* 5.Container crash（常见集合类crash等）\n* 6.NSNull crash \n* 7.Bad Access crash （野指针）\n* 8.UI not on Main Thread Crash (非主线程刷UI）\n\n### 日志上报\n\n## 技术实现\n\n### 安全模式\n\napp在启动时期会执行一系列的初始化操作，例如：\n\n* 协议注册\n * 配置接口\n * RN加载\n * 相关配置信息读取，环境变量配置\n * 本地数据缓存读取\n * ......\n\n\n实现逻辑：\n![安全模式.png](http://upload-images.jianshu.io/upload_images/1488967-3afff57c83997764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n1、开始检测\n一般来说，应用启动一般是在appDelegate里的didFinishLaunchingWithOptions方法回调里搞事情。\n可是发现自家的写代码喜欢在+load方法里搞。且+load方法的执行是在main函数之前，那么问题就来了， 无法保证+load方法里产生的一些异常也能够被检测到。为了避免这种情况，需要把安全检测的逻辑放在+load方法里，且被系统调度的优先级比较高。好在，+load方法是有过处理，大致实现思路是在系统调用到+load方法的时候，使用block来封装load方法里的逻辑，添加进一个全局的数组中，优先级设置是通过对全局数组排序事项的，最后在相应的时刻从该数组中取出block并执行。调用时机分别为以下三个：\n* mian函数执行之前\n* didFinishLaunch\n* didFinishLaunch之后\n\n例如：\n```\n+(void)load {\n    imy_load_main(IMYLoadAtPreMain, 0, ^{\n        [IMYBootingProtectionManager shareBootingProtectionManager];\n    });\n}\n```\n2、异常捕获\n异常捕获，坑点太多，iOS系统允许我们去捕获mach级别和应用级别的异常。应用层的异常需要我们自己去注册一个异常捕获函数，但是一些三方sdk经常会注册该函数（例如友盟，bugly等），就会存在问题。前面注册的会被后面注册覆盖。你需要去写一些兼容代码。且自家的应用接入友盟，bugly这种三方统计的sdk。\n通过hook NSSetUncaughtExceptionHandler这个函数（ [传送门](http://www.cocoachina.com/ios/20150701/12301.html)），清晰看到了app分别注册了三个handler，自己注册的，友盟注册的和bugly注册的。发生异常的时候，最终都被bugly的给拦截了。而进入到自己注册的异常处理函数。\nQ:友盟是怎么统计到的？\nA:这就很尴尬了。发现当bugly检测到异常，它会把该异常同时上报给友盟。\n所以为了取巧，监控异常这部分通过初始化，由外部传入异常回调的函数从而达到监控异常的目的。\n```\n  imy_load_main(IMYLoadAtPreMain, 0, ^{\n        // 注册安全模式\n        [[IMY_AtomSDK shareInstance] regiterCrashProtectService];\n        // 异常捕获回调   \n        [[IMYAppReport shareInstance] addCrashReportLog:^NSString *_Nonnull(NSException *_Nonnull exception) {\n            [[IMY_AtomSDK shareInstance] regiterSafeModeService];\n            return nil;\n        }];\n    });\n\n```\n\n3、如何安全检测？\n既然保证了app在启动之前都会进入安全模式。进入该模式的时候，首先会维护一个闪退计数器，并且开启一个定时任务，若在该时间段了，app没有检测到任何异常发生，则会将该计数器清0。若检测到了闪退，则将该计数器+1。逻辑见上图。\n\n4、如何修复程序？\n进入安全模式，获取闪退计数，在这里分别设置了三级保护措施，当闪退技术>=2的时候，则会进入三级修复，会删除沙盒里的接口数据缓存文件。当闪退技术>=3的时候，会删除接口数据缓存，同时也会删除JSpatch和RN的包。当闪退技术>=5的时候，则会清空整个沙盒。修复完成之后，则会将闪退计数置为0。而应用则会恢复到初始状态。逻辑见上图。\n\n### 进程守护\n\n#### 1、UI_Protect\n\n闪退场景：\niOS 上不建议在非主线程进行UI操作，在非主线程进行UI操作有很大几率会导致程序崩溃，或者出现预期之外的效果。\n\n实现思路：\n通过Hook UIView类和CALayer类的一些方法来避免在非主线程执行UI操作。\n```\nUIView\n1.setNeedsLayout\n2.setNeedsDisplay\n3.setNeedsUpdateConstraints\n4.setNeedsDisplayInRect:\n\nCALayer\n1.setNeedsLayout\n2.setNeedsDisplay\n3.setNeedsDisplayInRect:\n```\n\n核心代码：\n```\n判断是否在主线程，不在则转移到主线程执行\n if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) {\n                                            // 调用原来的方法\n                                        } else {\n                                            dispatch_async(dispatch_get_main_queue(), ^{\n                                                 // 调用原来的方法\n                                            });\n                                        }\n```\n#### 2、NSTimer_Protect\n\n闪退场景：\nNSTimer这个鬼使用的时候，需要非常小心，最常见的两个坑。\n1.NSTimer会对target对象进行强引用，容易出现reatain circle。导致target无法释放，从而产生内存泄露。\n2.在使用scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:做一个重复的定时任务的时候， repeats参数设置为YES，在你不需要的时候，要你手动调用invalidate来销毁定时器。因为定时器会被放进Runloop中，如果target对象释放了之后，Runloop触发了定时器的定时任务，会因为找不到target对象而引起crash。\n\n实现思路：\n![Snip20170918_29.png](http://upload-images.jianshu.io/upload_images/1488967-2bf0a205872b5708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n主要解决两个问题：\n1.NSTimer对Target的强引用\n![Snip20170918_33.png](http://upload-images.jianshu.io/upload_images/1488967-4bdef0bcb66acd4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.自动invalidate的NSTimer\n\n![Snip20170918_34.png](http://upload-images.jianshu.io/upload_images/1488967-02cbd5ccfff260c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n核心代码：\n```\n1.hook\n static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        RSSwizzleClassMethod([NSTimer class], @selector(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:), RSSWReturnType(NSTimer *), RSSWArguments(NSTimeInterval ti, id aTarget, SEL aSelector, id userInfo, BOOL yesOrNo), RSSWReplacement({\n                                 if (!_NSTimerCrashProtectEnable) {\n                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);\n                                 }\n                                 NSTimer *timer = nil;\n                                 if (yesOrNo) {\n                                     @autoreleasepool {\n                                         IMY_TimerStubProxy *proxy = [[IMY_TimerStubProxy alloc] init];\n                                         proxy.target = aTarget;\n                                         proxy.aSelector = aSelector;\n                                         timer.timerProxy = proxy;\n                                         timer = RSSWCallOriginal(ti, proxy, @selector(fireProxyTimer:), userInfo, yesOrNo);\n                                         proxy.sourceTimer = timer;\n                                     }\n                                     return timer;\n                                 } else {\n                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);\n                                 }\n                                 return nil;\n                             }));\n        _NSTimerCrashProtectEnable = YES;\n    });\n\n2. fireProxyTimer：\n- (void)fireProxyTimer:(id)userinfo\n{\n    id strongTarget = self.target;\n    if (strongTarget && ([strongTarget respondsToSelector:self.aSelector])) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n        [strongTarget performSelector:self.aSelector\n                           withObject:userinfo];\n#pragma clang diagnostic pop\n\n    } else {\n        if (self.sourceTimer) {\n            [self.sourceTimer invalidate];\n        }\n        NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]: Target is <%@> Method is <%@>, reason : an object dealloc not invalidate Timer.\",\n                                                      [self class], NSStringFromSelector(self.aSelector)];\n        NSLog(@\"%@\", reason);\n    }\n}\n\n\n```\n#### 3、NSNull_Protect\n\n闪退场景：\niOS中数组，字典等一些集合类，元素只能为OC对象，所以只能用NSNull来填空。在做数据解析的时候，经常遇到服务端返回的数据中带有null这种鬼，会被解析成NSNull这种对象。稍微不注意类型保护就会发生闪退。\n\n实现思路：\nhook NSNull类的forwardingTargetForSelector:，将一些无法识别的消息发送给一些可以识别的集合类。\n\n核心代码：\n```\n RSSwizzleInstanceMethod([NSNull class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement({\n\n                                    if (!_NSNullCrashProtectEnable) {\n                                        return RSSWCallOriginal(aSelector);\n                                    }\n                                    static NSArray *sTmpOutput = nil;\n                                    if (sTmpOutput == nil) {\n                                        sTmpOutput = @[@\"\", @0, @[], @{}];\n                                    }\n\n                                    for (id tmpObj in sTmpOutput) {\n                                        if ([tmpObj respondsToSelector:aSelector]) {\n                                            return tmpObj;\n                                        }\n                                    }\n                                    return RSSWCallOriginal(aSelector);\n                                }),\n                                RSSwizzleModeAlways, nil);\n```\n\n#### 4、NSNotification_Protect\n\n闪退场景：\n在iOS9之前，通过addObserver:selector:name:object:监听通知。NSNotificatinonCenter会对观察者进行强引用，所以需要手动的在观察者对象挂了的时候移除通知监听。如果未移除监听，在观察者被释放的之后仍然会接收到通知那么就会发生闪退。\n\n实现思路：\n主要是hook NSNotificationCenter的addObserver:selector:name:object:，凡是有添加过通知监听的对象，都会给该对象设置一个标识。在dealloc的hook中，判断需要释放的对象，是否有注册过通知监听，是则去移除通知。\n\n#### 5、UnrecognizedSelector_Protect\n\n闪退场景：\n天天见。\n![Snip20170925_22.png](http://upload-images.jianshu.io/upload_images/1488967-19552be78073a7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900)\n\n实现思路：\n由于OC是一门动态类型的语言，它的方法调用其实是一种动态绑定的机制，也就是说方法调用是直到运行期才去确定的。\n方法在调用时，系统会查看这个对象能否接收这个消息（查看这个类有没有这个方法，或者有没有实现这个方法。），牛逼的是，如果不能并且只在不能的情况下，就会调用下面这几个方法，给你“补救”的机会，你可以理解为几套防止程序crash的备选方案，苹果就是利用这几个方案进行消息转发，前一套方案实现后一套方法就不会执行。如果这几套方案你都没有做处理，那么程序就会报错crash。\n完整的消息转发的流程如下：\n![Snip20170925_23.png](http://upload-images.jianshu.io/upload_images/1488967-c0794df51a9ec109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n主要是通过hook NSObject类的forwardingTargetForSelector：实例方法以及类方法。在该方法中将一些无法识别的方法，发送给一个stubProxy对象，且在运行时动态的给改stubProxy对象添加改SEL对应的方法实现(IMP)。\n\n![Snip20170920_5.png](http://upload-images.jianshu.io/upload_images/1488967-b68da4e515176f62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n核心代码：\n```\n    RSSwizzleInstanceMethod([NSObject class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement({\n                                    if (!_UnrecognizedSelectorCrashProtectEnable) {\n                                        return RSSWCallOriginal(aSelector);\n                                    }\n\n                                    BOOL aBool = [self respondsToSelector:aSelector];\n                                    // 获取消息签名\n                                    NSMethodSignature *signatrue = [self methodSignatureForSelector:aSelector];\n\n                                    if (aBool || signatrue) {\n                                        return RSSWCallOriginal(aSelector);\n                                    } else {\n                                        IMY_UnrecognizedSelector_StubProxy *stub = [[IMY_UnrecognizedSelector_StubProxy alloc] init];\n                                        [stub addFunc:aSelector];\n                                        NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]: unrecognizedSelector <%@> to instance <%@>\",\n                                                                                      NSStringFromSelector(aSelector), [self class]];\n                                        NSLog(@\"%@\", reason);\n                                        return stub;\n                                    }\n\n                                }),\n                                RSSwizzleModeAlways, nil);\n```\n\n#### 6、KVO_Protect\n\nKVO 是 Objective-C 对观察者设计模式的一种实现。观察对象(例如A类)，当对象某个属性(例如A中的字符串name)发生更改时，监听对象会获得通知，并作出相应处理。且不需要给被观察的对象添加任何额外代码，就能使用的一种观察者模式。\n\n闪退场景：\n* 1.被观察者提前释放\n```\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x600000018180 of class Student was deallocated while key value observers were still registered with it. Current observation info: <NSKeyValueObservationInfo 0x600000032340> (\n<NSKeyValueObservance 0x600000054d60: Observer: 0x7fe684608b40, Key path: name, Options: <New: YES, Old: YES, Prior: NO> Context: 0x0, Property: 0x60000005cb00>\n)'\n```\n* 2.被观察者是局部变量\n* 3.重复移除观察者 \n```\n*** Terminating app due to uncaught exception 'NSRangeException', reason: 'Cannot remove an observer <TestViewController 0x7fdb13e0cf40> for the key path \"view\" from < TestViewController 0x7fdb13e0cf40> because it is not registered as an observer.'\n```\n* 4.观察者对象未实现observeValueForKeyPath:ofObject: change: context:方法\n```\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '< TestViewController: 0x7fc628f049e0>: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.\nKey path: view\nObserved object: < TestViewController: 0x7fc628f049e0>\nChange: {\n    kind = 1;\n    new = \"<UIView: 0x7fc628d18810; frame = (0 0; 414 736); layer = <CALayer: 0x60800002be00>>\";\n}\nContext: 0x0'\n```\nps:重复添加观察者并不会引起crash，但是会多次触发相应事件。\n\n\n实现思路：\n主要通过NSObject的分类，利用运行时给NSObject实例添加一个关联对象kvoProxy，该对象是用于管理当前对象的kvo关系(也就是观察者和被观察者的关系)，分别hook addObserver:forKeyPath:options:context:和removeObserver:forKeyPath:以及dealloc方法，在dealloc中移除真正的观察者对象。\n\n![addObserver:forKeyPath:options:context:](http://upload-images.jianshu.io/upload_images/1488967-65735d525724bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![removeObserver:forKeyPath](http://upload-images.jianshu.io/upload_images/1488967-72f9a4e0eb982742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n核心代码：\n```\n    RSSwizzleInstanceMethod([NSObject class], @selector(addObserver:forKeyPath:options:context:), RSSWReturnType(void), RSSWArguments(NSObject * observer, NSString * keyPath, NSKeyValueObservingOptions options, void *context), RSSWReplacement({\n                                // 忽略RAC\n                                if (object_getClass(observer) == objc_getClass(\"RACKVOProxy\")) {\n                                    RSSWCallOriginal(observer, keyPath, options, context);\n                                    return;\n                                }\n                                NSHashTable<NSObject *> *os = [self kvoProxy].kvoInfoMap[keyPath];\n                                // 第一次的时候将KVOProxy添加为真正的观察者\n                                if (os.count == 0) { // (包括了 observers == nil 和 count == 0)\n                                    os = [[NSHashTable alloc] initWithOptions:(NSPointerFunctionsWeakMemory)capacity:0];\n                                    [os addObject:observer];\n                                    RSSWCallOriginal([self kvoProxy], keyPath, options, context);\n                                    [self kvoProxy].kvoInfoMap[keyPath] = os;\n                                    return;\n                                }\n\n                                if ([os containsObject:observer]) {\n                                    // 找到同样的观察者 不重复添加\n                                    NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]:KVO add Observer to many timers.Target is %@ method is %@ \",\n                                                                                  [self class], NSStringFromSelector(@selector(addObserver:forKeyPath:options:context:))];\n                                    NSLog(@\"%@\", reason);\n\n                                } else {\n                                    // 以后添加观察者直接往容器里面更新元素就行了\n                                    [os addObject:observer];\n                                }\n                            }),\n                            RSSwizzleModeAlways, nil);\n\n    [RSSwizzle swizzleInstanceMethod:@selector(removeObserver:forKeyPath:)\n                             inClass:[NSObject class]\n                       newImpFactory:^id(RSSwizzleInfo *swizzleInfo) {\n                           return ^void(__unsafe_unretained id self, NSObject *observer, NSString *keyPath) {\n\n\n                               int (*originalIMP)(__unsafe_unretained id, SEL, NSObject *, NSString *);\n                               originalIMP = (__typeof(originalIMP))[swizzleInfo getOriginalImplementation];\n                               __imy_hook_orgin_function_removeObserver = originalIMP;\n\n\n                               if (object_getClass(observer) == objc_getClass(\"RACKVOProxy\")) {\n                                   originalIMP(self, @selector(removeObserver:forKeyPath:), observer, keyPath);\n                                   return;\n                               }\n\n                               NSHashTable<NSObject *> *os = [self kvoProxy].kvoInfoMap[keyPath];\n                               if (os.count == 0) {\n                                   // 未找到观察者\n                                   NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]: KVO remove Observer to many times.target is %@ method is %@,\",\n                                                                                 [self class], NSStringFromSelector(@selector(removeObserver:forKeyPath:))];\n                                   NSLog(@\"[KVO]:%@\", reason);\n\n                                   return;\n                               }\n                               // 找到了观察者 移除\n                               [os removeObject:observer];\n                               // 为空时移除真正的观察者\n                               if (os.count == 0) {\n                                   //                                   NSLog(@\"[KVO]:REMOVE【%@】-【%@】-【%@】\",self,observer,keyPath);\n                                   originalIMP(self, @selector(removeObserver:forKeyPath:), [self kvoProxy], keyPath);\n                                   [[self kvoProxy].kvoInfoMap removeObjectForKey:keyPath];\n                               }\n                           };\n                       }\n                                mode:RSSwizzleModeAlways\n                                 key:NULL];\n\n```\n#### 7、BadAccess_Protect\n\niOS中有空指针和野指针两种概念。空指针是没有存储任何内存地址的指针。如Student *s1 = NULL;和Student *s2 = nil;而野指针是指指向一个已删除的对象（”垃圾”内存既不可用内存）或未申请访问受限内存区域的指针。野指针是比较危险的。因为野指针指向的对象已经被释放了。通过野指针访问已经释放的对象crash其实不是必现的，因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。\nBTW野指针的崩溃是比较随机的，你在测试的时候可能没发生crash，但是用户在使用的时候就可能发生crash了。\n\n闪退场景：\n野指针闪退常见有以下几种情况：\n1.对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。\n2.对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。\n3.对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。\n4.对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。\n5.对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）！！\n6.对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。\n![1467690258548317-1.gif](http://upload-images.jianshu.io/upload_images/1488967-f460ae871ef8b723.gif?imageMogr2/auto-orient/strip)\n\n\n实现思路：\n\n在app的当前进程中，如果我们额外向系统申请一块内存，用于存储那些已经被释放的对象。所以当一个对象被释放了时候，系统就会自动调用该对象的dealloc方法，在这个方法里面系统会释放该对象自身的一些属性，关联对象等等一些资源。然后，我们利用isa指针混淆技术，将该对象的类动态修改为一个僵尸类，且该僵尸对象可以处理任何方法。那么如果你向一个已经被释放的对象发送消息的时候，因为它存在于缓存池当中，那么也就不会产生野指针了。\n\n首先我们需要知道dealloc的方法里面系统干了些什么事儿。\n因为OC中内存管理采用的是引用计数器的方式，即每个对象的散列表中都会存在一个int类型的变量表示该对象的被引用的次数，当该对象的引用计数为0的时候，由系统自动调用该对象的dealloc方法释放该对象的内存。并且父类的dealloc的方法将在子类dealloc方法返回后自动调用。（PS:你在跟我讲故事么。）\n\n通过查看Apple的runtime源码，可以看出ARC下的dealloc的实现原理。\n```\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj)\n{\n    assert(obj);\n\n    obj->rootDealloc();\n}\n\ninline void objc_object::rootDealloc()\n{\n    if (isTaggedPointer()) return;\n    object_dispose((id)this);\n}\n\nid object_dispose(id obj) \n{\n    if (UseGC) return _object_dispose(obj);\n    else return (*_dealloc)(obj); \n}\n\nstatic id _object_dispose(id anObject) \n{\n    if (anObject==nil) return nil;\n\n    objc_destructInstance(anObject);\n    \n#if SUPPORT_GC\n    if (UseGC) {\n        auto_zone_retain(gc_zone, anObject); // gc free expects rc==1\n    } else \n#endif\n    {\n        // only clobber isa for non-gc\n        anObject->initIsa(_objc_getFreedObjectClass ()); \n    }\n    free(anObject);\n    return nil;\n}\n```\n这里能够清晰地看到在执行dealloc的时候，会先执行_objc_rootDealloc()函数。然后执行_object_dispose()，且在这个函数里干了三件事情：\n* 1.调用objc_destructInstance()释放对象的所有实例变量和关联对象(该方法并未回收对象本身内存).\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = !UseGC && obj->hasAssociatedObjects();\n        bool dealloc = !UseGC;\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        if (dealloc) obj->clearDeallocating();\n    }\n    return obj;\n}\n```\n* 2.isa-swizzling将该对象的类置为一个空的类对象.\n* 3.调用free()回收该对象的内存.\n\n所以我们需要在对象真正被释放的时机搞事情，有三个选择：\n* 1.运行时hook NSObject的dealloc方法。\n* 2.runtime object_dispose 。\n* 3.利用fishhook c的free()。\n  这三个调用栈顺序依次dealloc->object_dispose->free。所以还是选择hook最上层dealloc方法。主要针对OC对象的野指针。\n  流程图如下：\n  ![Snip20170929_35.png](http://upload-images.jianshu.io/upload_images/1488967-4d3a9e5d5c875e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/h/800)\n\n\n核心代码：\n```\n- (void)IMY_BadAccess_dealloc {\n    NSObject *obj = (NSObject *)self;\n    objc_destructInstance(self);\n    object_setClass(self, [_IMYZombieObj class]);\n    obj.oriClass = NSStringFromClass([self class]);\n    dispatch_async(zombieOperationQueue, ^{\n        if (global_unfree_list->unfree_count > MAX_UNFREE_POINTER * 0.9 || global_unfree_list->unfree_size > MAX_UNFREE_MEM) {\n            freeMemInListSync(global_unfree_list, FREE_POINTER_NUM);\n        }\n        addUnFreeMemToListSync(global_unfree_list, (__bridge void *)(self));\n    });\n}\n```\n","source":"_posts/iOS-04.md","raw":"---\nlayout: post\ntitle: \"AtomSDK分享（安全模式及crash保护）\"\ndate: 2017-08-19 20:44\ncategories: \n- 技术\n- [技术, iOS]\ntags: \n- 技术\n- iOS\n---\n![Atom.jpg](http://upload-images.jianshu.io/upload_images/1488967-4b6a2f23f722bb43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450)\n\n> 前言：\n> APP的Crash率一直是评估app稳定性的一个重要指标，也是程序员的噩梦。每次提测之前跑完用例，都是信誓旦旦的\"放心，代码不可能存在bug。\"。在iOS还存在热补丁的时候，大部分iOS程序狗都有过半夜写着JSPatch代码的体验，那个时候确实可以做到不存在bug。然而热补丁被苹果大大封杀了，我们就开始焦虑了。KPI怎么搞？问题来了，如果App出现不可挽救的闪退怎么办？比如启动就崩溃，随便点点就闪退。怎么办？怎么办？怎么办？\n\n<!-- more -->\n\n## 开发目的\n\n主要的动机有2点。\n\n一是为了防止app在启动时期crash的情况发生，因为这种crash一旦产生必然会使得app陷入无法启动的绝境。\n\n另一个是为了降低运行时期app的crash率，主要是利用oc的动态特性，通过切面编程，使得业务层在无感知的情况下，app能够在运行时期自动捕获异常，修复异常，从而避免crash的出现。\n\n## 功能简介\n\n> 功能主要分为两个模块\n\n### 安全模式\n\n冷启动时期内程序能够检测连续闪退，在出现连续闪退时，能够进行自我修复，一共分为三级保护，触发一级保护时会删除沙盒中的一些网络数据的缓存。二级保护则会删除沙盒中的rn包以及一些资源文件。三级保护会去清空沙盒，从而使得app进入一种初始化状态。\n\n### 进程守护\n\n* 1.unrecognized selector crash\n* 2.KVO crash\n* 3.NSNotification crash\n* 4.NSTimer crash\n* 5.Container crash（常见集合类crash等）\n* 6.NSNull crash \n* 7.Bad Access crash （野指针）\n* 8.UI not on Main Thread Crash (非主线程刷UI）\n\n### 日志上报\n\n## 技术实现\n\n### 安全模式\n\napp在启动时期会执行一系列的初始化操作，例如：\n\n* 协议注册\n * 配置接口\n * RN加载\n * 相关配置信息读取，环境变量配置\n * 本地数据缓存读取\n * ......\n\n\n实现逻辑：\n![安全模式.png](http://upload-images.jianshu.io/upload_images/1488967-3afff57c83997764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n1、开始检测\n一般来说，应用启动一般是在appDelegate里的didFinishLaunchingWithOptions方法回调里搞事情。\n可是发现自家的写代码喜欢在+load方法里搞。且+load方法的执行是在main函数之前，那么问题就来了， 无法保证+load方法里产生的一些异常也能够被检测到。为了避免这种情况，需要把安全检测的逻辑放在+load方法里，且被系统调度的优先级比较高。好在，+load方法是有过处理，大致实现思路是在系统调用到+load方法的时候，使用block来封装load方法里的逻辑，添加进一个全局的数组中，优先级设置是通过对全局数组排序事项的，最后在相应的时刻从该数组中取出block并执行。调用时机分别为以下三个：\n* mian函数执行之前\n* didFinishLaunch\n* didFinishLaunch之后\n\n例如：\n```\n+(void)load {\n    imy_load_main(IMYLoadAtPreMain, 0, ^{\n        [IMYBootingProtectionManager shareBootingProtectionManager];\n    });\n}\n```\n2、异常捕获\n异常捕获，坑点太多，iOS系统允许我们去捕获mach级别和应用级别的异常。应用层的异常需要我们自己去注册一个异常捕获函数，但是一些三方sdk经常会注册该函数（例如友盟，bugly等），就会存在问题。前面注册的会被后面注册覆盖。你需要去写一些兼容代码。且自家的应用接入友盟，bugly这种三方统计的sdk。\n通过hook NSSetUncaughtExceptionHandler这个函数（ [传送门](http://www.cocoachina.com/ios/20150701/12301.html)），清晰看到了app分别注册了三个handler，自己注册的，友盟注册的和bugly注册的。发生异常的时候，最终都被bugly的给拦截了。而进入到自己注册的异常处理函数。\nQ:友盟是怎么统计到的？\nA:这就很尴尬了。发现当bugly检测到异常，它会把该异常同时上报给友盟。\n所以为了取巧，监控异常这部分通过初始化，由外部传入异常回调的函数从而达到监控异常的目的。\n```\n  imy_load_main(IMYLoadAtPreMain, 0, ^{\n        // 注册安全模式\n        [[IMY_AtomSDK shareInstance] regiterCrashProtectService];\n        // 异常捕获回调   \n        [[IMYAppReport shareInstance] addCrashReportLog:^NSString *_Nonnull(NSException *_Nonnull exception) {\n            [[IMY_AtomSDK shareInstance] regiterSafeModeService];\n            return nil;\n        }];\n    });\n\n```\n\n3、如何安全检测？\n既然保证了app在启动之前都会进入安全模式。进入该模式的时候，首先会维护一个闪退计数器，并且开启一个定时任务，若在该时间段了，app没有检测到任何异常发生，则会将该计数器清0。若检测到了闪退，则将该计数器+1。逻辑见上图。\n\n4、如何修复程序？\n进入安全模式，获取闪退计数，在这里分别设置了三级保护措施，当闪退技术>=2的时候，则会进入三级修复，会删除沙盒里的接口数据缓存文件。当闪退技术>=3的时候，会删除接口数据缓存，同时也会删除JSpatch和RN的包。当闪退技术>=5的时候，则会清空整个沙盒。修复完成之后，则会将闪退计数置为0。而应用则会恢复到初始状态。逻辑见上图。\n\n### 进程守护\n\n#### 1、UI_Protect\n\n闪退场景：\niOS 上不建议在非主线程进行UI操作，在非主线程进行UI操作有很大几率会导致程序崩溃，或者出现预期之外的效果。\n\n实现思路：\n通过Hook UIView类和CALayer类的一些方法来避免在非主线程执行UI操作。\n```\nUIView\n1.setNeedsLayout\n2.setNeedsDisplay\n3.setNeedsUpdateConstraints\n4.setNeedsDisplayInRect:\n\nCALayer\n1.setNeedsLayout\n2.setNeedsDisplay\n3.setNeedsDisplayInRect:\n```\n\n核心代码：\n```\n判断是否在主线程，不在则转移到主线程执行\n if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) {\n                                            // 调用原来的方法\n                                        } else {\n                                            dispatch_async(dispatch_get_main_queue(), ^{\n                                                 // 调用原来的方法\n                                            });\n                                        }\n```\n#### 2、NSTimer_Protect\n\n闪退场景：\nNSTimer这个鬼使用的时候，需要非常小心，最常见的两个坑。\n1.NSTimer会对target对象进行强引用，容易出现reatain circle。导致target无法释放，从而产生内存泄露。\n2.在使用scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:做一个重复的定时任务的时候， repeats参数设置为YES，在你不需要的时候，要你手动调用invalidate来销毁定时器。因为定时器会被放进Runloop中，如果target对象释放了之后，Runloop触发了定时器的定时任务，会因为找不到target对象而引起crash。\n\n实现思路：\n![Snip20170918_29.png](http://upload-images.jianshu.io/upload_images/1488967-2bf0a205872b5708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n主要解决两个问题：\n1.NSTimer对Target的强引用\n![Snip20170918_33.png](http://upload-images.jianshu.io/upload_images/1488967-4bdef0bcb66acd4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.自动invalidate的NSTimer\n\n![Snip20170918_34.png](http://upload-images.jianshu.io/upload_images/1488967-02cbd5ccfff260c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n核心代码：\n```\n1.hook\n static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        RSSwizzleClassMethod([NSTimer class], @selector(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:), RSSWReturnType(NSTimer *), RSSWArguments(NSTimeInterval ti, id aTarget, SEL aSelector, id userInfo, BOOL yesOrNo), RSSWReplacement({\n                                 if (!_NSTimerCrashProtectEnable) {\n                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);\n                                 }\n                                 NSTimer *timer = nil;\n                                 if (yesOrNo) {\n                                     @autoreleasepool {\n                                         IMY_TimerStubProxy *proxy = [[IMY_TimerStubProxy alloc] init];\n                                         proxy.target = aTarget;\n                                         proxy.aSelector = aSelector;\n                                         timer.timerProxy = proxy;\n                                         timer = RSSWCallOriginal(ti, proxy, @selector(fireProxyTimer:), userInfo, yesOrNo);\n                                         proxy.sourceTimer = timer;\n                                     }\n                                     return timer;\n                                 } else {\n                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);\n                                 }\n                                 return nil;\n                             }));\n        _NSTimerCrashProtectEnable = YES;\n    });\n\n2. fireProxyTimer：\n- (void)fireProxyTimer:(id)userinfo\n{\n    id strongTarget = self.target;\n    if (strongTarget && ([strongTarget respondsToSelector:self.aSelector])) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n        [strongTarget performSelector:self.aSelector\n                           withObject:userinfo];\n#pragma clang diagnostic pop\n\n    } else {\n        if (self.sourceTimer) {\n            [self.sourceTimer invalidate];\n        }\n        NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]: Target is <%@> Method is <%@>, reason : an object dealloc not invalidate Timer.\",\n                                                      [self class], NSStringFromSelector(self.aSelector)];\n        NSLog(@\"%@\", reason);\n    }\n}\n\n\n```\n#### 3、NSNull_Protect\n\n闪退场景：\niOS中数组，字典等一些集合类，元素只能为OC对象，所以只能用NSNull来填空。在做数据解析的时候，经常遇到服务端返回的数据中带有null这种鬼，会被解析成NSNull这种对象。稍微不注意类型保护就会发生闪退。\n\n实现思路：\nhook NSNull类的forwardingTargetForSelector:，将一些无法识别的消息发送给一些可以识别的集合类。\n\n核心代码：\n```\n RSSwizzleInstanceMethod([NSNull class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement({\n\n                                    if (!_NSNullCrashProtectEnable) {\n                                        return RSSWCallOriginal(aSelector);\n                                    }\n                                    static NSArray *sTmpOutput = nil;\n                                    if (sTmpOutput == nil) {\n                                        sTmpOutput = @[@\"\", @0, @[], @{}];\n                                    }\n\n                                    for (id tmpObj in sTmpOutput) {\n                                        if ([tmpObj respondsToSelector:aSelector]) {\n                                            return tmpObj;\n                                        }\n                                    }\n                                    return RSSWCallOriginal(aSelector);\n                                }),\n                                RSSwizzleModeAlways, nil);\n```\n\n#### 4、NSNotification_Protect\n\n闪退场景：\n在iOS9之前，通过addObserver:selector:name:object:监听通知。NSNotificatinonCenter会对观察者进行强引用，所以需要手动的在观察者对象挂了的时候移除通知监听。如果未移除监听，在观察者被释放的之后仍然会接收到通知那么就会发生闪退。\n\n实现思路：\n主要是hook NSNotificationCenter的addObserver:selector:name:object:，凡是有添加过通知监听的对象，都会给该对象设置一个标识。在dealloc的hook中，判断需要释放的对象，是否有注册过通知监听，是则去移除通知。\n\n#### 5、UnrecognizedSelector_Protect\n\n闪退场景：\n天天见。\n![Snip20170925_22.png](http://upload-images.jianshu.io/upload_images/1488967-19552be78073a7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900)\n\n实现思路：\n由于OC是一门动态类型的语言，它的方法调用其实是一种动态绑定的机制，也就是说方法调用是直到运行期才去确定的。\n方法在调用时，系统会查看这个对象能否接收这个消息（查看这个类有没有这个方法，或者有没有实现这个方法。），牛逼的是，如果不能并且只在不能的情况下，就会调用下面这几个方法，给你“补救”的机会，你可以理解为几套防止程序crash的备选方案，苹果就是利用这几个方案进行消息转发，前一套方案实现后一套方法就不会执行。如果这几套方案你都没有做处理，那么程序就会报错crash。\n完整的消息转发的流程如下：\n![Snip20170925_23.png](http://upload-images.jianshu.io/upload_images/1488967-c0794df51a9ec109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n主要是通过hook NSObject类的forwardingTargetForSelector：实例方法以及类方法。在该方法中将一些无法识别的方法，发送给一个stubProxy对象，且在运行时动态的给改stubProxy对象添加改SEL对应的方法实现(IMP)。\n\n![Snip20170920_5.png](http://upload-images.jianshu.io/upload_images/1488967-b68da4e515176f62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n核心代码：\n```\n    RSSwizzleInstanceMethod([NSObject class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement({\n                                    if (!_UnrecognizedSelectorCrashProtectEnable) {\n                                        return RSSWCallOriginal(aSelector);\n                                    }\n\n                                    BOOL aBool = [self respondsToSelector:aSelector];\n                                    // 获取消息签名\n                                    NSMethodSignature *signatrue = [self methodSignatureForSelector:aSelector];\n\n                                    if (aBool || signatrue) {\n                                        return RSSWCallOriginal(aSelector);\n                                    } else {\n                                        IMY_UnrecognizedSelector_StubProxy *stub = [[IMY_UnrecognizedSelector_StubProxy alloc] init];\n                                        [stub addFunc:aSelector];\n                                        NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]: unrecognizedSelector <%@> to instance <%@>\",\n                                                                                      NSStringFromSelector(aSelector), [self class]];\n                                        NSLog(@\"%@\", reason);\n                                        return stub;\n                                    }\n\n                                }),\n                                RSSwizzleModeAlways, nil);\n```\n\n#### 6、KVO_Protect\n\nKVO 是 Objective-C 对观察者设计模式的一种实现。观察对象(例如A类)，当对象某个属性(例如A中的字符串name)发生更改时，监听对象会获得通知，并作出相应处理。且不需要给被观察的对象添加任何额外代码，就能使用的一种观察者模式。\n\n闪退场景：\n* 1.被观察者提前释放\n```\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x600000018180 of class Student was deallocated while key value observers were still registered with it. Current observation info: <NSKeyValueObservationInfo 0x600000032340> (\n<NSKeyValueObservance 0x600000054d60: Observer: 0x7fe684608b40, Key path: name, Options: <New: YES, Old: YES, Prior: NO> Context: 0x0, Property: 0x60000005cb00>\n)'\n```\n* 2.被观察者是局部变量\n* 3.重复移除观察者 \n```\n*** Terminating app due to uncaught exception 'NSRangeException', reason: 'Cannot remove an observer <TestViewController 0x7fdb13e0cf40> for the key path \"view\" from < TestViewController 0x7fdb13e0cf40> because it is not registered as an observer.'\n```\n* 4.观察者对象未实现observeValueForKeyPath:ofObject: change: context:方法\n```\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '< TestViewController: 0x7fc628f049e0>: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.\nKey path: view\nObserved object: < TestViewController: 0x7fc628f049e0>\nChange: {\n    kind = 1;\n    new = \"<UIView: 0x7fc628d18810; frame = (0 0; 414 736); layer = <CALayer: 0x60800002be00>>\";\n}\nContext: 0x0'\n```\nps:重复添加观察者并不会引起crash，但是会多次触发相应事件。\n\n\n实现思路：\n主要通过NSObject的分类，利用运行时给NSObject实例添加一个关联对象kvoProxy，该对象是用于管理当前对象的kvo关系(也就是观察者和被观察者的关系)，分别hook addObserver:forKeyPath:options:context:和removeObserver:forKeyPath:以及dealloc方法，在dealloc中移除真正的观察者对象。\n\n![addObserver:forKeyPath:options:context:](http://upload-images.jianshu.io/upload_images/1488967-65735d525724bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![removeObserver:forKeyPath](http://upload-images.jianshu.io/upload_images/1488967-72f9a4e0eb982742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n核心代码：\n```\n    RSSwizzleInstanceMethod([NSObject class], @selector(addObserver:forKeyPath:options:context:), RSSWReturnType(void), RSSWArguments(NSObject * observer, NSString * keyPath, NSKeyValueObservingOptions options, void *context), RSSWReplacement({\n                                // 忽略RAC\n                                if (object_getClass(observer) == objc_getClass(\"RACKVOProxy\")) {\n                                    RSSWCallOriginal(observer, keyPath, options, context);\n                                    return;\n                                }\n                                NSHashTable<NSObject *> *os = [self kvoProxy].kvoInfoMap[keyPath];\n                                // 第一次的时候将KVOProxy添加为真正的观察者\n                                if (os.count == 0) { // (包括了 observers == nil 和 count == 0)\n                                    os = [[NSHashTable alloc] initWithOptions:(NSPointerFunctionsWeakMemory)capacity:0];\n                                    [os addObject:observer];\n                                    RSSWCallOriginal([self kvoProxy], keyPath, options, context);\n                                    [self kvoProxy].kvoInfoMap[keyPath] = os;\n                                    return;\n                                }\n\n                                if ([os containsObject:observer]) {\n                                    // 找到同样的观察者 不重复添加\n                                    NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]:KVO add Observer to many timers.Target is %@ method is %@ \",\n                                                                                  [self class], NSStringFromSelector(@selector(addObserver:forKeyPath:options:context:))];\n                                    NSLog(@\"%@\", reason);\n\n                                } else {\n                                    // 以后添加观察者直接往容器里面更新元素就行了\n                                    [os addObject:observer];\n                                }\n                            }),\n                            RSSwizzleModeAlways, nil);\n\n    [RSSwizzle swizzleInstanceMethod:@selector(removeObserver:forKeyPath:)\n                             inClass:[NSObject class]\n                       newImpFactory:^id(RSSwizzleInfo *swizzleInfo) {\n                           return ^void(__unsafe_unretained id self, NSObject *observer, NSString *keyPath) {\n\n\n                               int (*originalIMP)(__unsafe_unretained id, SEL, NSObject *, NSString *);\n                               originalIMP = (__typeof(originalIMP))[swizzleInfo getOriginalImplementation];\n                               __imy_hook_orgin_function_removeObserver = originalIMP;\n\n\n                               if (object_getClass(observer) == objc_getClass(\"RACKVOProxy\")) {\n                                   originalIMP(self, @selector(removeObserver:forKeyPath:), observer, keyPath);\n                                   return;\n                               }\n\n                               NSHashTable<NSObject *> *os = [self kvoProxy].kvoInfoMap[keyPath];\n                               if (os.count == 0) {\n                                   // 未找到观察者\n                                   NSString *reason = [NSString stringWithFormat:@\"[AtomSDK]: KVO remove Observer to many times.target is %@ method is %@,\",\n                                                                                 [self class], NSStringFromSelector(@selector(removeObserver:forKeyPath:))];\n                                   NSLog(@\"[KVO]:%@\", reason);\n\n                                   return;\n                               }\n                               // 找到了观察者 移除\n                               [os removeObject:observer];\n                               // 为空时移除真正的观察者\n                               if (os.count == 0) {\n                                   //                                   NSLog(@\"[KVO]:REMOVE【%@】-【%@】-【%@】\",self,observer,keyPath);\n                                   originalIMP(self, @selector(removeObserver:forKeyPath:), [self kvoProxy], keyPath);\n                                   [[self kvoProxy].kvoInfoMap removeObjectForKey:keyPath];\n                               }\n                           };\n                       }\n                                mode:RSSwizzleModeAlways\n                                 key:NULL];\n\n```\n#### 7、BadAccess_Protect\n\niOS中有空指针和野指针两种概念。空指针是没有存储任何内存地址的指针。如Student *s1 = NULL;和Student *s2 = nil;而野指针是指指向一个已删除的对象（”垃圾”内存既不可用内存）或未申请访问受限内存区域的指针。野指针是比较危险的。因为野指针指向的对象已经被释放了。通过野指针访问已经释放的对象crash其实不是必现的，因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。\nBTW野指针的崩溃是比较随机的，你在测试的时候可能没发生crash，但是用户在使用的时候就可能发生crash了。\n\n闪退场景：\n野指针闪退常见有以下几种情况：\n1.对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。\n2.对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。\n3.对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。\n4.对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。\n5.对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）！！\n6.对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。\n![1467690258548317-1.gif](http://upload-images.jianshu.io/upload_images/1488967-f460ae871ef8b723.gif?imageMogr2/auto-orient/strip)\n\n\n实现思路：\n\n在app的当前进程中，如果我们额外向系统申请一块内存，用于存储那些已经被释放的对象。所以当一个对象被释放了时候，系统就会自动调用该对象的dealloc方法，在这个方法里面系统会释放该对象自身的一些属性，关联对象等等一些资源。然后，我们利用isa指针混淆技术，将该对象的类动态修改为一个僵尸类，且该僵尸对象可以处理任何方法。那么如果你向一个已经被释放的对象发送消息的时候，因为它存在于缓存池当中，那么也就不会产生野指针了。\n\n首先我们需要知道dealloc的方法里面系统干了些什么事儿。\n因为OC中内存管理采用的是引用计数器的方式，即每个对象的散列表中都会存在一个int类型的变量表示该对象的被引用的次数，当该对象的引用计数为0的时候，由系统自动调用该对象的dealloc方法释放该对象的内存。并且父类的dealloc的方法将在子类dealloc方法返回后自动调用。（PS:你在跟我讲故事么。）\n\n通过查看Apple的runtime源码，可以看出ARC下的dealloc的实现原理。\n```\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj)\n{\n    assert(obj);\n\n    obj->rootDealloc();\n}\n\ninline void objc_object::rootDealloc()\n{\n    if (isTaggedPointer()) return;\n    object_dispose((id)this);\n}\n\nid object_dispose(id obj) \n{\n    if (UseGC) return _object_dispose(obj);\n    else return (*_dealloc)(obj); \n}\n\nstatic id _object_dispose(id anObject) \n{\n    if (anObject==nil) return nil;\n\n    objc_destructInstance(anObject);\n    \n#if SUPPORT_GC\n    if (UseGC) {\n        auto_zone_retain(gc_zone, anObject); // gc free expects rc==1\n    } else \n#endif\n    {\n        // only clobber isa for non-gc\n        anObject->initIsa(_objc_getFreedObjectClass ()); \n    }\n    free(anObject);\n    return nil;\n}\n```\n这里能够清晰地看到在执行dealloc的时候，会先执行_objc_rootDealloc()函数。然后执行_object_dispose()，且在这个函数里干了三件事情：\n* 1.调用objc_destructInstance()释放对象的所有实例变量和关联对象(该方法并未回收对象本身内存).\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = !UseGC && obj->hasAssociatedObjects();\n        bool dealloc = !UseGC;\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        if (dealloc) obj->clearDeallocating();\n    }\n    return obj;\n}\n```\n* 2.isa-swizzling将该对象的类置为一个空的类对象.\n* 3.调用free()回收该对象的内存.\n\n所以我们需要在对象真正被释放的时机搞事情，有三个选择：\n* 1.运行时hook NSObject的dealloc方法。\n* 2.runtime object_dispose 。\n* 3.利用fishhook c的free()。\n  这三个调用栈顺序依次dealloc->object_dispose->free。所以还是选择hook最上层dealloc方法。主要针对OC对象的野指针。\n  流程图如下：\n  ![Snip20170929_35.png](http://upload-images.jianshu.io/upload_images/1488967-4d3a9e5d5c875e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/h/800)\n\n\n核心代码：\n```\n- (void)IMY_BadAccess_dealloc {\n    NSObject *obj = (NSObject *)self;\n    objc_destructInstance(self);\n    object_setClass(self, [_IMYZombieObj class]);\n    obj.oriClass = NSStringFromClass([self class]);\n    dispatch_async(zombieOperationQueue, ^{\n        if (global_unfree_list->unfree_count > MAX_UNFREE_POINTER * 0.9 || global_unfree_list->unfree_size > MAX_UNFREE_MEM) {\n            freeMemInListSync(global_unfree_list, FREE_POINTER_NUM);\n        }\n        addUnFreeMemToListSync(global_unfree_list, (__bridge void *)(self));\n    });\n}\n```\n","slug":"iOS-04","published":1,"updated":"2019-12-20T06:08:22.050Z","comments":1,"photos":[],"link":"","_id":"ck4dsux37000oodnq7rfbgy6g","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4b6a2f23f722bb43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"Atom.jpg\"></p>\n<blockquote>\n<p>前言：<br>APP的Crash率一直是评估app稳定性的一个重要指标，也是程序员的噩梦。每次提测之前跑完用例，都是信誓旦旦的”放心，代码不可能存在bug。”。在iOS还存在热补丁的时候，大部分iOS程序狗都有过半夜写着JSPatch代码的体验，那个时候确实可以做到不存在bug。然而热补丁被苹果大大封杀了，我们就开始焦虑了。KPI怎么搞？问题来了，如果App出现不可挽救的闪退怎么办？比如启动就崩溃，随便点点就闪退。怎么办？怎么办？怎么办？</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"开发目的\"><a href=\"#开发目的\" class=\"headerlink\" title=\"开发目的\"></a>开发目的</h2><p>主要的动机有2点。</p>\n<p>一是为了防止app在启动时期crash的情况发生，因为这种crash一旦产生必然会使得app陷入无法启动的绝境。</p>\n<p>另一个是为了降低运行时期app的crash率，主要是利用oc的动态特性，通过切面编程，使得业务层在无感知的情况下，app能够在运行时期自动捕获异常，修复异常，从而避免crash的出现。</p>\n<h2 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h2><blockquote>\n<p>功能主要分为两个模块</p>\n</blockquote>\n<h3 id=\"安全模式\"><a href=\"#安全模式\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><p>冷启动时期内程序能够检测连续闪退，在出现连续闪退时，能够进行自我修复，一共分为三级保护，触发一级保护时会删除沙盒中的一些网络数据的缓存。二级保护则会删除沙盒中的rn包以及一些资源文件。三级保护会去清空沙盒，从而使得app进入一种初始化状态。</p>\n<h3 id=\"进程守护\"><a href=\"#进程守护\" class=\"headerlink\" title=\"进程守护\"></a>进程守护</h3><ul>\n<li>1.unrecognized selector crash</li>\n<li>2.KVO crash</li>\n<li>3.NSNotification crash</li>\n<li>4.NSTimer crash</li>\n<li>5.Container crash（常见集合类crash等）</li>\n<li>6.NSNull crash </li>\n<li>7.Bad Access crash （野指针）</li>\n<li>8.UI not on Main Thread Crash (非主线程刷UI）</li>\n</ul>\n<h3 id=\"日志上报\"><a href=\"#日志上报\" class=\"headerlink\" title=\"日志上报\"></a>日志上报</h3><h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><h3 id=\"安全模式-1\"><a href=\"#安全模式-1\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><p>app在启动时期会执行一系列的初始化操作，例如：</p>\n<ul>\n<li>协议注册<ul>\n<li>配置接口</li>\n<li>RN加载</li>\n<li>相关配置信息读取，环境变量配置</li>\n<li>本地数据缓存读取</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n<p>实现逻辑：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-3afff57c83997764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"安全模式.png\"></p>\n<p>1、开始检测<br>一般来说，应用启动一般是在appDelegate里的didFinishLaunchingWithOptions方法回调里搞事情。<br>可是发现自家的写代码喜欢在+load方法里搞。且+load方法的执行是在main函数之前，那么问题就来了， 无法保证+load方法里产生的一些异常也能够被检测到。为了避免这种情况，需要把安全检测的逻辑放在+load方法里，且被系统调度的优先级比较高。好在，+load方法是有过处理，大致实现思路是在系统调用到+load方法的时候，使用block来封装load方法里的逻辑，添加进一个全局的数组中，优先级设置是通过对全局数组排序事项的，最后在相应的时刻从该数组中取出block并执行。调用时机分别为以下三个：</p>\n<ul>\n<li>mian函数执行之前</li>\n<li>didFinishLaunch</li>\n<li>didFinishLaunch之后</li>\n</ul>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(void)load &#123;</span><br><span class=\"line\">    imy_load_main(IMYLoadAtPreMain, 0, ^&#123;</span><br><span class=\"line\">        [IMYBootingProtectionManager shareBootingProtectionManager];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2、异常捕获<br>异常捕获，坑点太多，iOS系统允许我们去捕获mach级别和应用级别的异常。应用层的异常需要我们自己去注册一个异常捕获函数，但是一些三方sdk经常会注册该函数（例如友盟，bugly等），就会存在问题。前面注册的会被后面注册覆盖。你需要去写一些兼容代码。且自家的应用接入友盟，bugly这种三方统计的sdk。<br>通过hook NSSetUncaughtExceptionHandler这个函数（ <a href=\"http://www.cocoachina.com/ios/20150701/12301.html\" target=\"_blank\" rel=\"noopener\">传送门</a>），清晰看到了app分别注册了三个handler，自己注册的，友盟注册的和bugly注册的。发生异常的时候，最终都被bugly的给拦截了。而进入到自己注册的异常处理函数。<br>Q:友盟是怎么统计到的？<br>A:这就很尴尬了。发现当bugly检测到异常，它会把该异常同时上报给友盟。<br>所以为了取巧，监控异常这部分通过初始化，由外部传入异常回调的函数从而达到监控异常的目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imy_load_main(IMYLoadAtPreMain, 0, ^&#123;</span><br><span class=\"line\">      // 注册安全模式</span><br><span class=\"line\">      [[IMY_AtomSDK shareInstance] regiterCrashProtectService];</span><br><span class=\"line\">      // 异常捕获回调   </span><br><span class=\"line\">      [[IMYAppReport shareInstance] addCrashReportLog:^NSString *_Nonnull(NSException *_Nonnull exception) &#123;</span><br><span class=\"line\">          [[IMY_AtomSDK shareInstance] regiterSafeModeService];</span><br><span class=\"line\">          return nil;</span><br><span class=\"line\">      &#125;];</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>3、如何安全检测？<br>既然保证了app在启动之前都会进入安全模式。进入该模式的时候，首先会维护一个闪退计数器，并且开启一个定时任务，若在该时间段了，app没有检测到任何异常发生，则会将该计数器清0。若检测到了闪退，则将该计数器+1。逻辑见上图。</p>\n<p>4、如何修复程序？<br>进入安全模式，获取闪退计数，在这里分别设置了三级保护措施，当闪退技术&gt;=2的时候，则会进入三级修复，会删除沙盒里的接口数据缓存文件。当闪退技术&gt;=3的时候，会删除接口数据缓存，同时也会删除JSpatch和RN的包。当闪退技术&gt;=5的时候，则会清空整个沙盒。修复完成之后，则会将闪退计数置为0。而应用则会恢复到初始状态。逻辑见上图。</p>\n<h3 id=\"进程守护-1\"><a href=\"#进程守护-1\" class=\"headerlink\" title=\"进程守护\"></a>进程守护</h3><h4 id=\"1、UI-Protect\"><a href=\"#1、UI-Protect\" class=\"headerlink\" title=\"1、UI_Protect\"></a>1、UI_Protect</h4><p>闪退场景：<br>iOS 上不建议在非主线程进行UI操作，在非主线程进行UI操作有很大几率会导致程序崩溃，或者出现预期之外的效果。</p>\n<p>实现思路：<br>通过Hook UIView类和CALayer类的一些方法来避免在非主线程执行UI操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView</span><br><span class=\"line\">1.setNeedsLayout</span><br><span class=\"line\">2.setNeedsDisplay</span><br><span class=\"line\">3.setNeedsUpdateConstraints</span><br><span class=\"line\">4.setNeedsDisplayInRect:</span><br><span class=\"line\"></span><br><span class=\"line\">CALayer</span><br><span class=\"line\">1.setNeedsLayout</span><br><span class=\"line\">2.setNeedsDisplay</span><br><span class=\"line\">3.setNeedsDisplayInRect:</span><br></pre></td></tr></table></figure></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断是否在主线程，不在则转移到主线程执行</span><br><span class=\"line\"> if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;</span><br><span class=\"line\">                                            // 调用原来的方法</span><br><span class=\"line\">                                        &#125; else &#123;</span><br><span class=\"line\">                                            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                                                 // 调用原来的方法</span><br><span class=\"line\">                                            &#125;);</span><br><span class=\"line\">                                        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、NSTimer-Protect\"><a href=\"#2、NSTimer-Protect\" class=\"headerlink\" title=\"2、NSTimer_Protect\"></a>2、NSTimer_Protect</h4><p>闪退场景：<br>NSTimer这个鬼使用的时候，需要非常小心，最常见的两个坑。<br>1.NSTimer会对target对象进行强引用，容易出现reatain circle。导致target无法释放，从而产生内存泄露。<br>2.在使用scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:做一个重复的定时任务的时候， repeats参数设置为YES，在你不需要的时候，要你手动调用invalidate来销毁定时器。因为定时器会被放进Runloop中，如果target对象释放了之后，Runloop触发了定时器的定时任务，会因为找不到target对象而引起crash。</p>\n<p>实现思路：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-2bf0a205872b5708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170918_29.png\"></p>\n<p>主要解决两个问题：<br>1.NSTimer对Target的强引用<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4bdef0bcb66acd4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170918_33.png\"></p>\n<p>2.自动invalidate的NSTimer</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-02cbd5ccfff260c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170918_34.png\"></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.hook</span><br><span class=\"line\"> static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        RSSwizzleClassMethod([NSTimer class], @selector(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:), RSSWReturnType(NSTimer *), RSSWArguments(NSTimeInterval ti, id aTarget, SEL aSelector, id userInfo, BOOL yesOrNo), RSSWReplacement(&#123;</span><br><span class=\"line\">                                 if (!_NSTimerCrashProtectEnable) &#123;</span><br><span class=\"line\">                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);</span><br><span class=\"line\">                                 &#125;</span><br><span class=\"line\">                                 NSTimer *timer = nil;</span><br><span class=\"line\">                                 if (yesOrNo) &#123;</span><br><span class=\"line\">                                     @autoreleasepool &#123;</span><br><span class=\"line\">                                         IMY_TimerStubProxy *proxy = [[IMY_TimerStubProxy alloc] init];</span><br><span class=\"line\">                                         proxy.target = aTarget;</span><br><span class=\"line\">                                         proxy.aSelector = aSelector;</span><br><span class=\"line\">                                         timer.timerProxy = proxy;</span><br><span class=\"line\">                                         timer = RSSWCallOriginal(ti, proxy, @selector(fireProxyTimer:), userInfo, yesOrNo);</span><br><span class=\"line\">                                         proxy.sourceTimer = timer;</span><br><span class=\"line\">                                     &#125;</span><br><span class=\"line\">                                     return timer;</span><br><span class=\"line\">                                 &#125; else &#123;</span><br><span class=\"line\">                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);</span><br><span class=\"line\">                                 &#125;</span><br><span class=\"line\">                                 return nil;</span><br><span class=\"line\">                             &#125;));</span><br><span class=\"line\">        _NSTimerCrashProtectEnable = YES;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">2. fireProxyTimer：</span><br><span class=\"line\">- (void)fireProxyTimer:(id)userinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    id strongTarget = self.target;</span><br><span class=\"line\">    if (strongTarget &amp;&amp; ([strongTarget respondsToSelector:self.aSelector])) &#123;</span><br><span class=\"line\">#pragma clang diagnostic push</span><br><span class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class=\"line\">        [strongTarget performSelector:self.aSelector</span><br><span class=\"line\">                           withObject:userinfo];</span><br><span class=\"line\">#pragma clang diagnostic pop</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (self.sourceTimer) &#123;</span><br><span class=\"line\">            [self.sourceTimer invalidate];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]: Target is &lt;%@&gt; Method is &lt;%@&gt;, reason : an object dealloc not invalidate Timer.&quot;,</span><br><span class=\"line\">                                                      [self class], NSStringFromSelector(self.aSelector)];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, reason);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、NSNull-Protect\"><a href=\"#3、NSNull-Protect\" class=\"headerlink\" title=\"3、NSNull_Protect\"></a>3、NSNull_Protect</h4><p>闪退场景：<br>iOS中数组，字典等一些集合类，元素只能为OC对象，所以只能用NSNull来填空。在做数据解析的时候，经常遇到服务端返回的数据中带有null这种鬼，会被解析成NSNull这种对象。稍微不注意类型保护就会发生闪退。</p>\n<p>实现思路：<br>hook NSNull类的forwardingTargetForSelector:，将一些无法识别的消息发送给一些可以识别的集合类。</p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSSwizzleInstanceMethod([NSNull class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                                   if (!_NSNullCrashProtectEnable) &#123;</span><br><span class=\"line\">                                       return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\">                                   static NSArray *sTmpOutput = nil;</span><br><span class=\"line\">                                   if (sTmpOutput == nil) &#123;</span><br><span class=\"line\">                                       sTmpOutput = @[@&quot;&quot;, @0, @[], @&#123;&#125;];</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                   for (id tmpObj in sTmpOutput) &#123;</span><br><span class=\"line\">                                       if ([tmpObj respondsToSelector:aSelector]) &#123;</span><br><span class=\"line\">                                           return tmpObj;</span><br><span class=\"line\">                                       &#125;</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\">                                   return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                               &#125;),</span><br><span class=\"line\">                               RSSwizzleModeAlways, nil);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4、NSNotification-Protect\"><a href=\"#4、NSNotification-Protect\" class=\"headerlink\" title=\"4、NSNotification_Protect\"></a>4、NSNotification_Protect</h4><p>闪退场景：<br>在iOS9之前，通过addObserver:selector:name:object:监听通知。NSNotificatinonCenter会对观察者进行强引用，所以需要手动的在观察者对象挂了的时候移除通知监听。如果未移除监听，在观察者被释放的之后仍然会接收到通知那么就会发生闪退。</p>\n<p>实现思路：<br>主要是hook NSNotificationCenter的addObserver:selector:name:object:，凡是有添加过通知监听的对象，都会给该对象设置一个标识。在dealloc的hook中，判断需要释放的对象，是否有注册过通知监听，是则去移除通知。</p>\n<h4 id=\"5、UnrecognizedSelector-Protect\"><a href=\"#5、UnrecognizedSelector-Protect\" class=\"headerlink\" title=\"5、UnrecognizedSelector_Protect\"></a>5、UnrecognizedSelector_Protect</h4><p>闪退场景：<br>天天见。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-19552be78073a7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900\" alt=\"Snip20170925_22.png\"></p>\n<p>实现思路：<br>由于OC是一门动态类型的语言，它的方法调用其实是一种动态绑定的机制，也就是说方法调用是直到运行期才去确定的。<br>方法在调用时，系统会查看这个对象能否接收这个消息（查看这个类有没有这个方法，或者有没有实现这个方法。），牛逼的是，如果不能并且只在不能的情况下，就会调用下面这几个方法，给你“补救”的机会，你可以理解为几套防止程序crash的备选方案，苹果就是利用这几个方案进行消息转发，前一套方案实现后一套方法就不会执行。如果这几套方案你都没有做处理，那么程序就会报错crash。<br>完整的消息转发的流程如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-c0794df51a9ec109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170925_23.png\"></p>\n<p>主要是通过hook NSObject类的forwardingTargetForSelector：实例方法以及类方法。在该方法中将一些无法识别的方法，发送给一个stubProxy对象，且在运行时动态的给改stubProxy对象添加改SEL对应的方法实现(IMP)。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-b68da4e515176f62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170920_5.png\"></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSSwizzleInstanceMethod([NSObject class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement(&#123;</span><br><span class=\"line\">                                if (!_UnrecognizedSelectorCrashProtectEnable) &#123;</span><br><span class=\"line\">                                    return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                BOOL aBool = [self respondsToSelector:aSelector];</span><br><span class=\"line\">                                // 获取消息签名</span><br><span class=\"line\">                                NSMethodSignature *signatrue = [self methodSignatureForSelector:aSelector];</span><br><span class=\"line\"></span><br><span class=\"line\">                                if (aBool || signatrue) &#123;</span><br><span class=\"line\">                                    return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                                &#125; else &#123;</span><br><span class=\"line\">                                    IMY_UnrecognizedSelector_StubProxy *stub = [[IMY_UnrecognizedSelector_StubProxy alloc] init];</span><br><span class=\"line\">                                    [stub addFunc:aSelector];</span><br><span class=\"line\">                                    NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]: unrecognizedSelector &lt;%@&gt; to instance &lt;%@&gt;&quot;,</span><br><span class=\"line\">                                                                                  NSStringFromSelector(aSelector), [self class]];</span><br><span class=\"line\">                                    NSLog(@&quot;%@&quot;, reason);</span><br><span class=\"line\">                                    return stub;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            &#125;),</span><br><span class=\"line\">                            RSSwizzleModeAlways, nil);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6、KVO-Protect\"><a href=\"#6、KVO-Protect\" class=\"headerlink\" title=\"6、KVO_Protect\"></a>6、KVO_Protect</h4><p>KVO 是 Objective-C 对观察者设计模式的一种实现。观察对象(例如A类)，当对象某个属性(例如A中的字符串name)发生更改时，监听对象会获得通知，并作出相应处理。且不需要给被观察的对象添加任何额外代码，就能使用的一种观察者模式。</p>\n<p>闪退场景：</p>\n<ul>\n<li><p>1.被观察者提前释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;An instance 0x600000018180 of class Student was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x600000032340&gt; (</span><br><span class=\"line\">&lt;NSKeyValueObservance 0x600000054d60: Observer: 0x7fe684608b40, Key path: name, Options: &lt;New: YES, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x60000005cb00&gt;</span><br><span class=\"line\">)&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.被观察者是局部变量</p>\n</li>\n<li><p>3.重复移除观察者 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;Cannot remove an observer &lt;TestViewController 0x7fdb13e0cf40&gt; for the key path &quot;view&quot; from &lt; TestViewController 0x7fdb13e0cf40&gt; because it is not registered as an observer.&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.观察者对象未实现observeValueForKeyPath:ofObject: change: context:方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;&lt; TestViewController: 0x7fc628f049e0&gt;: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</span><br><span class=\"line\">Key path: view</span><br><span class=\"line\">Observed object: &lt; TestViewController: 0x7fc628f049e0&gt;</span><br><span class=\"line\">Change: &#123;</span><br><span class=\"line\">    kind = 1;</span><br><span class=\"line\">    new = &quot;&lt;UIView: 0x7fc628d18810; frame = (0 0; 414 736); layer = &lt;CALayer: 0x60800002be00&gt;&gt;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Context: 0x0&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ps:重复添加观察者并不会引起crash，但是会多次触发相应事件。</p>\n<p>实现思路：<br>主要通过NSObject的分类，利用运行时给NSObject实例添加一个关联对象kvoProxy，该对象是用于管理当前对象的kvo关系(也就是观察者和被观察者的关系)，分别hook addObserver:forKeyPath:options:context:和removeObserver:forKeyPath:以及dealloc方法，在dealloc中移除真正的观察者对象。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-65735d525724bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"addObserver:forKeyPath:options:context:\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-72f9a4e0eb982742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"removeObserver:forKeyPath\"></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSSwizzleInstanceMethod([NSObject class], @selector(addObserver:forKeyPath:options:context:), RSSWReturnType(void), RSSWArguments(NSObject * observer, NSString * keyPath, NSKeyValueObservingOptions options, void *context), RSSWReplacement(&#123;</span><br><span class=\"line\">                            // 忽略RAC</span><br><span class=\"line\">                            if (object_getClass(observer) == objc_getClass(&quot;RACKVOProxy&quot;)) &#123;</span><br><span class=\"line\">                                RSSWCallOriginal(observer, keyPath, options, context);</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            NSHashTable&lt;NSObject *&gt; *os = [self kvoProxy].kvoInfoMap[keyPath];</span><br><span class=\"line\">                            // 第一次的时候将KVOProxy添加为真正的观察者</span><br><span class=\"line\">                            if (os.count == 0) &#123; // (包括了 observers == nil 和 count == 0)</span><br><span class=\"line\">                                os = [[NSHashTable alloc] initWithOptions:(NSPointerFunctionsWeakMemory)capacity:0];</span><br><span class=\"line\">                                [os addObject:observer];</span><br><span class=\"line\">                                RSSWCallOriginal([self kvoProxy], keyPath, options, context);</span><br><span class=\"line\">                                [self kvoProxy].kvoInfoMap[keyPath] = os;</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            if ([os containsObject:observer]) &#123;</span><br><span class=\"line\">                                // 找到同样的观察者 不重复添加</span><br><span class=\"line\">                                NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]:KVO add Observer to many timers.Target is %@ method is %@ &quot;,</span><br><span class=\"line\">                                                                              [self class], NSStringFromSelector(@selector(addObserver:forKeyPath:options:context:))];</span><br><span class=\"line\">                                NSLog(@&quot;%@&quot;, reason);</span><br><span class=\"line\"></span><br><span class=\"line\">                            &#125; else &#123;</span><br><span class=\"line\">                                // 以后添加观察者直接往容器里面更新元素就行了</span><br><span class=\"line\">                                [os addObject:observer];</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;),</span><br><span class=\"line\">                        RSSwizzleModeAlways, nil);</span><br><span class=\"line\"></span><br><span class=\"line\">[RSSwizzle swizzleInstanceMethod:@selector(removeObserver:forKeyPath:)</span><br><span class=\"line\">                         inClass:[NSObject class]</span><br><span class=\"line\">                   newImpFactory:^id(RSSwizzleInfo *swizzleInfo) &#123;</span><br><span class=\"line\">                       return ^void(__unsafe_unretained id self, NSObject *observer, NSString *keyPath) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                           int (*originalIMP)(__unsafe_unretained id, SEL, NSObject *, NSString *);</span><br><span class=\"line\">                           originalIMP = (__typeof(originalIMP))[swizzleInfo getOriginalImplementation];</span><br><span class=\"line\">                           __imy_hook_orgin_function_removeObserver = originalIMP;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                           if (object_getClass(observer) == objc_getClass(&quot;RACKVOProxy&quot;)) &#123;</span><br><span class=\"line\">                               originalIMP(self, @selector(removeObserver:forKeyPath:), observer, keyPath);</span><br><span class=\"line\">                               return;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                           NSHashTable&lt;NSObject *&gt; *os = [self kvoProxy].kvoInfoMap[keyPath];</span><br><span class=\"line\">                           if (os.count == 0) &#123;</span><br><span class=\"line\">                               // 未找到观察者</span><br><span class=\"line\">                               NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]: KVO remove Observer to many times.target is %@ method is %@,&quot;,</span><br><span class=\"line\">                                                                             [self class], NSStringFromSelector(@selector(removeObserver:forKeyPath:))];</span><br><span class=\"line\">                               NSLog(@&quot;[KVO]:%@&quot;, reason);</span><br><span class=\"line\"></span><br><span class=\"line\">                               return;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                           // 找到了观察者 移除</span><br><span class=\"line\">                           [os removeObject:observer];</span><br><span class=\"line\">                           // 为空时移除真正的观察者</span><br><span class=\"line\">                           if (os.count == 0) &#123;</span><br><span class=\"line\">                               //                                   NSLog(@&quot;[KVO]:REMOVE【%@】-【%@】-【%@】&quot;,self,observer,keyPath);</span><br><span class=\"line\">                               originalIMP(self, @selector(removeObserver:forKeyPath:), [self kvoProxy], keyPath);</span><br><span class=\"line\">                               [[self kvoProxy].kvoInfoMap removeObjectForKey:keyPath];</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                            mode:RSSwizzleModeAlways</span><br><span class=\"line\">                             key:NULL];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7、BadAccess-Protect\"><a href=\"#7、BadAccess-Protect\" class=\"headerlink\" title=\"7、BadAccess_Protect\"></a>7、BadAccess_Protect</h4><p>iOS中有空指针和野指针两种概念。空指针是没有存储任何内存地址的指针。如Student <em>s1 = NULL;和Student </em>s2 = nil;而野指针是指指向一个已删除的对象（”垃圾”内存既不可用内存）或未申请访问受限内存区域的指针。野指针是比较危险的。因为野指针指向的对象已经被释放了。通过野指针访问已经释放的对象crash其实不是必现的，因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。<br>BTW野指针的崩溃是比较随机的，你在测试的时候可能没发生crash，但是用户在使用的时候就可能发生crash了。</p>\n<p>闪退场景：<br>野指针闪退常见有以下几种情况：<br>1.对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。<br>2.对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。<br>3.对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。<br>4.对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。<br>5.对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）！！<br>6.对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-f460ae871ef8b723.gif?imageMogr2/auto-orient/strip\" alt=\"1467690258548317-1.gif\"></p>\n<p>实现思路：</p>\n<p>在app的当前进程中，如果我们额外向系统申请一块内存，用于存储那些已经被释放的对象。所以当一个对象被释放了时候，系统就会自动调用该对象的dealloc方法，在这个方法里面系统会释放该对象自身的一些属性，关联对象等等一些资源。然后，我们利用isa指针混淆技术，将该对象的类动态修改为一个僵尸类，且该僵尸对象可以处理任何方法。那么如果你向一个已经被释放的对象发送消息的时候，因为它存在于缓存池当中，那么也就不会产生野指针了。</p>\n<p>首先我们需要知道dealloc的方法里面系统干了些什么事儿。<br>因为OC中内存管理采用的是引用计数器的方式，即每个对象的散列表中都会存在一个int类型的变量表示该对象的被引用的次数，当该对象的引用计数为0的时候，由系统自动调用该对象的dealloc方法释放该对象的内存。并且父类的dealloc的方法将在子类dealloc方法返回后自动调用。（PS:你在跟我讲故事么。）</p>\n<p>通过查看Apple的runtime源码，可以看出ARC下的dealloc的实现原理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _objc_rootDealloc(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    assert(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    obj-&gt;rootDealloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void objc_object::rootDealloc()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (isTaggedPointer()) return;</span><br><span class=\"line\">    object_dispose((id)this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id object_dispose(id obj) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (UseGC) return _object_dispose(obj);</span><br><span class=\"line\">    else return (*_dealloc)(obj); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static id _object_dispose(id anObject) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (anObject==nil) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_destructInstance(anObject);</span><br><span class=\"line\">    </span><br><span class=\"line\">#if SUPPORT_GC</span><br><span class=\"line\">    if (UseGC) &#123;</span><br><span class=\"line\">        auto_zone_retain(gc_zone, anObject); // gc free expects rc==1</span><br><span class=\"line\">    &#125; else </span><br><span class=\"line\">#endif</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // only clobber isa for non-gc</span><br><span class=\"line\">        anObject-&gt;initIsa(_objc_getFreedObjectClass ()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(anObject);</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里能够清晰地看到在执行dealloc的时候，会先执行_objc_rootDealloc()函数。然后执行_object_dispose()，且在这个函数里干了三件事情：</p>\n<ul>\n<li><p>1.调用objc_destructInstance()释放对象的所有实例变量和关联对象(该方法并未回收对象本身内存).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *objc_destructInstance(id obj) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (obj) &#123;</span><br><span class=\"line\">        // Read all of the flags at once for performance.</span><br><span class=\"line\">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\">        bool dealloc = !UseGC;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This order is important.</span><br><span class=\"line\">        if (cxx) object_cxxDestruct(obj);</span><br><span class=\"line\">        if (assoc) _object_remove_assocations(obj);</span><br><span class=\"line\">        if (dealloc) obj-&gt;clearDeallocating();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.isa-swizzling将该对象的类置为一个空的类对象.</p>\n</li>\n<li>3.调用free()回收该对象的内存.</li>\n</ul>\n<p>所以我们需要在对象真正被释放的时机搞事情，有三个选择：</p>\n<ul>\n<li>1.运行时hook NSObject的dealloc方法。</li>\n<li>2.runtime object_dispose 。</li>\n<li>3.利用fishhook c的free()。<br>这三个调用栈顺序依次dealloc-&gt;object_dispose-&gt;free。所以还是选择hook最上层dealloc方法。主要针对OC对象的野指针。<br>流程图如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4d3a9e5d5c875e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/h/800\" alt=\"Snip20170929_35.png\"></li>\n</ul>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)IMY_BadAccess_dealloc &#123;</span><br><span class=\"line\">    NSObject *obj = (NSObject *)self;</span><br><span class=\"line\">    objc_destructInstance(self);</span><br><span class=\"line\">    object_setClass(self, [_IMYZombieObj class]);</span><br><span class=\"line\">    obj.oriClass = NSStringFromClass([self class]);</span><br><span class=\"line\">    dispatch_async(zombieOperationQueue, ^&#123;</span><br><span class=\"line\">        if (global_unfree_list-&gt;unfree_count &gt; MAX_UNFREE_POINTER * 0.9 || global_unfree_list-&gt;unfree_size &gt; MAX_UNFREE_MEM) &#123;</span><br><span class=\"line\">            freeMemInListSync(global_unfree_list, FREE_POINTER_NUM);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addUnFreeMemToListSync(global_unfree_list, (__bridge void *)(self));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4b6a2f23f722bb43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"Atom.jpg\"></p>\n<blockquote>\n<p>前言：<br>APP的Crash率一直是评估app稳定性的一个重要指标，也是程序员的噩梦。每次提测之前跑完用例，都是信誓旦旦的”放心，代码不可能存在bug。”。在iOS还存在热补丁的时候，大部分iOS程序狗都有过半夜写着JSPatch代码的体验，那个时候确实可以做到不存在bug。然而热补丁被苹果大大封杀了，我们就开始焦虑了。KPI怎么搞？问题来了，如果App出现不可挽救的闪退怎么办？比如启动就崩溃，随便点点就闪退。怎么办？怎么办？怎么办？</p>\n</blockquote>","more":"<h2 id=\"开发目的\"><a href=\"#开发目的\" class=\"headerlink\" title=\"开发目的\"></a>开发目的</h2><p>主要的动机有2点。</p>\n<p>一是为了防止app在启动时期crash的情况发生，因为这种crash一旦产生必然会使得app陷入无法启动的绝境。</p>\n<p>另一个是为了降低运行时期app的crash率，主要是利用oc的动态特性，通过切面编程，使得业务层在无感知的情况下，app能够在运行时期自动捕获异常，修复异常，从而避免crash的出现。</p>\n<h2 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h2><blockquote>\n<p>功能主要分为两个模块</p>\n</blockquote>\n<h3 id=\"安全模式\"><a href=\"#安全模式\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><p>冷启动时期内程序能够检测连续闪退，在出现连续闪退时，能够进行自我修复，一共分为三级保护，触发一级保护时会删除沙盒中的一些网络数据的缓存。二级保护则会删除沙盒中的rn包以及一些资源文件。三级保护会去清空沙盒，从而使得app进入一种初始化状态。</p>\n<h3 id=\"进程守护\"><a href=\"#进程守护\" class=\"headerlink\" title=\"进程守护\"></a>进程守护</h3><ul>\n<li>1.unrecognized selector crash</li>\n<li>2.KVO crash</li>\n<li>3.NSNotification crash</li>\n<li>4.NSTimer crash</li>\n<li>5.Container crash（常见集合类crash等）</li>\n<li>6.NSNull crash </li>\n<li>7.Bad Access crash （野指针）</li>\n<li>8.UI not on Main Thread Crash (非主线程刷UI）</li>\n</ul>\n<h3 id=\"日志上报\"><a href=\"#日志上报\" class=\"headerlink\" title=\"日志上报\"></a>日志上报</h3><h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><h3 id=\"安全模式-1\"><a href=\"#安全模式-1\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><p>app在启动时期会执行一系列的初始化操作，例如：</p>\n<ul>\n<li>协议注册<ul>\n<li>配置接口</li>\n<li>RN加载</li>\n<li>相关配置信息读取，环境变量配置</li>\n<li>本地数据缓存读取</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n<p>实现逻辑：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-3afff57c83997764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"安全模式.png\"></p>\n<p>1、开始检测<br>一般来说，应用启动一般是在appDelegate里的didFinishLaunchingWithOptions方法回调里搞事情。<br>可是发现自家的写代码喜欢在+load方法里搞。且+load方法的执行是在main函数之前，那么问题就来了， 无法保证+load方法里产生的一些异常也能够被检测到。为了避免这种情况，需要把安全检测的逻辑放在+load方法里，且被系统调度的优先级比较高。好在，+load方法是有过处理，大致实现思路是在系统调用到+load方法的时候，使用block来封装load方法里的逻辑，添加进一个全局的数组中，优先级设置是通过对全局数组排序事项的，最后在相应的时刻从该数组中取出block并执行。调用时机分别为以下三个：</p>\n<ul>\n<li>mian函数执行之前</li>\n<li>didFinishLaunch</li>\n<li>didFinishLaunch之后</li>\n</ul>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(void)load &#123;</span><br><span class=\"line\">    imy_load_main(IMYLoadAtPreMain, 0, ^&#123;</span><br><span class=\"line\">        [IMYBootingProtectionManager shareBootingProtectionManager];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2、异常捕获<br>异常捕获，坑点太多，iOS系统允许我们去捕获mach级别和应用级别的异常。应用层的异常需要我们自己去注册一个异常捕获函数，但是一些三方sdk经常会注册该函数（例如友盟，bugly等），就会存在问题。前面注册的会被后面注册覆盖。你需要去写一些兼容代码。且自家的应用接入友盟，bugly这种三方统计的sdk。<br>通过hook NSSetUncaughtExceptionHandler这个函数（ <a href=\"http://www.cocoachina.com/ios/20150701/12301.html\" target=\"_blank\" rel=\"noopener\">传送门</a>），清晰看到了app分别注册了三个handler，自己注册的，友盟注册的和bugly注册的。发生异常的时候，最终都被bugly的给拦截了。而进入到自己注册的异常处理函数。<br>Q:友盟是怎么统计到的？<br>A:这就很尴尬了。发现当bugly检测到异常，它会把该异常同时上报给友盟。<br>所以为了取巧，监控异常这部分通过初始化，由外部传入异常回调的函数从而达到监控异常的目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imy_load_main(IMYLoadAtPreMain, 0, ^&#123;</span><br><span class=\"line\">      // 注册安全模式</span><br><span class=\"line\">      [[IMY_AtomSDK shareInstance] regiterCrashProtectService];</span><br><span class=\"line\">      // 异常捕获回调   </span><br><span class=\"line\">      [[IMYAppReport shareInstance] addCrashReportLog:^NSString *_Nonnull(NSException *_Nonnull exception) &#123;</span><br><span class=\"line\">          [[IMY_AtomSDK shareInstance] regiterSafeModeService];</span><br><span class=\"line\">          return nil;</span><br><span class=\"line\">      &#125;];</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>3、如何安全检测？<br>既然保证了app在启动之前都会进入安全模式。进入该模式的时候，首先会维护一个闪退计数器，并且开启一个定时任务，若在该时间段了，app没有检测到任何异常发生，则会将该计数器清0。若检测到了闪退，则将该计数器+1。逻辑见上图。</p>\n<p>4、如何修复程序？<br>进入安全模式，获取闪退计数，在这里分别设置了三级保护措施，当闪退技术&gt;=2的时候，则会进入三级修复，会删除沙盒里的接口数据缓存文件。当闪退技术&gt;=3的时候，会删除接口数据缓存，同时也会删除JSpatch和RN的包。当闪退技术&gt;=5的时候，则会清空整个沙盒。修复完成之后，则会将闪退计数置为0。而应用则会恢复到初始状态。逻辑见上图。</p>\n<h3 id=\"进程守护-1\"><a href=\"#进程守护-1\" class=\"headerlink\" title=\"进程守护\"></a>进程守护</h3><h4 id=\"1、UI-Protect\"><a href=\"#1、UI-Protect\" class=\"headerlink\" title=\"1、UI_Protect\"></a>1、UI_Protect</h4><p>闪退场景：<br>iOS 上不建议在非主线程进行UI操作，在非主线程进行UI操作有很大几率会导致程序崩溃，或者出现预期之外的效果。</p>\n<p>实现思路：<br>通过Hook UIView类和CALayer类的一些方法来避免在非主线程执行UI操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView</span><br><span class=\"line\">1.setNeedsLayout</span><br><span class=\"line\">2.setNeedsDisplay</span><br><span class=\"line\">3.setNeedsUpdateConstraints</span><br><span class=\"line\">4.setNeedsDisplayInRect:</span><br><span class=\"line\"></span><br><span class=\"line\">CALayer</span><br><span class=\"line\">1.setNeedsLayout</span><br><span class=\"line\">2.setNeedsDisplay</span><br><span class=\"line\">3.setNeedsDisplayInRect:</span><br></pre></td></tr></table></figure></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断是否在主线程，不在则转移到主线程执行</span><br><span class=\"line\"> if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;</span><br><span class=\"line\">                                            // 调用原来的方法</span><br><span class=\"line\">                                        &#125; else &#123;</span><br><span class=\"line\">                                            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                                                 // 调用原来的方法</span><br><span class=\"line\">                                            &#125;);</span><br><span class=\"line\">                                        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、NSTimer-Protect\"><a href=\"#2、NSTimer-Protect\" class=\"headerlink\" title=\"2、NSTimer_Protect\"></a>2、NSTimer_Protect</h4><p>闪退场景：<br>NSTimer这个鬼使用的时候，需要非常小心，最常见的两个坑。<br>1.NSTimer会对target对象进行强引用，容易出现reatain circle。导致target无法释放，从而产生内存泄露。<br>2.在使用scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:做一个重复的定时任务的时候， repeats参数设置为YES，在你不需要的时候，要你手动调用invalidate来销毁定时器。因为定时器会被放进Runloop中，如果target对象释放了之后，Runloop触发了定时器的定时任务，会因为找不到target对象而引起crash。</p>\n<p>实现思路：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-2bf0a205872b5708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170918_29.png\"></p>\n<p>主要解决两个问题：<br>1.NSTimer对Target的强引用<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4bdef0bcb66acd4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170918_33.png\"></p>\n<p>2.自动invalidate的NSTimer</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-02cbd5ccfff260c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170918_34.png\"></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.hook</span><br><span class=\"line\"> static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        RSSwizzleClassMethod([NSTimer class], @selector(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:), RSSWReturnType(NSTimer *), RSSWArguments(NSTimeInterval ti, id aTarget, SEL aSelector, id userInfo, BOOL yesOrNo), RSSWReplacement(&#123;</span><br><span class=\"line\">                                 if (!_NSTimerCrashProtectEnable) &#123;</span><br><span class=\"line\">                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);</span><br><span class=\"line\">                                 &#125;</span><br><span class=\"line\">                                 NSTimer *timer = nil;</span><br><span class=\"line\">                                 if (yesOrNo) &#123;</span><br><span class=\"line\">                                     @autoreleasepool &#123;</span><br><span class=\"line\">                                         IMY_TimerStubProxy *proxy = [[IMY_TimerStubProxy alloc] init];</span><br><span class=\"line\">                                         proxy.target = aTarget;</span><br><span class=\"line\">                                         proxy.aSelector = aSelector;</span><br><span class=\"line\">                                         timer.timerProxy = proxy;</span><br><span class=\"line\">                                         timer = RSSWCallOriginal(ti, proxy, @selector(fireProxyTimer:), userInfo, yesOrNo);</span><br><span class=\"line\">                                         proxy.sourceTimer = timer;</span><br><span class=\"line\">                                     &#125;</span><br><span class=\"line\">                                     return timer;</span><br><span class=\"line\">                                 &#125; else &#123;</span><br><span class=\"line\">                                     return RSSWCallOriginal(ti, aTarget, aSelector, userInfo, yesOrNo);</span><br><span class=\"line\">                                 &#125;</span><br><span class=\"line\">                                 return nil;</span><br><span class=\"line\">                             &#125;));</span><br><span class=\"line\">        _NSTimerCrashProtectEnable = YES;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">2. fireProxyTimer：</span><br><span class=\"line\">- (void)fireProxyTimer:(id)userinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    id strongTarget = self.target;</span><br><span class=\"line\">    if (strongTarget &amp;&amp; ([strongTarget respondsToSelector:self.aSelector])) &#123;</span><br><span class=\"line\">#pragma clang diagnostic push</span><br><span class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class=\"line\">        [strongTarget performSelector:self.aSelector</span><br><span class=\"line\">                           withObject:userinfo];</span><br><span class=\"line\">#pragma clang diagnostic pop</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (self.sourceTimer) &#123;</span><br><span class=\"line\">            [self.sourceTimer invalidate];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]: Target is &lt;%@&gt; Method is &lt;%@&gt;, reason : an object dealloc not invalidate Timer.&quot;,</span><br><span class=\"line\">                                                      [self class], NSStringFromSelector(self.aSelector)];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, reason);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、NSNull-Protect\"><a href=\"#3、NSNull-Protect\" class=\"headerlink\" title=\"3、NSNull_Protect\"></a>3、NSNull_Protect</h4><p>闪退场景：<br>iOS中数组，字典等一些集合类，元素只能为OC对象，所以只能用NSNull来填空。在做数据解析的时候，经常遇到服务端返回的数据中带有null这种鬼，会被解析成NSNull这种对象。稍微不注意类型保护就会发生闪退。</p>\n<p>实现思路：<br>hook NSNull类的forwardingTargetForSelector:，将一些无法识别的消息发送给一些可以识别的集合类。</p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSSwizzleInstanceMethod([NSNull class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                                   if (!_NSNullCrashProtectEnable) &#123;</span><br><span class=\"line\">                                       return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\">                                   static NSArray *sTmpOutput = nil;</span><br><span class=\"line\">                                   if (sTmpOutput == nil) &#123;</span><br><span class=\"line\">                                       sTmpOutput = @[@&quot;&quot;, @0, @[], @&#123;&#125;];</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                   for (id tmpObj in sTmpOutput) &#123;</span><br><span class=\"line\">                                       if ([tmpObj respondsToSelector:aSelector]) &#123;</span><br><span class=\"line\">                                           return tmpObj;</span><br><span class=\"line\">                                       &#125;</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\">                                   return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                               &#125;),</span><br><span class=\"line\">                               RSSwizzleModeAlways, nil);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4、NSNotification-Protect\"><a href=\"#4、NSNotification-Protect\" class=\"headerlink\" title=\"4、NSNotification_Protect\"></a>4、NSNotification_Protect</h4><p>闪退场景：<br>在iOS9之前，通过addObserver:selector:name:object:监听通知。NSNotificatinonCenter会对观察者进行强引用，所以需要手动的在观察者对象挂了的时候移除通知监听。如果未移除监听，在观察者被释放的之后仍然会接收到通知那么就会发生闪退。</p>\n<p>实现思路：<br>主要是hook NSNotificationCenter的addObserver:selector:name:object:，凡是有添加过通知监听的对象，都会给该对象设置一个标识。在dealloc的hook中，判断需要释放的对象，是否有注册过通知监听，是则去移除通知。</p>\n<h4 id=\"5、UnrecognizedSelector-Protect\"><a href=\"#5、UnrecognizedSelector-Protect\" class=\"headerlink\" title=\"5、UnrecognizedSelector_Protect\"></a>5、UnrecognizedSelector_Protect</h4><p>闪退场景：<br>天天见。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-19552be78073a7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900\" alt=\"Snip20170925_22.png\"></p>\n<p>实现思路：<br>由于OC是一门动态类型的语言，它的方法调用其实是一种动态绑定的机制，也就是说方法调用是直到运行期才去确定的。<br>方法在调用时，系统会查看这个对象能否接收这个消息（查看这个类有没有这个方法，或者有没有实现这个方法。），牛逼的是，如果不能并且只在不能的情况下，就会调用下面这几个方法，给你“补救”的机会，你可以理解为几套防止程序crash的备选方案，苹果就是利用这几个方案进行消息转发，前一套方案实现后一套方法就不会执行。如果这几套方案你都没有做处理，那么程序就会报错crash。<br>完整的消息转发的流程如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-c0794df51a9ec109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170925_23.png\"></p>\n<p>主要是通过hook NSObject类的forwardingTargetForSelector：实例方法以及类方法。在该方法中将一些无法识别的方法，发送给一个stubProxy对象，且在运行时动态的给改stubProxy对象添加改SEL对应的方法实现(IMP)。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-b68da4e515176f62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Snip20170920_5.png\"></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSSwizzleInstanceMethod([NSObject class], @selector(forwardingTargetForSelector:), RSSWReturnType(id), RSSWArguments(SEL aSelector), RSSWReplacement(&#123;</span><br><span class=\"line\">                                if (!_UnrecognizedSelectorCrashProtectEnable) &#123;</span><br><span class=\"line\">                                    return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                BOOL aBool = [self respondsToSelector:aSelector];</span><br><span class=\"line\">                                // 获取消息签名</span><br><span class=\"line\">                                NSMethodSignature *signatrue = [self methodSignatureForSelector:aSelector];</span><br><span class=\"line\"></span><br><span class=\"line\">                                if (aBool || signatrue) &#123;</span><br><span class=\"line\">                                    return RSSWCallOriginal(aSelector);</span><br><span class=\"line\">                                &#125; else &#123;</span><br><span class=\"line\">                                    IMY_UnrecognizedSelector_StubProxy *stub = [[IMY_UnrecognizedSelector_StubProxy alloc] init];</span><br><span class=\"line\">                                    [stub addFunc:aSelector];</span><br><span class=\"line\">                                    NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]: unrecognizedSelector &lt;%@&gt; to instance &lt;%@&gt;&quot;,</span><br><span class=\"line\">                                                                                  NSStringFromSelector(aSelector), [self class]];</span><br><span class=\"line\">                                    NSLog(@&quot;%@&quot;, reason);</span><br><span class=\"line\">                                    return stub;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            &#125;),</span><br><span class=\"line\">                            RSSwizzleModeAlways, nil);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6、KVO-Protect\"><a href=\"#6、KVO-Protect\" class=\"headerlink\" title=\"6、KVO_Protect\"></a>6、KVO_Protect</h4><p>KVO 是 Objective-C 对观察者设计模式的一种实现。观察对象(例如A类)，当对象某个属性(例如A中的字符串name)发生更改时，监听对象会获得通知，并作出相应处理。且不需要给被观察的对象添加任何额外代码，就能使用的一种观察者模式。</p>\n<p>闪退场景：</p>\n<ul>\n<li><p>1.被观察者提前释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;An instance 0x600000018180 of class Student was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x600000032340&gt; (</span><br><span class=\"line\">&lt;NSKeyValueObservance 0x600000054d60: Observer: 0x7fe684608b40, Key path: name, Options: &lt;New: YES, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x60000005cb00&gt;</span><br><span class=\"line\">)&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.被观察者是局部变量</p>\n</li>\n<li><p>3.重复移除观察者 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;Cannot remove an observer &lt;TestViewController 0x7fdb13e0cf40&gt; for the key path &quot;view&quot; from &lt; TestViewController 0x7fdb13e0cf40&gt; because it is not registered as an observer.&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.观察者对象未实现observeValueForKeyPath:ofObject: change: context:方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;&lt; TestViewController: 0x7fc628f049e0&gt;: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</span><br><span class=\"line\">Key path: view</span><br><span class=\"line\">Observed object: &lt; TestViewController: 0x7fc628f049e0&gt;</span><br><span class=\"line\">Change: &#123;</span><br><span class=\"line\">    kind = 1;</span><br><span class=\"line\">    new = &quot;&lt;UIView: 0x7fc628d18810; frame = (0 0; 414 736); layer = &lt;CALayer: 0x60800002be00&gt;&gt;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Context: 0x0&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ps:重复添加观察者并不会引起crash，但是会多次触发相应事件。</p>\n<p>实现思路：<br>主要通过NSObject的分类，利用运行时给NSObject实例添加一个关联对象kvoProxy，该对象是用于管理当前对象的kvo关系(也就是观察者和被观察者的关系)，分别hook addObserver:forKeyPath:options:context:和removeObserver:forKeyPath:以及dealloc方法，在dealloc中移除真正的观察者对象。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-65735d525724bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"addObserver:forKeyPath:options:context:\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-72f9a4e0eb982742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"removeObserver:forKeyPath\"></p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSSwizzleInstanceMethod([NSObject class], @selector(addObserver:forKeyPath:options:context:), RSSWReturnType(void), RSSWArguments(NSObject * observer, NSString * keyPath, NSKeyValueObservingOptions options, void *context), RSSWReplacement(&#123;</span><br><span class=\"line\">                            // 忽略RAC</span><br><span class=\"line\">                            if (object_getClass(observer) == objc_getClass(&quot;RACKVOProxy&quot;)) &#123;</span><br><span class=\"line\">                                RSSWCallOriginal(observer, keyPath, options, context);</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            NSHashTable&lt;NSObject *&gt; *os = [self kvoProxy].kvoInfoMap[keyPath];</span><br><span class=\"line\">                            // 第一次的时候将KVOProxy添加为真正的观察者</span><br><span class=\"line\">                            if (os.count == 0) &#123; // (包括了 observers == nil 和 count == 0)</span><br><span class=\"line\">                                os = [[NSHashTable alloc] initWithOptions:(NSPointerFunctionsWeakMemory)capacity:0];</span><br><span class=\"line\">                                [os addObject:observer];</span><br><span class=\"line\">                                RSSWCallOriginal([self kvoProxy], keyPath, options, context);</span><br><span class=\"line\">                                [self kvoProxy].kvoInfoMap[keyPath] = os;</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            if ([os containsObject:observer]) &#123;</span><br><span class=\"line\">                                // 找到同样的观察者 不重复添加</span><br><span class=\"line\">                                NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]:KVO add Observer to many timers.Target is %@ method is %@ &quot;,</span><br><span class=\"line\">                                                                              [self class], NSStringFromSelector(@selector(addObserver:forKeyPath:options:context:))];</span><br><span class=\"line\">                                NSLog(@&quot;%@&quot;, reason);</span><br><span class=\"line\"></span><br><span class=\"line\">                            &#125; else &#123;</span><br><span class=\"line\">                                // 以后添加观察者直接往容器里面更新元素就行了</span><br><span class=\"line\">                                [os addObject:observer];</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;),</span><br><span class=\"line\">                        RSSwizzleModeAlways, nil);</span><br><span class=\"line\"></span><br><span class=\"line\">[RSSwizzle swizzleInstanceMethod:@selector(removeObserver:forKeyPath:)</span><br><span class=\"line\">                         inClass:[NSObject class]</span><br><span class=\"line\">                   newImpFactory:^id(RSSwizzleInfo *swizzleInfo) &#123;</span><br><span class=\"line\">                       return ^void(__unsafe_unretained id self, NSObject *observer, NSString *keyPath) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                           int (*originalIMP)(__unsafe_unretained id, SEL, NSObject *, NSString *);</span><br><span class=\"line\">                           originalIMP = (__typeof(originalIMP))[swizzleInfo getOriginalImplementation];</span><br><span class=\"line\">                           __imy_hook_orgin_function_removeObserver = originalIMP;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                           if (object_getClass(observer) == objc_getClass(&quot;RACKVOProxy&quot;)) &#123;</span><br><span class=\"line\">                               originalIMP(self, @selector(removeObserver:forKeyPath:), observer, keyPath);</span><br><span class=\"line\">                               return;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                           NSHashTable&lt;NSObject *&gt; *os = [self kvoProxy].kvoInfoMap[keyPath];</span><br><span class=\"line\">                           if (os.count == 0) &#123;</span><br><span class=\"line\">                               // 未找到观察者</span><br><span class=\"line\">                               NSString *reason = [NSString stringWithFormat:@&quot;[AtomSDK]: KVO remove Observer to many times.target is %@ method is %@,&quot;,</span><br><span class=\"line\">                                                                             [self class], NSStringFromSelector(@selector(removeObserver:forKeyPath:))];</span><br><span class=\"line\">                               NSLog(@&quot;[KVO]:%@&quot;, reason);</span><br><span class=\"line\"></span><br><span class=\"line\">                               return;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                           // 找到了观察者 移除</span><br><span class=\"line\">                           [os removeObject:observer];</span><br><span class=\"line\">                           // 为空时移除真正的观察者</span><br><span class=\"line\">                           if (os.count == 0) &#123;</span><br><span class=\"line\">                               //                                   NSLog(@&quot;[KVO]:REMOVE【%@】-【%@】-【%@】&quot;,self,observer,keyPath);</span><br><span class=\"line\">                               originalIMP(self, @selector(removeObserver:forKeyPath:), [self kvoProxy], keyPath);</span><br><span class=\"line\">                               [[self kvoProxy].kvoInfoMap removeObjectForKey:keyPath];</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                            mode:RSSwizzleModeAlways</span><br><span class=\"line\">                             key:NULL];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7、BadAccess-Protect\"><a href=\"#7、BadAccess-Protect\" class=\"headerlink\" title=\"7、BadAccess_Protect\"></a>7、BadAccess_Protect</h4><p>iOS中有空指针和野指针两种概念。空指针是没有存储任何内存地址的指针。如Student <em>s1 = NULL;和Student </em>s2 = nil;而野指针是指指向一个已删除的对象（”垃圾”内存既不可用内存）或未申请访问受限内存区域的指针。野指针是比较危险的。因为野指针指向的对象已经被释放了。通过野指针访问已经释放的对象crash其实不是必现的，因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。<br>BTW野指针的崩溃是比较随机的，你在测试的时候可能没发生crash，但是用户在使用的时候就可能发生crash了。</p>\n<p>闪退场景：<br>野指针闪退常见有以下几种情况：<br>1.对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。<br>2.对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。<br>3.对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。<br>4.对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。<br>5.对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）！！<br>6.对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-f460ae871ef8b723.gif?imageMogr2/auto-orient/strip\" alt=\"1467690258548317-1.gif\"></p>\n<p>实现思路：</p>\n<p>在app的当前进程中，如果我们额外向系统申请一块内存，用于存储那些已经被释放的对象。所以当一个对象被释放了时候，系统就会自动调用该对象的dealloc方法，在这个方法里面系统会释放该对象自身的一些属性，关联对象等等一些资源。然后，我们利用isa指针混淆技术，将该对象的类动态修改为一个僵尸类，且该僵尸对象可以处理任何方法。那么如果你向一个已经被释放的对象发送消息的时候，因为它存在于缓存池当中，那么也就不会产生野指针了。</p>\n<p>首先我们需要知道dealloc的方法里面系统干了些什么事儿。<br>因为OC中内存管理采用的是引用计数器的方式，即每个对象的散列表中都会存在一个int类型的变量表示该对象的被引用的次数，当该对象的引用计数为0的时候，由系统自动调用该对象的dealloc方法释放该对象的内存。并且父类的dealloc的方法将在子类dealloc方法返回后自动调用。（PS:你在跟我讲故事么。）</p>\n<p>通过查看Apple的runtime源码，可以看出ARC下的dealloc的实现原理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _objc_rootDealloc(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    assert(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    obj-&gt;rootDealloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void objc_object::rootDealloc()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (isTaggedPointer()) return;</span><br><span class=\"line\">    object_dispose((id)this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id object_dispose(id obj) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (UseGC) return _object_dispose(obj);</span><br><span class=\"line\">    else return (*_dealloc)(obj); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static id _object_dispose(id anObject) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (anObject==nil) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_destructInstance(anObject);</span><br><span class=\"line\">    </span><br><span class=\"line\">#if SUPPORT_GC</span><br><span class=\"line\">    if (UseGC) &#123;</span><br><span class=\"line\">        auto_zone_retain(gc_zone, anObject); // gc free expects rc==1</span><br><span class=\"line\">    &#125; else </span><br><span class=\"line\">#endif</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // only clobber isa for non-gc</span><br><span class=\"line\">        anObject-&gt;initIsa(_objc_getFreedObjectClass ()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(anObject);</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里能够清晰地看到在执行dealloc的时候，会先执行_objc_rootDealloc()函数。然后执行_object_dispose()，且在这个函数里干了三件事情：</p>\n<ul>\n<li><p>1.调用objc_destructInstance()释放对象的所有实例变量和关联对象(该方法并未回收对象本身内存).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *objc_destructInstance(id obj) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (obj) &#123;</span><br><span class=\"line\">        // Read all of the flags at once for performance.</span><br><span class=\"line\">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\">        bool dealloc = !UseGC;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This order is important.</span><br><span class=\"line\">        if (cxx) object_cxxDestruct(obj);</span><br><span class=\"line\">        if (assoc) _object_remove_assocations(obj);</span><br><span class=\"line\">        if (dealloc) obj-&gt;clearDeallocating();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.isa-swizzling将该对象的类置为一个空的类对象.</p>\n</li>\n<li>3.调用free()回收该对象的内存.</li>\n</ul>\n<p>所以我们需要在对象真正被释放的时机搞事情，有三个选择：</p>\n<ul>\n<li>1.运行时hook NSObject的dealloc方法。</li>\n<li>2.runtime object_dispose 。</li>\n<li>3.利用fishhook c的free()。<br>这三个调用栈顺序依次dealloc-&gt;object_dispose-&gt;free。所以还是选择hook最上层dealloc方法。主要针对OC对象的野指针。<br>流程图如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4d3a9e5d5c875e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/h/800\" alt=\"Snip20170929_35.png\"></li>\n</ul>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)IMY_BadAccess_dealloc &#123;</span><br><span class=\"line\">    NSObject *obj = (NSObject *)self;</span><br><span class=\"line\">    objc_destructInstance(self);</span><br><span class=\"line\">    object_setClass(self, [_IMYZombieObj class]);</span><br><span class=\"line\">    obj.oriClass = NSStringFromClass([self class]);</span><br><span class=\"line\">    dispatch_async(zombieOperationQueue, ^&#123;</span><br><span class=\"line\">        if (global_unfree_list-&gt;unfree_count &gt; MAX_UNFREE_POINTER * 0.9 || global_unfree_list-&gt;unfree_size &gt; MAX_UNFREE_MEM) &#123;</span><br><span class=\"line\">            freeMemInListSync(global_unfree_list, FREE_POINTER_NUM);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addUnFreeMemToListSync(global_unfree_list, (__bridge void *)(self));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"日常开发02：砸壳+Hook","date":"2017-03-10T09:46:00.000Z","_content":"> 项目中或多或少都需要接入一些三方sdk，那种静态库。然而产品就经常会提出那种无理的需求，让我们去改sdk的东西。要知道去改一个不知道源码的东西，还要在不影响原有功能的情况下去插入自己的逻辑在里面。是件很危险的事情。所以...\n\n![ed372f2eb9389b50f7c73c348c35e5dde6116e87.gif](http://upload-images.jianshu.io/upload_images/1488967-bdc0754b608af099.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n首先想到的就是利用切面编程去hook静态库里的某些方法。可是某些方法是指哪些方法？\n\n\n\n![N7Z0}{DL4OEU4(3S`($1UH7.gif](http://upload-images.jianshu.io/upload_images/1488967-81bcd73464d974bc.gif?imageMogr2/auto-orient/strip)\n\n---\n\n## 砸壳\n\n> 《iOS应用逆向工程》书中有提到一个工具(class-dump)，这个工具利用Objective-C的runtime特性，将存储在Mach-O文件中的头文件信息提取出来，并生成对应的.h文件。这样就能扒出来所有的头文件了。\n\n### 使用教程\n\n* 1.安装class-dump.dmg。\n\n* 2.将class-dump复制到'/usr/bin'目录下。\n\n  ```\n  sudo cp /Users/xxx/Desktop/class-dump '/usr/bin'\n  ```\n\n* 3.拿出你要扒的ipa包解压，得到.app文件。\n\n* 4.class-dump -H test.app -o testFile\n\n  ![屏幕快照 2016-09-07 下午12.09.24.png](http://upload-images.jianshu.io/upload_images/1488967-bbcfdc45bc1df7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK。接下来你看到桌面上出现一个文件夹![屏幕快照 2016-09-07 下午12.11.23.png](http://upload-images.jianshu.io/upload_images/1488967-151d981f3b434cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这么多头文件？小手一抖，点开看看吧。![屏幕快照 2016-09-07 下午12.12.05.png](http://upload-images.jianshu.io/upload_images/1488967-fbd09b88b9bb337c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你妹啊，近4000个头文件。\n\n好吧。剩下的就是在这4000份文件里，找到你要hook的那个类，那个方法。\n![D6E8D73FD503854EAD8084AB3298C4BC.jpg](http://upload-images.jianshu.io/upload_images/1488967-ae60e1453435432f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n经过多次尝试，总结了一些找方法的经验。\n\n* 1.断点，查看调用栈，根据调用栈判断最有可能的那个方法，从而缩小范围。\n* 2.配合runtime，打印class的所有方法名，属性的key和value。\n* 3.有时候，你hook的了某个类的某个方法，发现未生效，可能是该方法是继承与父类的，且自己没有重载父类的方法。这个时候需要hook父类的该方法。\n\n---\n\n## HOOK\n\n### 方法hook\n\n在oc中每个方法对应的都是一个sel和imp的映射，方法A的imp指针和方法B的imp指针进行了替换，并且在要替换的方法中调用了一下原来的方法实现。这个也是常用到的方法混淆。\n\n例如：\n\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n        \n        SEL originalSelector = @selector(test);\n        SEL swizzledSelector = @selector(swizzle_test);\n        \n        \n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        \n\n        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));\n        \n        if (didAddMethod) {\n            class_replaceMethod(class,\n                                swizzledSelector,\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)test {\n    NSLog(@\"test\");\n}\n- (void)swizzle_test {\n    [self swizzle_test];\n}\n```\n\n\n\n### 函数hook\n\n推荐使用[fishhook](https://github.com/facebook/fishhook )，使用起来很简单，内部实现复杂，很强，源码基本看不懂。大致原理还是要弄清楚的。\n\n例如有2个函数，函数A，函数B，想要将函数A的实现替换为函数B的实现。fishhook的实现大致分为2步，第一步找到目标函数的函数地址。第二步找到函数名，进行比对。匹配成功，替换目标函数地址为自己的函数地址。\n\n```\nstruct rebinding {\n    const char *name; // 目标函数名\n    void *replacement; // 替换函数\n    void **replaced; // 二级目标函数指针\n};\n/*\n  struct rebinding rebindings[]:要重新绑定的结构体数组\n  rebindings_nel：要重新绑定的函数个数\n*/\nint rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);\n\nint rebind_symbols_image(void *header,\n                         intptr_t slide,\n                         struct rebinding rebindings[],\n                         size_t rebindings_nel);\n```\n\n\n\n#### 例1\n\nhook Foundation库的NSSetUncaughtExceptionHandler()函数（生效）\n\n```\nstatic NSUncaughtExceptionHandler *g_vaildUncaughtExceptionHandler;\nstatic void (*ori_NSSetUncaughtExceptionHandler)( NSUncaughtExceptionHandler *_Nullable);\n\nvoid swizzle_NSSetUncaughtExceptionHandler( NSUncaughtExceptionHandler * handler) {\n    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();\n    if (g_vaildUncaughtExceptionHandler != NULL) {\n        NSLog(@\"UncaughtExceptionHandler=%p\",g_vaildUncaughtExceptionHandler);\n    }\n    ori_NSSetUncaughtExceptionHandler(handler);\n    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();\n}\n\nstatic void xr_uncaught_exception_handler (NSException *exception) {\n    NSLog(@\"XX\");\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        rebind_symbols((struct rebinding [1]){\"NSSetUncaughtExceptionHandler\",swizzle_NSSetUncaughtExceptionHandler,(void *)&ori_NSSetUncaughtExceptionHandler}, 1);\n        NSSetUncaughtExceptionHandler(&xr_uncaught_exception_handler);\n         [@[] objectAtIndex:1];\n        \n    }\n    return 0;\n}\n```\n\n\n\n#### 例2\n\nhook自己的函数（不生效）\n\n```\nvoid test(void) {\n    NSLog(@\"test\");\n}\nvoid swizzle_test(void) {\n    NSLog(@\"swizzle_test\");\n}\nstatic void (*funcptr)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        // 初始化一个 rebinding 结构体\n        struct rebinding test_rebinding = { \"test\", swizzle_test, (void *)&funcptr };\n        // 将结构体包装成数组，并传入数组的大小，对原符号 open 进行重绑定\n        rebind_symbols((struct rebinding[1]){test_rebinding}, 1);\n        // 调用原函数\n        test();\n        \n    }\n    return 0;\n}\n```\n\n\n\n函数的hook大致原理和方法hook类似。方法调用其实在运行时也就是转成一个个函数调用。根据方法名（SEL）去查找对应的方法实现的函数地址(IMP)，然后执行该函数。只不过函数和方法的存储空间不一样，查找函数地址的实现方法也就不一样。\n\n示例2中，我发现hook不生效。而示例1中可以。就很奇怪。查了资料，发现原来fishhook不能hook当前镜像（库或可执行文件）中运行的函数，当前镜像中的函数调用是直接通过函数地址调用。而其他镜像中的函数，是通过可执行文件中的符号化表去查找对应的函数地址，从而间接调用的函数。而fishhook就是在符号化表中做的手脚。那就能解释了实例2不生效的原因了。","source":"_posts/ios-daily-02.md","raw":"---\nlayout: post\ntitle: \"日常开发02：砸壳+Hook\"\ndate: 2017-03-10 17:46\ncategories: \n- 技术\n- [技术, iOS]\ntags: \n- 技术\n- iOS\n- 日常\n---\n> 项目中或多或少都需要接入一些三方sdk，那种静态库。然而产品就经常会提出那种无理的需求，让我们去改sdk的东西。要知道去改一个不知道源码的东西，还要在不影响原有功能的情况下去插入自己的逻辑在里面。是件很危险的事情。所以...\n\n![ed372f2eb9389b50f7c73c348c35e5dde6116e87.gif](http://upload-images.jianshu.io/upload_images/1488967-bdc0754b608af099.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n首先想到的就是利用切面编程去hook静态库里的某些方法。可是某些方法是指哪些方法？\n\n\n\n![N7Z0}{DL4OEU4(3S`($1UH7.gif](http://upload-images.jianshu.io/upload_images/1488967-81bcd73464d974bc.gif?imageMogr2/auto-orient/strip)\n\n---\n\n## 砸壳\n\n> 《iOS应用逆向工程》书中有提到一个工具(class-dump)，这个工具利用Objective-C的runtime特性，将存储在Mach-O文件中的头文件信息提取出来，并生成对应的.h文件。这样就能扒出来所有的头文件了。\n\n### 使用教程\n\n* 1.安装class-dump.dmg。\n\n* 2.将class-dump复制到'/usr/bin'目录下。\n\n  ```\n  sudo cp /Users/xxx/Desktop/class-dump '/usr/bin'\n  ```\n\n* 3.拿出你要扒的ipa包解压，得到.app文件。\n\n* 4.class-dump -H test.app -o testFile\n\n  ![屏幕快照 2016-09-07 下午12.09.24.png](http://upload-images.jianshu.io/upload_images/1488967-bbcfdc45bc1df7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK。接下来你看到桌面上出现一个文件夹![屏幕快照 2016-09-07 下午12.11.23.png](http://upload-images.jianshu.io/upload_images/1488967-151d981f3b434cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这么多头文件？小手一抖，点开看看吧。![屏幕快照 2016-09-07 下午12.12.05.png](http://upload-images.jianshu.io/upload_images/1488967-fbd09b88b9bb337c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你妹啊，近4000个头文件。\n\n好吧。剩下的就是在这4000份文件里，找到你要hook的那个类，那个方法。\n![D6E8D73FD503854EAD8084AB3298C4BC.jpg](http://upload-images.jianshu.io/upload_images/1488967-ae60e1453435432f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n经过多次尝试，总结了一些找方法的经验。\n\n* 1.断点，查看调用栈，根据调用栈判断最有可能的那个方法，从而缩小范围。\n* 2.配合runtime，打印class的所有方法名，属性的key和value。\n* 3.有时候，你hook的了某个类的某个方法，发现未生效，可能是该方法是继承与父类的，且自己没有重载父类的方法。这个时候需要hook父类的该方法。\n\n---\n\n## HOOK\n\n### 方法hook\n\n在oc中每个方法对应的都是一个sel和imp的映射，方法A的imp指针和方法B的imp指针进行了替换，并且在要替换的方法中调用了一下原来的方法实现。这个也是常用到的方法混淆。\n\n例如：\n\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n        \n        SEL originalSelector = @selector(test);\n        SEL swizzledSelector = @selector(swizzle_test);\n        \n        \n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        \n\n        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));\n        \n        if (didAddMethod) {\n            class_replaceMethod(class,\n                                swizzledSelector,\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)test {\n    NSLog(@\"test\");\n}\n- (void)swizzle_test {\n    [self swizzle_test];\n}\n```\n\n\n\n### 函数hook\n\n推荐使用[fishhook](https://github.com/facebook/fishhook )，使用起来很简单，内部实现复杂，很强，源码基本看不懂。大致原理还是要弄清楚的。\n\n例如有2个函数，函数A，函数B，想要将函数A的实现替换为函数B的实现。fishhook的实现大致分为2步，第一步找到目标函数的函数地址。第二步找到函数名，进行比对。匹配成功，替换目标函数地址为自己的函数地址。\n\n```\nstruct rebinding {\n    const char *name; // 目标函数名\n    void *replacement; // 替换函数\n    void **replaced; // 二级目标函数指针\n};\n/*\n  struct rebinding rebindings[]:要重新绑定的结构体数组\n  rebindings_nel：要重新绑定的函数个数\n*/\nint rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);\n\nint rebind_symbols_image(void *header,\n                         intptr_t slide,\n                         struct rebinding rebindings[],\n                         size_t rebindings_nel);\n```\n\n\n\n#### 例1\n\nhook Foundation库的NSSetUncaughtExceptionHandler()函数（生效）\n\n```\nstatic NSUncaughtExceptionHandler *g_vaildUncaughtExceptionHandler;\nstatic void (*ori_NSSetUncaughtExceptionHandler)( NSUncaughtExceptionHandler *_Nullable);\n\nvoid swizzle_NSSetUncaughtExceptionHandler( NSUncaughtExceptionHandler * handler) {\n    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();\n    if (g_vaildUncaughtExceptionHandler != NULL) {\n        NSLog(@\"UncaughtExceptionHandler=%p\",g_vaildUncaughtExceptionHandler);\n    }\n    ori_NSSetUncaughtExceptionHandler(handler);\n    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();\n}\n\nstatic void xr_uncaught_exception_handler (NSException *exception) {\n    NSLog(@\"XX\");\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        rebind_symbols((struct rebinding [1]){\"NSSetUncaughtExceptionHandler\",swizzle_NSSetUncaughtExceptionHandler,(void *)&ori_NSSetUncaughtExceptionHandler}, 1);\n        NSSetUncaughtExceptionHandler(&xr_uncaught_exception_handler);\n         [@[] objectAtIndex:1];\n        \n    }\n    return 0;\n}\n```\n\n\n\n#### 例2\n\nhook自己的函数（不生效）\n\n```\nvoid test(void) {\n    NSLog(@\"test\");\n}\nvoid swizzle_test(void) {\n    NSLog(@\"swizzle_test\");\n}\nstatic void (*funcptr)(void);\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        // 初始化一个 rebinding 结构体\n        struct rebinding test_rebinding = { \"test\", swizzle_test, (void *)&funcptr };\n        // 将结构体包装成数组，并传入数组的大小，对原符号 open 进行重绑定\n        rebind_symbols((struct rebinding[1]){test_rebinding}, 1);\n        // 调用原函数\n        test();\n        \n    }\n    return 0;\n}\n```\n\n\n\n函数的hook大致原理和方法hook类似。方法调用其实在运行时也就是转成一个个函数调用。根据方法名（SEL）去查找对应的方法实现的函数地址(IMP)，然后执行该函数。只不过函数和方法的存储空间不一样，查找函数地址的实现方法也就不一样。\n\n示例2中，我发现hook不生效。而示例1中可以。就很奇怪。查了资料，发现原来fishhook不能hook当前镜像（库或可执行文件）中运行的函数，当前镜像中的函数调用是直接通过函数地址调用。而其他镜像中的函数，是通过可执行文件中的符号化表去查找对应的函数地址，从而间接调用的函数。而fishhook就是在符号化表中做的手脚。那就能解释了实例2不生效的原因了。","slug":"ios-daily-02","published":1,"updated":"2019-12-20T06:08:22.050Z","comments":1,"photos":[],"link":"","_id":"ck4dsux39000sodnq188i83yi","content":"<blockquote>\n<p>项目中或多或少都需要接入一些三方sdk，那种静态库。然而产品就经常会提出那种无理的需求，让我们去改sdk的东西。要知道去改一个不知道源码的东西，还要在不影响原有功能的情况下去插入自己的逻辑在里面。是件很危险的事情。所以…</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-bdc0754b608af099.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ed372f2eb9389b50f7c73c348c35e5dde6116e87.gif\"></p>\n<a id=\"more\"></a>\n<p>首先想到的就是利用切面编程去hook静态库里的某些方法。可是某些方法是指哪些方法？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-81bcd73464d974bc.gif?imageMogr2/auto-orient/strip\" alt=\"N7Z0}{DL4OEU4(3S`($1UH7.gif\"></p>\n<hr>\n<h2 id=\"砸壳\"><a href=\"#砸壳\" class=\"headerlink\" title=\"砸壳\"></a>砸壳</h2><blockquote>\n<p>《iOS应用逆向工程》书中有提到一个工具(class-dump)，这个工具利用Objective-C的runtime特性，将存储在Mach-O文件中的头文件信息提取出来，并生成对应的.h文件。这样就能扒出来所有的头文件了。</p>\n</blockquote>\n<h3 id=\"使用教程\"><a href=\"#使用教程\" class=\"headerlink\" title=\"使用教程\"></a>使用教程</h3><ul>\n<li><p>1.安装class-dump.dmg。</p>\n</li>\n<li><p>2.将class-dump复制到’/usr/bin’目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp /Users/xxx/Desktop/class-dump &apos;/usr/bin&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.拿出你要扒的ipa包解压，得到.app文件。</p>\n</li>\n<li><p>4.class-dump -H test.app -o testFile</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-bbcfdc45bc1df7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-09-07 下午12.09.24.png\"></p>\n</li>\n</ul>\n<p>OK。接下来你看到桌面上出现一个文件夹<img src=\"http://upload-images.jianshu.io/upload_images/1488967-151d981f3b434cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-09-07 下午12.11.23.png\"></p>\n<p>这么多头文件？小手一抖，点开看看吧。<img src=\"http://upload-images.jianshu.io/upload_images/1488967-fbd09b88b9bb337c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-09-07 下午12.12.05.png\"></p>\n<p>你妹啊，近4000个头文件。</p>\n<p>好吧。剩下的就是在这4000份文件里，找到你要hook的那个类，那个方法。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-ae60e1453435432f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"D6E8D73FD503854EAD8084AB3298C4BC.jpg\"></p>\n<p>经过多次尝试，总结了一些找方法的经验。</p>\n<ul>\n<li>1.断点，查看调用栈，根据调用栈判断最有可能的那个方法，从而缩小范围。</li>\n<li>2.配合runtime，打印class的所有方法名，属性的key和value。</li>\n<li>3.有时候，你hook的了某个类的某个方法，发现未生效，可能是该方法是继承与父类的，且自己没有重载父类的方法。这个时候需要hook父类的该方法。</li>\n</ul>\n<hr>\n<h2 id=\"HOOK\"><a href=\"#HOOK\" class=\"headerlink\" title=\"HOOK\"></a>HOOK</h2><h3 id=\"方法hook\"><a href=\"#方法hook\" class=\"headerlink\" title=\"方法hook\"></a>方法hook</h3><p>在oc中每个方法对应的都是一个sel和imp的映射，方法A的imp指针和方法B的imp指针进行了替换，并且在要替换的方法中调用了一下原来的方法实现。这个也是常用到的方法混淆。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class class = [self class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(test);</span><br><span class=\"line\">        SEL swizzledSelector = @selector(swizzle_test);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (didAddMethod) &#123;</span><br><span class=\"line\">            class_replaceMethod(class,</span><br><span class=\"line\">                                swizzledSelector,</span><br><span class=\"line\">                                method_getImplementation(originalMethod),</span><br><span class=\"line\">                                method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;test&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)swizzle_test &#123;</span><br><span class=\"line\">    [self swizzle_test];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数hook\"><a href=\"#函数hook\" class=\"headerlink\" title=\"函数hook\"></a>函数hook</h3><p>推荐使用<a href=\"https://github.com/facebook/fishhook\" target=\"_blank\" rel=\"noopener\">fishhook</a>，使用起来很简单，内部实现复杂，很强，源码基本看不懂。大致原理还是要弄清楚的。</p>\n<p>例如有2个函数，函数A，函数B，想要将函数A的实现替换为函数B的实现。fishhook的实现大致分为2步，第一步找到目标函数的函数地址。第二步找到函数名，进行比对。匹配成功，替换目标函数地址为自己的函数地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct rebinding &#123;</span><br><span class=\"line\">    const char *name; // 目标函数名</span><br><span class=\"line\">    void *replacement; // 替换函数</span><br><span class=\"line\">    void **replaced; // 二级目标函数指针</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">/*</span><br><span class=\"line\">  struct rebinding rebindings[]:要重新绑定的结构体数组</span><br><span class=\"line\">  rebindings_nel：要重新绑定的函数个数</span><br><span class=\"line\">*/</span><br><span class=\"line\">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);</span><br><span class=\"line\"></span><br><span class=\"line\">int rebind_symbols_image(void *header,</span><br><span class=\"line\">                         intptr_t slide,</span><br><span class=\"line\">                         struct rebinding rebindings[],</span><br><span class=\"line\">                         size_t rebindings_nel);</span><br></pre></td></tr></table></figure>\n<h4 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h4><p>hook Foundation库的NSSetUncaughtExceptionHandler()函数（生效）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static NSUncaughtExceptionHandler *g_vaildUncaughtExceptionHandler;</span><br><span class=\"line\">static void (*ori_NSSetUncaughtExceptionHandler)( NSUncaughtExceptionHandler *_Nullable);</span><br><span class=\"line\"></span><br><span class=\"line\">void swizzle_NSSetUncaughtExceptionHandler( NSUncaughtExceptionHandler * handler) &#123;</span><br><span class=\"line\">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class=\"line\">    if (g_vaildUncaughtExceptionHandler != NULL) &#123;</span><br><span class=\"line\">        NSLog(@&quot;UncaughtExceptionHandler=%p&quot;,g_vaildUncaughtExceptionHandler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ori_NSSetUncaughtExceptionHandler(handler);</span><br><span class=\"line\">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void xr_uncaught_exception_handler (NSException *exception) &#123;</span><br><span class=\"line\">    NSLog(@&quot;XX&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        rebind_symbols((struct rebinding [1])&#123;&quot;NSSetUncaughtExceptionHandler&quot;,swizzle_NSSetUncaughtExceptionHandler,(void *)&amp;ori_NSSetUncaughtExceptionHandler&#125;, 1);</span><br><span class=\"line\">        NSSetUncaughtExceptionHandler(&amp;xr_uncaught_exception_handler);</span><br><span class=\"line\">         [@[] objectAtIndex:1];</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h4><p>hook自己的函数（不生效）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test(void) &#123;</span><br><span class=\"line\">    NSLog(@&quot;test&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void swizzle_test(void) &#123;</span><br><span class=\"line\">    NSLog(@&quot;swizzle_test&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static void (*funcptr)(void);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 初始化一个 rebinding 结构体</span><br><span class=\"line\">        struct rebinding test_rebinding = &#123; &quot;test&quot;, swizzle_test, (void *)&amp;funcptr &#125;;</span><br><span class=\"line\">        // 将结构体包装成数组，并传入数组的大小，对原符号 open 进行重绑定</span><br><span class=\"line\">        rebind_symbols((struct rebinding[1])&#123;test_rebinding&#125;, 1);</span><br><span class=\"line\">        // 调用原函数</span><br><span class=\"line\">        test();</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的hook大致原理和方法hook类似。方法调用其实在运行时也就是转成一个个函数调用。根据方法名（SEL）去查找对应的方法实现的函数地址(IMP)，然后执行该函数。只不过函数和方法的存储空间不一样，查找函数地址的实现方法也就不一样。</p>\n<p>示例2中，我发现hook不生效。而示例1中可以。就很奇怪。查了资料，发现原来fishhook不能hook当前镜像（库或可执行文件）中运行的函数，当前镜像中的函数调用是直接通过函数地址调用。而其他镜像中的函数，是通过可执行文件中的符号化表去查找对应的函数地址，从而间接调用的函数。而fishhook就是在符号化表中做的手脚。那就能解释了实例2不生效的原因了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>项目中或多或少都需要接入一些三方sdk，那种静态库。然而产品就经常会提出那种无理的需求，让我们去改sdk的东西。要知道去改一个不知道源码的东西，还要在不影响原有功能的情况下去插入自己的逻辑在里面。是件很危险的事情。所以…</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-bdc0754b608af099.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ed372f2eb9389b50f7c73c348c35e5dde6116e87.gif\"></p>","more":"<p>首先想到的就是利用切面编程去hook静态库里的某些方法。可是某些方法是指哪些方法？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-81bcd73464d974bc.gif?imageMogr2/auto-orient/strip\" alt=\"N7Z0}{DL4OEU4(3S`($1UH7.gif\"></p>\n<hr>\n<h2 id=\"砸壳\"><a href=\"#砸壳\" class=\"headerlink\" title=\"砸壳\"></a>砸壳</h2><blockquote>\n<p>《iOS应用逆向工程》书中有提到一个工具(class-dump)，这个工具利用Objective-C的runtime特性，将存储在Mach-O文件中的头文件信息提取出来，并生成对应的.h文件。这样就能扒出来所有的头文件了。</p>\n</blockquote>\n<h3 id=\"使用教程\"><a href=\"#使用教程\" class=\"headerlink\" title=\"使用教程\"></a>使用教程</h3><ul>\n<li><p>1.安装class-dump.dmg。</p>\n</li>\n<li><p>2.将class-dump复制到’/usr/bin’目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp /Users/xxx/Desktop/class-dump &apos;/usr/bin&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.拿出你要扒的ipa包解压，得到.app文件。</p>\n</li>\n<li><p>4.class-dump -H test.app -o testFile</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-bbcfdc45bc1df7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-09-07 下午12.09.24.png\"></p>\n</li>\n</ul>\n<p>OK。接下来你看到桌面上出现一个文件夹<img src=\"http://upload-images.jianshu.io/upload_images/1488967-151d981f3b434cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-09-07 下午12.11.23.png\"></p>\n<p>这么多头文件？小手一抖，点开看看吧。<img src=\"http://upload-images.jianshu.io/upload_images/1488967-fbd09b88b9bb337c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-09-07 下午12.12.05.png\"></p>\n<p>你妹啊，近4000个头文件。</p>\n<p>好吧。剩下的就是在这4000份文件里，找到你要hook的那个类，那个方法。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-ae60e1453435432f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"D6E8D73FD503854EAD8084AB3298C4BC.jpg\"></p>\n<p>经过多次尝试，总结了一些找方法的经验。</p>\n<ul>\n<li>1.断点，查看调用栈，根据调用栈判断最有可能的那个方法，从而缩小范围。</li>\n<li>2.配合runtime，打印class的所有方法名，属性的key和value。</li>\n<li>3.有时候，你hook的了某个类的某个方法，发现未生效，可能是该方法是继承与父类的，且自己没有重载父类的方法。这个时候需要hook父类的该方法。</li>\n</ul>\n<hr>\n<h2 id=\"HOOK\"><a href=\"#HOOK\" class=\"headerlink\" title=\"HOOK\"></a>HOOK</h2><h3 id=\"方法hook\"><a href=\"#方法hook\" class=\"headerlink\" title=\"方法hook\"></a>方法hook</h3><p>在oc中每个方法对应的都是一个sel和imp的映射，方法A的imp指针和方法B的imp指针进行了替换，并且在要替换的方法中调用了一下原来的方法实现。这个也是常用到的方法混淆。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class class = [self class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(test);</span><br><span class=\"line\">        SEL swizzledSelector = @selector(swizzle_test);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (didAddMethod) &#123;</span><br><span class=\"line\">            class_replaceMethod(class,</span><br><span class=\"line\">                                swizzledSelector,</span><br><span class=\"line\">                                method_getImplementation(originalMethod),</span><br><span class=\"line\">                                method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">    NSLog(@&quot;test&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)swizzle_test &#123;</span><br><span class=\"line\">    [self swizzle_test];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数hook\"><a href=\"#函数hook\" class=\"headerlink\" title=\"函数hook\"></a>函数hook</h3><p>推荐使用<a href=\"https://github.com/facebook/fishhook\" target=\"_blank\" rel=\"noopener\">fishhook</a>，使用起来很简单，内部实现复杂，很强，源码基本看不懂。大致原理还是要弄清楚的。</p>\n<p>例如有2个函数，函数A，函数B，想要将函数A的实现替换为函数B的实现。fishhook的实现大致分为2步，第一步找到目标函数的函数地址。第二步找到函数名，进行比对。匹配成功，替换目标函数地址为自己的函数地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct rebinding &#123;</span><br><span class=\"line\">    const char *name; // 目标函数名</span><br><span class=\"line\">    void *replacement; // 替换函数</span><br><span class=\"line\">    void **replaced; // 二级目标函数指针</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">/*</span><br><span class=\"line\">  struct rebinding rebindings[]:要重新绑定的结构体数组</span><br><span class=\"line\">  rebindings_nel：要重新绑定的函数个数</span><br><span class=\"line\">*/</span><br><span class=\"line\">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);</span><br><span class=\"line\"></span><br><span class=\"line\">int rebind_symbols_image(void *header,</span><br><span class=\"line\">                         intptr_t slide,</span><br><span class=\"line\">                         struct rebinding rebindings[],</span><br><span class=\"line\">                         size_t rebindings_nel);</span><br></pre></td></tr></table></figure>\n<h4 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h4><p>hook Foundation库的NSSetUncaughtExceptionHandler()函数（生效）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static NSUncaughtExceptionHandler *g_vaildUncaughtExceptionHandler;</span><br><span class=\"line\">static void (*ori_NSSetUncaughtExceptionHandler)( NSUncaughtExceptionHandler *_Nullable);</span><br><span class=\"line\"></span><br><span class=\"line\">void swizzle_NSSetUncaughtExceptionHandler( NSUncaughtExceptionHandler * handler) &#123;</span><br><span class=\"line\">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class=\"line\">    if (g_vaildUncaughtExceptionHandler != NULL) &#123;</span><br><span class=\"line\">        NSLog(@&quot;UncaughtExceptionHandler=%p&quot;,g_vaildUncaughtExceptionHandler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ori_NSSetUncaughtExceptionHandler(handler);</span><br><span class=\"line\">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void xr_uncaught_exception_handler (NSException *exception) &#123;</span><br><span class=\"line\">    NSLog(@&quot;XX&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        rebind_symbols((struct rebinding [1])&#123;&quot;NSSetUncaughtExceptionHandler&quot;,swizzle_NSSetUncaughtExceptionHandler,(void *)&amp;ori_NSSetUncaughtExceptionHandler&#125;, 1);</span><br><span class=\"line\">        NSSetUncaughtExceptionHandler(&amp;xr_uncaught_exception_handler);</span><br><span class=\"line\">         [@[] objectAtIndex:1];</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h4><p>hook自己的函数（不生效）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test(void) &#123;</span><br><span class=\"line\">    NSLog(@&quot;test&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void swizzle_test(void) &#123;</span><br><span class=\"line\">    NSLog(@&quot;swizzle_test&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static void (*funcptr)(void);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 初始化一个 rebinding 结构体</span><br><span class=\"line\">        struct rebinding test_rebinding = &#123; &quot;test&quot;, swizzle_test, (void *)&amp;funcptr &#125;;</span><br><span class=\"line\">        // 将结构体包装成数组，并传入数组的大小，对原符号 open 进行重绑定</span><br><span class=\"line\">        rebind_symbols((struct rebinding[1])&#123;test_rebinding&#125;, 1);</span><br><span class=\"line\">        // 调用原函数</span><br><span class=\"line\">        test();</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的hook大致原理和方法hook类似。方法调用其实在运行时也就是转成一个个函数调用。根据方法名（SEL）去查找对应的方法实现的函数地址(IMP)，然后执行该函数。只不过函数和方法的存储空间不一样，查找函数地址的实现方法也就不一样。</p>\n<p>示例2中，我发现hook不生效。而示例1中可以。就很奇怪。查了资料，发现原来fishhook不能hook当前镜像（库或可执行文件）中运行的函数，当前镜像中的函数调用是直接通过函数地址调用。而其他镜像中的函数，是通过可执行文件中的符号化表去查找对应的函数地址，从而间接调用的函数。而fishhook就是在符号化表中做的手脚。那就能解释了实例2不生效的原因了。</p>"},{"layout":"post","title":"学习笔记01：OC的对象模型","date":"2015-05-10T05:36:00.000Z","_content":"\n> OC作为一门面向对象语言。不管是学习阶段还是工作阶段。每天都是在和各种各样的类以及对象打交道。\n>\n> 什么是类？什么是对象？这是一个最初的问题。\n\n## 1.什么是类？什么是对象？\n对象是对客观事物的抽象，类是对对象的抽象，类是一种抽象的数据类。它们的关系是对象是类的实例，类是对象的模板。\n哈。绕口令么。这个解释太官方。\n\n关于类。我自己理解为类就是你所能看到的一切事物的特征和行为的集合的一个抽象。而对象则是某一个类（抽象）的具体实现。\n<!-- more -->\n\n## 2.对象是怎么被创建出来的？\n栗如创建一个叫zs的Person实例：Person *zs = [Person alloc] init];\n在OC中这段代码做了些什么？\n\n首先有了一个Person类。调用了+alloc方法然后调用了+init方法。创建了一个Person实例。接下来用了一个Person类型的指针引用这个实例。\n\n  * 那+alloc方法里面又做了些什么？\n    * 为该对象分配足够的内存 \n    * 将该新对象的引用计数 (Retain Count) 设置成 1。\n    * 将该新对象的 isa指针指向它的类。\n    * 将该新对象的所有其它成员变量的值设置成零。\n  * +init方法又做了些什么？\n    * init方法也叫初始化方法，字面理解就是初始化一些成员变量。比如我们想要zs对象在创建出来，身高就为180cm，体重60kg，战斗力1000+等等这些属性值。所以我们可以重载init方法。在这里面设置对象的一些成员变量的初始值。\n\n\n## 3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\n这一串的问题。在一开始的时候困惑了我很长的一段是时间。其实这些问题最终都指向一个答案，也就是类和对象的内存结构。\n\n![1413628797629491.png](http://upload-images.jianshu.io/upload_images/1488967-42b2c729e2ccb283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOC是C的一个超集。在C中能够描述一组不同数据类型的变量的集合也就是结构体。所以在OC中不管是对象还是类。本质也就是结构体。那就容易理解了。isa指针就相当于一个标识，标识某个对象或某个类所属的类型。OC既然是一门OOP的语言。那么superclass也就是表示当前类的继承结构。所以在类和元类中，都具有isa和superclass这两个成员变量。而对象只有isa。那么就能解释了。通过类创建了对象，对象的isa指针指向的类。而类是由元类创建出来的，所以类的isa指针指向元类。那么superclass指针呢。因为OC不支持多继承，只能单继承，那么superclass指针理解起来就比较容易了。\n到了这里，脑子里又冒出来一个疑问。这种类和对象的isa指针总不能无限制的下去吧，总归是要形成一个闭环或者指向一个创世类吧？所以答案也就是图中最顶层的根类（RootClass）以及根元类的isa和superclass指针的指向了。原来所有的元类的isa指针都指向根元类，而根类的isa指针同样指向根元类，最终根元类的superclass指针指向的是元类。这样就很好的形成了一个闭环。\n这样也就顺带解决了我另外的一个疑问，OC是在运行时动态检测对象的所属的真实类型。那么它是怎么检测的呢？答案也就是上面那幅图。对象在创建的时候就已经初始化好了isa指针。那么运行时也就是根据这个isa指针找到它所属的真实类型。\n\n## 4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\n\n好吧，又是一长串问题。答案的是OC中的方法调用。首先还是先上图，更加直观的了解类和对象的内存结构。\n![屏幕快照 2016-06-20 下午1.14.11.png](http://upload-images.jianshu.io/upload_images/1488967-d99981018e89101a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上图是类的内存结构，最主要的是ivars，methodLists以及cache这三张表。简单的理解就是ivars存储的是该类所有的成员变量。methodLists存储的是该类的所有的对象方法（又或者类对象方法）。cache存储的是methodLists中执行过的方法的方法缓存。\n类结构中methodLists表中存储的是对象方法。元类的methodLists存储的是类方法。例如对象方法的调用步骤是，首先根据isa指针确定该对象所属的真实类型，找到该类之后，首先会去cache表中查找有没有这个方法缓存。如果没有，才去methodLists表中查找方法，如果找到了，执行该方法，并将该方法添加进cache表中。如果没有找到就会沿着superclass指针去父类中按步骤依次查找。对于对象方法，以上的这些执行步骤都是在类的结构中去查找的。而类方法却是根据类的isa指针去元类的结构体中执行的。所以这也就能解释，为什么对象方法只能由对象来调用，而类方法只能由类来调用了。\n\n","source":"_posts/ios_stduy_note_01.md","raw":"---\nlayout: post\ntitle: \"学习笔记01：OC的对象模型\"\ndate: 2015-05-10 13:36\ncategories: \n- 技术\n- [技术, OC]\ntags: \n- 技术\n- OC\n- 笔记\n---\n\n> OC作为一门面向对象语言。不管是学习阶段还是工作阶段。每天都是在和各种各样的类以及对象打交道。\n>\n> 什么是类？什么是对象？这是一个最初的问题。\n\n## 1.什么是类？什么是对象？\n对象是对客观事物的抽象，类是对对象的抽象，类是一种抽象的数据类。它们的关系是对象是类的实例，类是对象的模板。\n哈。绕口令么。这个解释太官方。\n\n关于类。我自己理解为类就是你所能看到的一切事物的特征和行为的集合的一个抽象。而对象则是某一个类（抽象）的具体实现。\n<!-- more -->\n\n## 2.对象是怎么被创建出来的？\n栗如创建一个叫zs的Person实例：Person *zs = [Person alloc] init];\n在OC中这段代码做了些什么？\n\n首先有了一个Person类。调用了+alloc方法然后调用了+init方法。创建了一个Person实例。接下来用了一个Person类型的指针引用这个实例。\n\n  * 那+alloc方法里面又做了些什么？\n    * 为该对象分配足够的内存 \n    * 将该新对象的引用计数 (Retain Count) 设置成 1。\n    * 将该新对象的 isa指针指向它的类。\n    * 将该新对象的所有其它成员变量的值设置成零。\n  * +init方法又做了些什么？\n    * init方法也叫初始化方法，字面理解就是初始化一些成员变量。比如我们想要zs对象在创建出来，身高就为180cm，体重60kg，战斗力1000+等等这些属性值。所以我们可以重载init方法。在这里面设置对象的一些成员变量的初始值。\n\n\n## 3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\n这一串的问题。在一开始的时候困惑了我很长的一段是时间。其实这些问题最终都指向一个答案，也就是类和对象的内存结构。\n\n![1413628797629491.png](http://upload-images.jianshu.io/upload_images/1488967-42b2c729e2ccb283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOC是C的一个超集。在C中能够描述一组不同数据类型的变量的集合也就是结构体。所以在OC中不管是对象还是类。本质也就是结构体。那就容易理解了。isa指针就相当于一个标识，标识某个对象或某个类所属的类型。OC既然是一门OOP的语言。那么superclass也就是表示当前类的继承结构。所以在类和元类中，都具有isa和superclass这两个成员变量。而对象只有isa。那么就能解释了。通过类创建了对象，对象的isa指针指向的类。而类是由元类创建出来的，所以类的isa指针指向元类。那么superclass指针呢。因为OC不支持多继承，只能单继承，那么superclass指针理解起来就比较容易了。\n到了这里，脑子里又冒出来一个疑问。这种类和对象的isa指针总不能无限制的下去吧，总归是要形成一个闭环或者指向一个创世类吧？所以答案也就是图中最顶层的根类（RootClass）以及根元类的isa和superclass指针的指向了。原来所有的元类的isa指针都指向根元类，而根类的isa指针同样指向根元类，最终根元类的superclass指针指向的是元类。这样就很好的形成了一个闭环。\n这样也就顺带解决了我另外的一个疑问，OC是在运行时动态检测对象的所属的真实类型。那么它是怎么检测的呢？答案也就是上面那幅图。对象在创建的时候就已经初始化好了isa指针。那么运行时也就是根据这个isa指针找到它所属的真实类型。\n\n## 4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\n\n好吧，又是一长串问题。答案的是OC中的方法调用。首先还是先上图，更加直观的了解类和对象的内存结构。\n![屏幕快照 2016-06-20 下午1.14.11.png](http://upload-images.jianshu.io/upload_images/1488967-d99981018e89101a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上图是类的内存结构，最主要的是ivars，methodLists以及cache这三张表。简单的理解就是ivars存储的是该类所有的成员变量。methodLists存储的是该类的所有的对象方法（又或者类对象方法）。cache存储的是methodLists中执行过的方法的方法缓存。\n类结构中methodLists表中存储的是对象方法。元类的methodLists存储的是类方法。例如对象方法的调用步骤是，首先根据isa指针确定该对象所属的真实类型，找到该类之后，首先会去cache表中查找有没有这个方法缓存。如果没有，才去methodLists表中查找方法，如果找到了，执行该方法，并将该方法添加进cache表中。如果没有找到就会沿着superclass指针去父类中按步骤依次查找。对于对象方法，以上的这些执行步骤都是在类的结构中去查找的。而类方法却是根据类的isa指针去元类的结构体中执行的。所以这也就能解释，为什么对象方法只能由对象来调用，而类方法只能由类来调用了。\n\n","slug":"ios_stduy_note_01","published":1,"updated":"2019-12-20T06:08:22.050Z","comments":1,"photos":[],"link":"","_id":"ck4dsux3a000uodnq1xbt6x9t","content":"<blockquote>\n<p>OC作为一门面向对象语言。不管是学习阶段还是工作阶段。每天都是在和各种各样的类以及对象打交道。</p>\n<p>什么是类？什么是对象？这是一个最初的问题。</p>\n</blockquote>\n<h2 id=\"1-什么是类？什么是对象？\"><a href=\"#1-什么是类？什么是对象？\" class=\"headerlink\" title=\"1.什么是类？什么是对象？\"></a>1.什么是类？什么是对象？</h2><p>对象是对客观事物的抽象，类是对对象的抽象，类是一种抽象的数据类。它们的关系是对象是类的实例，类是对象的模板。<br>哈。绕口令么。这个解释太官方。</p>\n<p>关于类。我自己理解为类就是你所能看到的一切事物的特征和行为的集合的一个抽象。而对象则是某一个类（抽象）的具体实现。<br><a id=\"more\"></a></p>\n<h2 id=\"2-对象是怎么被创建出来的？\"><a href=\"#2-对象是怎么被创建出来的？\" class=\"headerlink\" title=\"2.对象是怎么被创建出来的？\"></a>2.对象是怎么被创建出来的？</h2><p>栗如创建一个叫zs的Person实例：Person *zs = [Person alloc] init];<br>在OC中这段代码做了些什么？</p>\n<p>首先有了一个Person类。调用了+alloc方法然后调用了+init方法。创建了一个Person实例。接下来用了一个Person类型的指针引用这个实例。</p>\n<ul>\n<li>那+alloc方法里面又做了些什么？<ul>\n<li>为该对象分配足够的内存 </li>\n<li>将该新对象的引用计数 (Retain Count) 设置成 1。</li>\n<li>将该新对象的 isa指针指向它的类。</li>\n<li>将该新对象的所有其它成员变量的值设置成零。</li>\n</ul>\n</li>\n<li>+init方法又做了些什么？<ul>\n<li>init方法也叫初始化方法，字面理解就是初始化一些成员变量。比如我们想要zs对象在创建出来，身高就为180cm，体重60kg，战斗力1000+等等这些属性值。所以我们可以重载init方法。在这里面设置对象的一些成员变量的初始值。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\"><a href=\"#3-什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\" class=\"headerlink\" title=\"3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\"></a>3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？</h2><p>这一串的问题。在一开始的时候困惑了我很长的一段是时间。其实这些问题最终都指向一个答案，也就是类和对象的内存结构。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-42b2c729e2ccb283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1413628797629491.png\"></p>\n<p>OC是C的一个超集。在C中能够描述一组不同数据类型的变量的集合也就是结构体。所以在OC中不管是对象还是类。本质也就是结构体。那就容易理解了。isa指针就相当于一个标识，标识某个对象或某个类所属的类型。OC既然是一门OOP的语言。那么superclass也就是表示当前类的继承结构。所以在类和元类中，都具有isa和superclass这两个成员变量。而对象只有isa。那么就能解释了。通过类创建了对象，对象的isa指针指向的类。而类是由元类创建出来的，所以类的isa指针指向元类。那么superclass指针呢。因为OC不支持多继承，只能单继承，那么superclass指针理解起来就比较容易了。<br>到了这里，脑子里又冒出来一个疑问。这种类和对象的isa指针总不能无限制的下去吧，总归是要形成一个闭环或者指向一个创世类吧？所以答案也就是图中最顶层的根类（RootClass）以及根元类的isa和superclass指针的指向了。原来所有的元类的isa指针都指向根元类，而根类的isa指针同样指向根元类，最终根元类的superclass指针指向的是元类。这样就很好的形成了一个闭环。<br>这样也就顺带解决了我另外的一个疑问，OC是在运行时动态检测对象的所属的真实类型。那么它是怎么检测的呢？答案也就是上面那幅图。对象在创建的时候就已经初始化好了isa指针。那么运行时也就是根据这个isa指针找到它所属的真实类型。</p>\n<h2 id=\"4-类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\"><a href=\"#4-类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\" class=\"headerlink\" title=\"4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\"></a>4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？</h2><p>好吧，又是一长串问题。答案的是OC中的方法调用。首先还是先上图，更加直观的了解类和对象的内存结构。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-d99981018e89101a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-06-20 下午1.14.11.png\"></p>\n<p>上图是类的内存结构，最主要的是ivars，methodLists以及cache这三张表。简单的理解就是ivars存储的是该类所有的成员变量。methodLists存储的是该类的所有的对象方法（又或者类对象方法）。cache存储的是methodLists中执行过的方法的方法缓存。<br>类结构中methodLists表中存储的是对象方法。元类的methodLists存储的是类方法。例如对象方法的调用步骤是，首先根据isa指针确定该对象所属的真实类型，找到该类之后，首先会去cache表中查找有没有这个方法缓存。如果没有，才去methodLists表中查找方法，如果找到了，执行该方法，并将该方法添加进cache表中。如果没有找到就会沿着superclass指针去父类中按步骤依次查找。对于对象方法，以上的这些执行步骤都是在类的结构中去查找的。而类方法却是根据类的isa指针去元类的结构体中执行的。所以这也就能解释，为什么对象方法只能由对象来调用，而类方法只能由类来调用了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>OC作为一门面向对象语言。不管是学习阶段还是工作阶段。每天都是在和各种各样的类以及对象打交道。</p>\n<p>什么是类？什么是对象？这是一个最初的问题。</p>\n</blockquote>\n<h2 id=\"1-什么是类？什么是对象？\"><a href=\"#1-什么是类？什么是对象？\" class=\"headerlink\" title=\"1.什么是类？什么是对象？\"></a>1.什么是类？什么是对象？</h2><p>对象是对客观事物的抽象，类是对对象的抽象，类是一种抽象的数据类。它们的关系是对象是类的实例，类是对象的模板。<br>哈。绕口令么。这个解释太官方。</p>\n<p>关于类。我自己理解为类就是你所能看到的一切事物的特征和行为的集合的一个抽象。而对象则是某一个类（抽象）的具体实现。<br>","more":"</p>\n<h2 id=\"2-对象是怎么被创建出来的？\"><a href=\"#2-对象是怎么被创建出来的？\" class=\"headerlink\" title=\"2.对象是怎么被创建出来的？\"></a>2.对象是怎么被创建出来的？</h2><p>栗如创建一个叫zs的Person实例：Person *zs = [Person alloc] init];<br>在OC中这段代码做了些什么？</p>\n<p>首先有了一个Person类。调用了+alloc方法然后调用了+init方法。创建了一个Person实例。接下来用了一个Person类型的指针引用这个实例。</p>\n<ul>\n<li>那+alloc方法里面又做了些什么？<ul>\n<li>为该对象分配足够的内存 </li>\n<li>将该新对象的引用计数 (Retain Count) 设置成 1。</li>\n<li>将该新对象的 isa指针指向它的类。</li>\n<li>将该新对象的所有其它成员变量的值设置成零。</li>\n</ul>\n</li>\n<li>+init方法又做了些什么？<ul>\n<li>init方法也叫初始化方法，字面理解就是初始化一些成员变量。比如我们想要zs对象在创建出来，身高就为180cm，体重60kg，战斗力1000+等等这些属性值。所以我们可以重载init方法。在这里面设置对象的一些成员变量的初始值。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\"><a href=\"#3-什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\" class=\"headerlink\" title=\"3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？\"></a>3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？</h2><p>这一串的问题。在一开始的时候困惑了我很长的一段是时间。其实这些问题最终都指向一个答案，也就是类和对象的内存结构。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-42b2c729e2ccb283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1413628797629491.png\"></p>\n<p>OC是C的一个超集。在C中能够描述一组不同数据类型的变量的集合也就是结构体。所以在OC中不管是对象还是类。本质也就是结构体。那就容易理解了。isa指针就相当于一个标识，标识某个对象或某个类所属的类型。OC既然是一门OOP的语言。那么superclass也就是表示当前类的继承结构。所以在类和元类中，都具有isa和superclass这两个成员变量。而对象只有isa。那么就能解释了。通过类创建了对象，对象的isa指针指向的类。而类是由元类创建出来的，所以类的isa指针指向元类。那么superclass指针呢。因为OC不支持多继承，只能单继承，那么superclass指针理解起来就比较容易了。<br>到了这里，脑子里又冒出来一个疑问。这种类和对象的isa指针总不能无限制的下去吧，总归是要形成一个闭环或者指向一个创世类吧？所以答案也就是图中最顶层的根类（RootClass）以及根元类的isa和superclass指针的指向了。原来所有的元类的isa指针都指向根元类，而根类的isa指针同样指向根元类，最终根元类的superclass指针指向的是元类。这样就很好的形成了一个闭环。<br>这样也就顺带解决了我另外的一个疑问，OC是在运行时动态检测对象的所属的真实类型。那么它是怎么检测的呢？答案也就是上面那幅图。对象在创建的时候就已经初始化好了isa指针。那么运行时也就是根据这个isa指针找到它所属的真实类型。</p>\n<h2 id=\"4-类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\"><a href=\"#4-类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\" class=\"headerlink\" title=\"4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？\"></a>4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？</h2><p>好吧，又是一长串问题。答案的是OC中的方法调用。首先还是先上图，更加直观的了解类和对象的内存结构。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-d99981018e89101a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-06-20 下午1.14.11.png\"></p>\n<p>上图是类的内存结构，最主要的是ivars，methodLists以及cache这三张表。简单的理解就是ivars存储的是该类所有的成员变量。methodLists存储的是该类的所有的对象方法（又或者类对象方法）。cache存储的是methodLists中执行过的方法的方法缓存。<br>类结构中methodLists表中存储的是对象方法。元类的methodLists存储的是类方法。例如对象方法的调用步骤是，首先根据isa指针确定该对象所属的真实类型，找到该类之后，首先会去cache表中查找有没有这个方法缓存。如果没有，才去methodLists表中查找方法，如果找到了，执行该方法，并将该方法添加进cache表中。如果没有找到就会沿着superclass指针去父类中按步骤依次查找。对于对象方法，以上的这些执行步骤都是在类的结构中去查找的。而类方法却是根据类的isa指针去元类的结构体中执行的。所以这也就能解释，为什么对象方法只能由对象来调用，而类方法只能由类来调用了。</p>"},{"layout":"post","title":"学习笔记02：OC的消息机制","date":"2015-05-11T06:36:00.000Z","_content":"举个栗子！！！\nPerson.h\n```objective-c\n#import <Foundation/Foundation.h>\n@interface Person : NSObject\n- (void)eat;\n@end\n```\nPerson.m\n``` objective-c\n#import \"Person.h\"\n@implementation Person\n- (void)eat {\n    NSLog(@\"eat...\");\n}\n@end\n```\n<!-- more -->\nMain.m\n```objective-c\n#import <Foundation/Foundation.h>\n#import \"Person.h\"\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *p = [[Person alloc] init];\n    }\n    return 0;\n}\n```\n\n#### 1.如何调用p对象的eat方法呢？除了[p eat]这种方式，还有没有其他方式能够调用eat方法？如果我在.h文件中没有eat方法的声明，又如何调用？\n\n* 1>直接调用\n\n  ```objective-c\n  [p eat];\n  ```\n\n\n* 2>通过performSelector\n\n  ```objective-c\n  if ([p respondsToSelector:@selector(eat)]) { // 判断方法是否存在，防止方法不存在导致闪退\n  \t[p performSelector:@selector(eat)];\n  }\n  ```\n\n\n* 3>利用NSInvovation\n\n  ```objective-c\n  // 获取方法签名\n  NSMethodSignature *sign = [[p class] instanceMethodSignatureForSelector:selector];\n  // 创建invocation对象\n  NSInvocation *eatIvo = [NSInvocation invocationWithMethodSignature:sign];\n  eatIvo.target = p;\n  eatIvo.selector = selector;\n  [eatIvo invoke];\n  ```\n\n* 4>运行时消息函数\n\n  ```objective-c\n   objc_msgSend(p,@selector(eat));\n  ```\n**PS:**\n在Xcode7中直接调用objc_msgSend函数会报错。主要是因为编译器会检查你objc_msgSend函数调用。解决办法有2种：\n\n  * 1.强转  \n\n       ```objective-c\n       Class class = [p class];\n       ((void * ()(void, SEL))(void*)objc_msgSend)(&class, @selector(eat));\n       ```\n\n  * 2.Build Settings->Enable Strict Checking of objec_msgSend Calls 设置为YES\n\n方法调用的几种方式。那么一开始的那个疑问，如果-eat方法只有实现，在.h文件中而没有声明，这样外部也就无法调用到-eat方法了。当然还是可以利用上述2，3，4种方式来调用。又在想，如果做绝一点，连Person类都不让你知道呢？我又该怎么创建Person类的实例？怎么调用p对象的那个-eat方法呢？这时候就需要用到运行时。获取到类名还有类的所有方法名。利用反射将字符串转变为类，方法等等。同样可以利用2,3,4来调用方法。那是不是可以认为在OC中没有严格意义上的私有方法呢。\n\n#### 2.OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\n一大串的问题。对于消息这东西，思绪是乱的。静下心来一点点的梳理一遍，也是受益很多，对于OC也有了更深的理解。\n* \n  1.SEL是什么？SEL也叫方法选择器，它的定义如下：\n  ```c\n  typedef struct objc_selector *SEL;\n  ```\n  其实就是一个特殊的结构体类型的指针，而该结构体就是对每个方法的方法名，参数序列等等一些信息的描述。\n\n  关于SEL其实就是一个根据方法名哈希处理后的一个用来标识某个方法的一个唯一标识而已。一个SEL就代表着一个方法。通过这个SEL就能找到对应的方法实现。使用哈希处理后的方法名而不用方法名去做标识，这样提高了查找方法实现的效率。\n  ps：\n\n  * @selector()只是个编译器指令。在编译期会自动将这部分转换为对应的代码。\n  * 在某一个类或该类的继承体系中，如果出现两个方法名相同的方法，即使参数不同。他们生成的SEL也是一样的。所以OC中某一个类或该类的继承体系中最好不要出现两个相同方法名的方法。\n\n* 2.动态绑定\n  OC既然是动态语言，重要的一个体现就是动态绑定。OC是在运行时确定对象所属的真实类型。确定类型之后，才会将对应的属性和响应的消息绑定到该对象上。\n\n* 3.方法\n  我们知道类的结构中有一个MethodLists表。里面存储的都是一个个方法。该结构体中主要就SEL（方法选择）和IMP（方法实现）。简单理解该结构体就相当于是在SEL和IMP之间做了一个映射。方便我们通过SEL找到对应的IMP。\n\n  内存结构如下：\n\n  ```c\n   typedef struct objc_method *Method;\n   struct objc_method {\n      SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名\n      char *method_types                  OBJC2_UNAVAILABLE;\n      IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现\n  }\n  ```\n\n\n* 4.发消息\n  [p eat];通常我们说对象p调用了eat方法，也可以说向p对象发送了一条eat的消息。这两种说法。我觉得后面那种方式更加形象也更加准确。\n  那这句话的背后系统又干了些什么？是时候推开门进去看一看了。\n  在编译时期，编译器会将大部分的方法转换为函数，如objc_msgSend(),obj_msgSendSuper()等等。而在运行时期，消息才会被绑定到方法上。\n  例如：\n      [p eat];\n      在编译时则会转换为：objc_msgSend(p,@selector(eat));这样的函数。\n  objc_msgSend()是什么？\n  ```\n  objc_msgSend(receiver, selector, arg1, arg2, ...)\n  receiver：消息接收者\n  selector：方法选择器\n  arg：其他参数\n  ```\n\n\n\n\n* 5.消息传递\n  画个图吧。画好了。\n\n\n![消息传递过程.png](http://upload-images.jianshu.io/upload_images/1488967-adec86257f242c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n因为OC的动态特性。所以它会运行时确定该对象或该类所属的真实类型，也就是根isa指针去找它的真实类型。确定类型后，首先它会去cache表里面根据SEL去找IMP(方法实现函数)。没有的话，她就会去MethodLists里面找。找到了就去执行对应的IMP，并且她会将这个方法扔到Cache里面。如果在MethodLists里面也没找着。她回去根据superclass区她的父类按照这个顺序去查找方法实现。直到根类为止。从这里也就能看出来OC的方法调用其实走的是一个缓存机制。提高了方法调用的效率。\n\n* 消息转发\n  刚才说到了消息传递。有个疑问。如果在在Person.m中干掉-eat方法实现呢？那么整套流程走了下来。都没有找到那个方法会出现什么情况？答案当然是unrecognized selector sent to instance 0x2b2b2b2b..类似的字样，并且闪退。\n  所以，系统在经过消息传递过程后，还没有找到这个方法，那么它又偷偷摸摸的干了些什么呢？给不给机会挽回一下呢？\n  点开NSObject类的头文件。\n\n  ![NSObject.png](http://upload-images.jianshu.io/upload_images/1488967-1ada22c46563f0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n发现了四个方法。这四个方法也就是用来实现消息转发的。也是用来给你没有实现那个方法的过错进行补救的。当然OC是人性化的。她一共给了你三次机会。消息转发的具体步骤如下：\n1.方案一。如果是实例方法，会调用+ (BOOL)resolveInstanceMethod:(SEL)sel；方法。如果是类方法，则调用+ (BOOL)resolveClassMethod:(SEL)sel；\n这两个方法的作用也就是让你在程序运行时动态的为一个selector提供实现。\n栗如上面的那个疑问。我在Person.m中干掉了-eat的实现。则可以通过重载这个方法动态添加-eat的方法实现。\n\n```objective-c\n@implementation Person\nvoid eatIMP(id self ,SEL _cmd) {\n    NSLog(@\"eat...\");\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(eat)) {\n        class_addMethod([self class], sel, (IMP)eatIMP, \"v@:\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n```\n\n 这里用到了class_addMethod()函数；\n```          objective-c\nBOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)\ncls：添加方法到指定的类。\nname：方法选择器\nimp：方法实现\ntypes：请参考Objective-C Runtime Programming Guide-类型编码\n```\n([ Objective-C Runtime Programming Guide-类型编码](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html ))\n\n这种方式让我们有机会在运行时通过resolveInstanceMethod或resolveClassMethod中动态的将某个方法实现添加到类中。那问题就来了。就一个方法实现而已。还要弄这么多代码。有毛用啊？\n这个动态方法解析主要是为了解决@dynamic属性而存在的。\n\n那么我又要举手了。@dynamic又是什么鬼？\n@dynamic 其实就是要是关键字。是相对于 @synthesize 的，它们用样用于修饰 @property，用于生成对应的的 getter 和 setter 方法。但是 @ dynamic 表示这个成员变量的 getter 和 setter 方法并不是直接由编译器生成，而是手工生成或者运行时生成。\n\n\n2.方案二\n如果方案一你自己没有处理的话。就会来到- (id)forwardingTargetForSelector:(SEL)selector；这个方法。这个方法主要是用来将这个消息发送给一个可以处理的对象的。栗如：我收到了一个bug，我处理不了，我基友说他可以。那我通过这个方法我就可以把这个bug转发给我基友了。\n栗如：\n```objective-c\nPerson.h\n\n#import <Foundation/Foundation.h>\n#import \"Dog.h\"\n@interface Person : NSObject\n@property (nonatomic, strong) Dog *dog;\n- (void)eat;\n@end\n\nPerson.m\n\n#import \"Person.h\"\n@implementation Person\n\n- (void)eat {\n    NSLog(@\"eat...\");\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(bark)) {\n        return self.dog;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n@end\n\n```\n\n```objective-c\nDog.h\n\n#import <Foundation/Foundation.h>\n@interface Dog : NSObject\n- (void)bark;\n@end\n\n\nDog.m\n\n#import \"Dog.h\"\n@implementation Dog\n- (void)bark {\n    NSLog(@\"wangwang...\");\n}\n@end\n```\n\n```\nmain.m\n\n#import <Foundation/Foundation.h>\n#import \"Person.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init];\n        Person *oldWang = [[Person alloc] init];\n        oldWang.dog = dog;\n        \n        [oldWang performSelector:@selector(bark)];\n    }\n    return 0;\n}\n```\n人有一只狗。狗有一个叫的方法。在main.m中我分别创建了一个Dog实例，还有个Person实例。并且将dog赋值给了oldWang的dog属性是不是。\n那么现在oldWang有了一条dog。[oldWang performSelector:@selector(bark)];我们让oldWang像狗狗一样的叫。很明显不可能的是吧。所以我们在Person中重载了forwardingTargetForSelector方法。在这里面将bark这条消息发送给了dog属性。\n\nPS:\n这种方式看起来蛮有意思的。混搭有没有。人可以飞。猪可以上树。但是有一个很大的局限性。具体执行这些行为的都不是对象本身。而是该对象持有的其他对象或者其他对象。感觉有点狐假虎威。\n\n使用场景：这种方式只适用于我们只想将消息转发到另一个能处理该消息的对象上，而并不能处理消息的参数和返回值。\n\n方案三：\n好吧。再假设你第一步和第二步都没有做处理。事不过三。那就给你最后一次机会。- (void)forwardInvocation:(NSInvocation *)anInvocation。\n\n这一次运行时系统会将消息打包成一个NSInvocation对象。启动完整的消息转发机制。\n\n那么forwardInvocation：干了些什么呢？\n* 1.定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。\n* 2.使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。\n\n还是用代码说话。瞎逼逼谁不会啊。\n还是刚才的代码。只不过改了下Person的实现文件。oldWang有一个dog。让oldWang像狗一样的叫。\n\n```objective-c\n#import \"Person.h\"\n\n@implementation Person\n\n- (void)eat {\n    NSLog(@\"eat...\");\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    NSMethodSignature *sign = [super methodSignatureForSelector:aSelector];\n    if (!sign) {\n        sign = [[self.dog class] instanceMethodSignatureForSelector:@selector(bark)];\n    }\n    return sign;\n}\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    if (anInvocation) {\n        [anInvocation invokeWithTarget:self.dog];\n    }\n}\n@end\n```\n\n在这里，我们重载了methodSignatureForSelector方法，这里需要返回一个非nil的NSMethodSignature对象。然后在forwardInvocation里进行转发消息。所以你可以在methodSignatureForSelector方法里对所有未识别的消息进行签名。感觉就像是个加工厂。消息想要进入forwardInvocation转发前必须经过这里包装下。接下来运行时系统会将这里NSMethodSignature对象自动打包成一个个NSInvocation对象。进入forwardInvocation，将消息发送出去。\n\n其实这里，一开始我有过一个疑问，既然OC不支持多继承。那么通过消息转发这种形式，不是很像是多继承吗？后来发现，它和多继承最大区别是在于，多继承是在于集中。而这种方式却更像是在分散。将不同的功能分散到不同的对象身上。\n\n到了这里OC中的消息转发也差不多了。那么我又有疑问了。知道了这么多，有毛用？不知道我也能干活。\n通过查阅资料，Demo。总结了消息转发的几个用途。\n* 创建一个对象负责把消息转发给一个由其它对象组成的响应链，代理对象会在这个有其它对象组成的集合里寻找能够处理该消息的对象； \n* 把一个对象包在一个logger对象里，用来拦截或者纪录一些有趣的消息调用；\n* 比如声明类的属性为dynamic，使用自定义的方法来截取和取代由系统自动生成的getter和setter方法。\n\n\n\n![异常.jpg](http://upload-images.jianshu.io/upload_images/1488967-0707de44c067caeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/ios_stduy_note_02.md","raw":"---\nlayout: post\ntitle: \"学习笔记02：OC的消息机制\"\ndate: 2015-05-11 14:36\ncategories: \n- 技术\n- [技术, OC]\ntags: \n- 技术\n- OC\n- 笔记\n---\n举个栗子！！！\nPerson.h\n```objective-c\n#import <Foundation/Foundation.h>\n@interface Person : NSObject\n- (void)eat;\n@end\n```\nPerson.m\n``` objective-c\n#import \"Person.h\"\n@implementation Person\n- (void)eat {\n    NSLog(@\"eat...\");\n}\n@end\n```\n<!-- more -->\nMain.m\n```objective-c\n#import <Foundation/Foundation.h>\n#import \"Person.h\"\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person *p = [[Person alloc] init];\n    }\n    return 0;\n}\n```\n\n#### 1.如何调用p对象的eat方法呢？除了[p eat]这种方式，还有没有其他方式能够调用eat方法？如果我在.h文件中没有eat方法的声明，又如何调用？\n\n* 1>直接调用\n\n  ```objective-c\n  [p eat];\n  ```\n\n\n* 2>通过performSelector\n\n  ```objective-c\n  if ([p respondsToSelector:@selector(eat)]) { // 判断方法是否存在，防止方法不存在导致闪退\n  \t[p performSelector:@selector(eat)];\n  }\n  ```\n\n\n* 3>利用NSInvovation\n\n  ```objective-c\n  // 获取方法签名\n  NSMethodSignature *sign = [[p class] instanceMethodSignatureForSelector:selector];\n  // 创建invocation对象\n  NSInvocation *eatIvo = [NSInvocation invocationWithMethodSignature:sign];\n  eatIvo.target = p;\n  eatIvo.selector = selector;\n  [eatIvo invoke];\n  ```\n\n* 4>运行时消息函数\n\n  ```objective-c\n   objc_msgSend(p,@selector(eat));\n  ```\n**PS:**\n在Xcode7中直接调用objc_msgSend函数会报错。主要是因为编译器会检查你objc_msgSend函数调用。解决办法有2种：\n\n  * 1.强转  \n\n       ```objective-c\n       Class class = [p class];\n       ((void * ()(void, SEL))(void*)objc_msgSend)(&class, @selector(eat));\n       ```\n\n  * 2.Build Settings->Enable Strict Checking of objec_msgSend Calls 设置为YES\n\n方法调用的几种方式。那么一开始的那个疑问，如果-eat方法只有实现，在.h文件中而没有声明，这样外部也就无法调用到-eat方法了。当然还是可以利用上述2，3，4种方式来调用。又在想，如果做绝一点，连Person类都不让你知道呢？我又该怎么创建Person类的实例？怎么调用p对象的那个-eat方法呢？这时候就需要用到运行时。获取到类名还有类的所有方法名。利用反射将字符串转变为类，方法等等。同样可以利用2,3,4来调用方法。那是不是可以认为在OC中没有严格意义上的私有方法呢。\n\n#### 2.OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\n一大串的问题。对于消息这东西，思绪是乱的。静下心来一点点的梳理一遍，也是受益很多，对于OC也有了更深的理解。\n* \n  1.SEL是什么？SEL也叫方法选择器，它的定义如下：\n  ```c\n  typedef struct objc_selector *SEL;\n  ```\n  其实就是一个特殊的结构体类型的指针，而该结构体就是对每个方法的方法名，参数序列等等一些信息的描述。\n\n  关于SEL其实就是一个根据方法名哈希处理后的一个用来标识某个方法的一个唯一标识而已。一个SEL就代表着一个方法。通过这个SEL就能找到对应的方法实现。使用哈希处理后的方法名而不用方法名去做标识，这样提高了查找方法实现的效率。\n  ps：\n\n  * @selector()只是个编译器指令。在编译期会自动将这部分转换为对应的代码。\n  * 在某一个类或该类的继承体系中，如果出现两个方法名相同的方法，即使参数不同。他们生成的SEL也是一样的。所以OC中某一个类或该类的继承体系中最好不要出现两个相同方法名的方法。\n\n* 2.动态绑定\n  OC既然是动态语言，重要的一个体现就是动态绑定。OC是在运行时确定对象所属的真实类型。确定类型之后，才会将对应的属性和响应的消息绑定到该对象上。\n\n* 3.方法\n  我们知道类的结构中有一个MethodLists表。里面存储的都是一个个方法。该结构体中主要就SEL（方法选择）和IMP（方法实现）。简单理解该结构体就相当于是在SEL和IMP之间做了一个映射。方便我们通过SEL找到对应的IMP。\n\n  内存结构如下：\n\n  ```c\n   typedef struct objc_method *Method;\n   struct objc_method {\n      SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名\n      char *method_types                  OBJC2_UNAVAILABLE;\n      IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现\n  }\n  ```\n\n\n* 4.发消息\n  [p eat];通常我们说对象p调用了eat方法，也可以说向p对象发送了一条eat的消息。这两种说法。我觉得后面那种方式更加形象也更加准确。\n  那这句话的背后系统又干了些什么？是时候推开门进去看一看了。\n  在编译时期，编译器会将大部分的方法转换为函数，如objc_msgSend(),obj_msgSendSuper()等等。而在运行时期，消息才会被绑定到方法上。\n  例如：\n      [p eat];\n      在编译时则会转换为：objc_msgSend(p,@selector(eat));这样的函数。\n  objc_msgSend()是什么？\n  ```\n  objc_msgSend(receiver, selector, arg1, arg2, ...)\n  receiver：消息接收者\n  selector：方法选择器\n  arg：其他参数\n  ```\n\n\n\n\n* 5.消息传递\n  画个图吧。画好了。\n\n\n![消息传递过程.png](http://upload-images.jianshu.io/upload_images/1488967-adec86257f242c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n因为OC的动态特性。所以它会运行时确定该对象或该类所属的真实类型，也就是根isa指针去找它的真实类型。确定类型后，首先它会去cache表里面根据SEL去找IMP(方法实现函数)。没有的话，她就会去MethodLists里面找。找到了就去执行对应的IMP，并且她会将这个方法扔到Cache里面。如果在MethodLists里面也没找着。她回去根据superclass区她的父类按照这个顺序去查找方法实现。直到根类为止。从这里也就能看出来OC的方法调用其实走的是一个缓存机制。提高了方法调用的效率。\n\n* 消息转发\n  刚才说到了消息传递。有个疑问。如果在在Person.m中干掉-eat方法实现呢？那么整套流程走了下来。都没有找到那个方法会出现什么情况？答案当然是unrecognized selector sent to instance 0x2b2b2b2b..类似的字样，并且闪退。\n  所以，系统在经过消息传递过程后，还没有找到这个方法，那么它又偷偷摸摸的干了些什么呢？给不给机会挽回一下呢？\n  点开NSObject类的头文件。\n\n  ![NSObject.png](http://upload-images.jianshu.io/upload_images/1488967-1ada22c46563f0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n发现了四个方法。这四个方法也就是用来实现消息转发的。也是用来给你没有实现那个方法的过错进行补救的。当然OC是人性化的。她一共给了你三次机会。消息转发的具体步骤如下：\n1.方案一。如果是实例方法，会调用+ (BOOL)resolveInstanceMethod:(SEL)sel；方法。如果是类方法，则调用+ (BOOL)resolveClassMethod:(SEL)sel；\n这两个方法的作用也就是让你在程序运行时动态的为一个selector提供实现。\n栗如上面的那个疑问。我在Person.m中干掉了-eat的实现。则可以通过重载这个方法动态添加-eat的方法实现。\n\n```objective-c\n@implementation Person\nvoid eatIMP(id self ,SEL _cmd) {\n    NSLog(@\"eat...\");\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(eat)) {\n        class_addMethod([self class], sel, (IMP)eatIMP, \"v@:\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n@end\n```\n\n 这里用到了class_addMethod()函数；\n```          objective-c\nBOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)\ncls：添加方法到指定的类。\nname：方法选择器\nimp：方法实现\ntypes：请参考Objective-C Runtime Programming Guide-类型编码\n```\n([ Objective-C Runtime Programming Guide-类型编码](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html ))\n\n这种方式让我们有机会在运行时通过resolveInstanceMethod或resolveClassMethod中动态的将某个方法实现添加到类中。那问题就来了。就一个方法实现而已。还要弄这么多代码。有毛用啊？\n这个动态方法解析主要是为了解决@dynamic属性而存在的。\n\n那么我又要举手了。@dynamic又是什么鬼？\n@dynamic 其实就是要是关键字。是相对于 @synthesize 的，它们用样用于修饰 @property，用于生成对应的的 getter 和 setter 方法。但是 @ dynamic 表示这个成员变量的 getter 和 setter 方法并不是直接由编译器生成，而是手工生成或者运行时生成。\n\n\n2.方案二\n如果方案一你自己没有处理的话。就会来到- (id)forwardingTargetForSelector:(SEL)selector；这个方法。这个方法主要是用来将这个消息发送给一个可以处理的对象的。栗如：我收到了一个bug，我处理不了，我基友说他可以。那我通过这个方法我就可以把这个bug转发给我基友了。\n栗如：\n```objective-c\nPerson.h\n\n#import <Foundation/Foundation.h>\n#import \"Dog.h\"\n@interface Person : NSObject\n@property (nonatomic, strong) Dog *dog;\n- (void)eat;\n@end\n\nPerson.m\n\n#import \"Person.h\"\n@implementation Person\n\n- (void)eat {\n    NSLog(@\"eat...\");\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(bark)) {\n        return self.dog;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n@end\n\n```\n\n```objective-c\nDog.h\n\n#import <Foundation/Foundation.h>\n@interface Dog : NSObject\n- (void)bark;\n@end\n\n\nDog.m\n\n#import \"Dog.h\"\n@implementation Dog\n- (void)bark {\n    NSLog(@\"wangwang...\");\n}\n@end\n```\n\n```\nmain.m\n\n#import <Foundation/Foundation.h>\n#import \"Person.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Dog *dog = [[Dog alloc] init];\n        Person *oldWang = [[Person alloc] init];\n        oldWang.dog = dog;\n        \n        [oldWang performSelector:@selector(bark)];\n    }\n    return 0;\n}\n```\n人有一只狗。狗有一个叫的方法。在main.m中我分别创建了一个Dog实例，还有个Person实例。并且将dog赋值给了oldWang的dog属性是不是。\n那么现在oldWang有了一条dog。[oldWang performSelector:@selector(bark)];我们让oldWang像狗狗一样的叫。很明显不可能的是吧。所以我们在Person中重载了forwardingTargetForSelector方法。在这里面将bark这条消息发送给了dog属性。\n\nPS:\n这种方式看起来蛮有意思的。混搭有没有。人可以飞。猪可以上树。但是有一个很大的局限性。具体执行这些行为的都不是对象本身。而是该对象持有的其他对象或者其他对象。感觉有点狐假虎威。\n\n使用场景：这种方式只适用于我们只想将消息转发到另一个能处理该消息的对象上，而并不能处理消息的参数和返回值。\n\n方案三：\n好吧。再假设你第一步和第二步都没有做处理。事不过三。那就给你最后一次机会。- (void)forwardInvocation:(NSInvocation *)anInvocation。\n\n这一次运行时系统会将消息打包成一个NSInvocation对象。启动完整的消息转发机制。\n\n那么forwardInvocation：干了些什么呢？\n* 1.定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。\n* 2.使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。\n\n还是用代码说话。瞎逼逼谁不会啊。\n还是刚才的代码。只不过改了下Person的实现文件。oldWang有一个dog。让oldWang像狗一样的叫。\n\n```objective-c\n#import \"Person.h\"\n\n@implementation Person\n\n- (void)eat {\n    NSLog(@\"eat...\");\n}\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    NSMethodSignature *sign = [super methodSignatureForSelector:aSelector];\n    if (!sign) {\n        sign = [[self.dog class] instanceMethodSignatureForSelector:@selector(bark)];\n    }\n    return sign;\n}\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    if (anInvocation) {\n        [anInvocation invokeWithTarget:self.dog];\n    }\n}\n@end\n```\n\n在这里，我们重载了methodSignatureForSelector方法，这里需要返回一个非nil的NSMethodSignature对象。然后在forwardInvocation里进行转发消息。所以你可以在methodSignatureForSelector方法里对所有未识别的消息进行签名。感觉就像是个加工厂。消息想要进入forwardInvocation转发前必须经过这里包装下。接下来运行时系统会将这里NSMethodSignature对象自动打包成一个个NSInvocation对象。进入forwardInvocation，将消息发送出去。\n\n其实这里，一开始我有过一个疑问，既然OC不支持多继承。那么通过消息转发这种形式，不是很像是多继承吗？后来发现，它和多继承最大区别是在于，多继承是在于集中。而这种方式却更像是在分散。将不同的功能分散到不同的对象身上。\n\n到了这里OC中的消息转发也差不多了。那么我又有疑问了。知道了这么多，有毛用？不知道我也能干活。\n通过查阅资料，Demo。总结了消息转发的几个用途。\n* 创建一个对象负责把消息转发给一个由其它对象组成的响应链，代理对象会在这个有其它对象组成的集合里寻找能够处理该消息的对象； \n* 把一个对象包在一个logger对象里，用来拦截或者纪录一些有趣的消息调用；\n* 比如声明类的属性为dynamic，使用自定义的方法来截取和取代由系统自动生成的getter和setter方法。\n\n\n\n![异常.jpg](http://upload-images.jianshu.io/upload_images/1488967-0707de44c067caeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"ios_stduy_note_02","published":1,"updated":"2019-12-20T06:08:22.051Z","comments":1,"photos":[],"link":"","_id":"ck4dsux3b000xodnqatbbboj8","content":"<p>举个栗子！！！<br>Person.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">- (void)eat;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>Person.m<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (void)eat &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>Main.m<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Person *p = [[Person alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-如何调用p对象的eat方法呢？除了-p-eat-这种方式，还有没有其他方式能够调用eat方法？如果我在-h文件中没有eat方法的声明，又如何调用？\"><a href=\"#1-如何调用p对象的eat方法呢？除了-p-eat-这种方式，还有没有其他方式能够调用eat方法？如果我在-h文件中没有eat方法的声明，又如何调用？\" class=\"headerlink\" title=\"1.如何调用p对象的eat方法呢？除了[p eat]这种方式，还有没有其他方式能够调用eat方法？如果我在.h文件中没有eat方法的声明，又如何调用？\"></a>1.如何调用p对象的eat方法呢？除了[p eat]这种方式，还有没有其他方式能够调用eat方法？如果我在.h文件中没有eat方法的声明，又如何调用？</h4><ul>\n<li><p>1&gt;直接调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[p eat];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2&gt;通过performSelector</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([p respondsToSelector:@selector(eat)]) &#123; // 判断方法是否存在，防止方法不存在导致闪退</span><br><span class=\"line\">\t[p performSelector:@selector(eat)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3&gt;利用NSInvovation</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取方法签名</span><br><span class=\"line\">NSMethodSignature *sign = [[p class] instanceMethodSignatureForSelector:selector];</span><br><span class=\"line\">// 创建invocation对象</span><br><span class=\"line\">NSInvocation *eatIvo = [NSInvocation invocationWithMethodSignature:sign];</span><br><span class=\"line\">eatIvo.target = p;</span><br><span class=\"line\">eatIvo.selector = selector;</span><br><span class=\"line\">[eatIvo invoke];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4&gt;运行时消息函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(p,@selector(eat));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>PS:</strong><br>在Xcode7中直接调用objc_msgSend函数会报错。主要是因为编译器会检查你objc_msgSend函数调用。解决办法有2种：</p>\n<ul>\n<li><p>1.强转  </p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class = [p class];</span><br><span class=\"line\">((void * ()(void, SEL))(void*)objc_msgSend)(&amp;class, @selector(eat));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.Build Settings-&gt;Enable Strict Checking of objec_msgSend Calls 设置为YES</p>\n</li>\n</ul>\n<p>方法调用的几种方式。那么一开始的那个疑问，如果-eat方法只有实现，在.h文件中而没有声明，这样外部也就无法调用到-eat方法了。当然还是可以利用上述2，3，4种方式来调用。又在想，如果做绝一点，连Person类都不让你知道呢？我又该怎么创建Person类的实例？怎么调用p对象的那个-eat方法呢？这时候就需要用到运行时。获取到类名还有类的所有方法名。利用反射将字符串转变为类，方法等等。同样可以利用2,3,4来调用方法。那是不是可以认为在OC中没有严格意义上的私有方法呢。</p>\n<h4 id=\"2-OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\"><a href=\"#2-OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\" class=\"headerlink\" title=\"2.OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\"></a>2.OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？</h4><p>一大串的问题。对于消息这东西，思绪是乱的。静下心来一点点的梳理一遍，也是受益很多，对于OC也有了更深的理解。</p>\n<ul>\n<li><p>1.SEL是什么？SEL也叫方法选择器，它的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>;</span></span><br></pre></td></tr></table></figure>\n<p>其实就是一个特殊的结构体类型的指针，而该结构体就是对每个方法的方法名，参数序列等等一些信息的描述。</p>\n<p>关于SEL其实就是一个根据方法名哈希处理后的一个用来标识某个方法的一个唯一标识而已。一个SEL就代表着一个方法。通过这个SEL就能找到对应的方法实现。使用哈希处理后的方法名而不用方法名去做标识，这样提高了查找方法实现的效率。<br>ps：</p>\n<ul>\n<li>@selector()只是个编译器指令。在编译期会自动将这部分转换为对应的代码。</li>\n<li>在某一个类或该类的继承体系中，如果出现两个方法名相同的方法，即使参数不同。他们生成的SEL也是一样的。所以OC中某一个类或该类的继承体系中最好不要出现两个相同方法名的方法。</li>\n</ul>\n</li>\n<li><p>2.动态绑定<br>OC既然是动态语言，重要的一个体现就是动态绑定。OC是在运行时确定对象所属的真实类型。确定类型之后，才会将对应的属性和响应的消息绑定到该对象上。</p>\n</li>\n<li><p>3.方法<br>我们知道类的结构中有一个MethodLists表。里面存储的都是一个个方法。该结构体中主要就SEL（方法选择）和IMP（方法实现）。简单理解该结构体就相当于是在SEL和IMP之间做了一个映射。方便我们通过SEL找到对应的IMP。</p>\n<p>内存结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> *<span class=\"title\">Method</span>;</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> &#123;</span></span><br><span class=\"line\">    SEL method_name                 OBJC2_UNAVAILABLE;  <span class=\"comment\">// 方法名</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *method_types                  OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    IMP method_imp                      OBJC2_UNAVAILABLE;  <span class=\"comment\">// 方法实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.发消息<br>[p eat];通常我们说对象p调用了eat方法，也可以说向p对象发送了一条eat的消息。这两种说法。我觉得后面那种方式更加形象也更加准确。<br>那这句话的背后系统又干了些什么？是时候推开门进去看一看了。<br>在编译时期，编译器会将大部分的方法转换为函数，如objc_msgSend(),obj_msgSendSuper()等等。而在运行时期，消息才会被绑定到方法上。<br>例如：</p>\n<pre><code>[p eat];\n在编译时则会转换为：objc_msgSend(p,@selector(eat));这样的函数。\n</code></pre><p>objc_msgSend()是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br><span class=\"line\">receiver：消息接收者</span><br><span class=\"line\">selector：方法选择器</span><br><span class=\"line\">arg：其他参数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>5.消息传递<br>画个图吧。画好了。</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-adec86257f242c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"消息传递过程.png\"></p>\n<p>因为OC的动态特性。所以它会运行时确定该对象或该类所属的真实类型，也就是根isa指针去找它的真实类型。确定类型后，首先它会去cache表里面根据SEL去找IMP(方法实现函数)。没有的话，她就会去MethodLists里面找。找到了就去执行对应的IMP，并且她会将这个方法扔到Cache里面。如果在MethodLists里面也没找着。她回去根据superclass区她的父类按照这个顺序去查找方法实现。直到根类为止。从这里也就能看出来OC的方法调用其实走的是一个缓存机制。提高了方法调用的效率。</p>\n<ul>\n<li><p>消息转发<br>刚才说到了消息传递。有个疑问。如果在在Person.m中干掉-eat方法实现呢？那么整套流程走了下来。都没有找到那个方法会出现什么情况？答案当然是unrecognized selector sent to instance 0x2b2b2b2b..类似的字样，并且闪退。<br>所以，系统在经过消息传递过程后，还没有找到这个方法，那么它又偷偷摸摸的干了些什么呢？给不给机会挽回一下呢？<br>点开NSObject类的头文件。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-1ada22c46563f0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NSObject.png\"></p>\n</li>\n</ul>\n<p>发现了四个方法。这四个方法也就是用来实现消息转发的。也是用来给你没有实现那个方法的过错进行补救的。当然OC是人性化的。她一共给了你三次机会。消息转发的具体步骤如下：<br>1.方案一。如果是实例方法，会调用+ (BOOL)resolveInstanceMethod:(SEL)sel；方法。如果是类方法，则调用+ (BOOL)resolveClassMethod:(SEL)sel；<br>这两个方法的作用也就是让你在程序运行时动态的为一个selector提供实现。<br>栗如上面的那个疑问。我在Person.m中干掉了-eat的实现。则可以通过重载这个方法动态添加-eat的方法实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\">void eatIMP(id self ,SEL _cmd) &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    if (sel == @selector(eat)) &#123;</span><br><span class=\"line\">        class_addMethod([self class], sel, (IMP)eatIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p> 这里用到了class_addMethod()函数；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class=\"line\">cls：添加方法到指定的类。</span><br><span class=\"line\">name：方法选择器</span><br><span class=\"line\">imp：方法实现</span><br><span class=\"line\">types：请参考Objective-C Runtime Programming Guide-类型编码</span><br></pre></td></tr></table></figure></p>\n<p>(<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\"> Objective-C Runtime Programming Guide-类型编码</a>)</p>\n<p>这种方式让我们有机会在运行时通过resolveInstanceMethod或resolveClassMethod中动态的将某个方法实现添加到类中。那问题就来了。就一个方法实现而已。还要弄这么多代码。有毛用啊？<br>这个动态方法解析主要是为了解决@dynamic属性而存在的。</p>\n<p>那么我又要举手了。@dynamic又是什么鬼？<br>@dynamic 其实就是要是关键字。是相对于 @synthesize 的，它们用样用于修饰 @property，用于生成对应的的 getter 和 setter 方法。但是 @ dynamic 表示这个成员变量的 getter 和 setter 方法并不是直接由编译器生成，而是手工生成或者运行时生成。</p>\n<p>2.方案二<br>如果方案一你自己没有处理的话。就会来到- (id)forwardingTargetForSelector:(SEL)selector；这个方法。这个方法主要是用来将这个消息发送给一个可以处理的对象的。栗如：我收到了一个bug，我处理不了，我基友说他可以。那我通过这个方法我就可以把这个bug转发给我基友了。<br>栗如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Dog.h&quot;</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">@property (nonatomic, strong) Dog *dog;</span><br><span class=\"line\">- (void)eat;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">Person.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)eat &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    if (aSelector == @selector(bark)) &#123;</span><br><span class=\"line\">        return self.dog;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">@interface Dog : NSObject</span><br><span class=\"line\">- (void)bark;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Dog.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;Dog.h&quot;</span><br><span class=\"line\">@implementation Dog</span><br><span class=\"line\">- (void)bark &#123;</span><br><span class=\"line\">    NSLog(@&quot;wangwang...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Dog *dog = [[Dog alloc] init];</span><br><span class=\"line\">        Person *oldWang = [[Person alloc] init];</span><br><span class=\"line\">        oldWang.dog = dog;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [oldWang performSelector:@selector(bark)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>人有一只狗。狗有一个叫的方法。在main.m中我分别创建了一个Dog实例，还有个Person实例。并且将dog赋值给了oldWang的dog属性是不是。<br>那么现在oldWang有了一条dog。[oldWang performSelector:@selector(bark)];我们让oldWang像狗狗一样的叫。很明显不可能的是吧。所以我们在Person中重载了forwardingTargetForSelector方法。在这里面将bark这条消息发送给了dog属性。</p>\n<p>PS:<br>这种方式看起来蛮有意思的。混搭有没有。人可以飞。猪可以上树。但是有一个很大的局限性。具体执行这些行为的都不是对象本身。而是该对象持有的其他对象或者其他对象。感觉有点狐假虎威。</p>\n<p>使用场景：这种方式只适用于我们只想将消息转发到另一个能处理该消息的对象上，而并不能处理消息的参数和返回值。</p>\n<p>方案三：<br>好吧。再假设你第一步和第二步都没有做处理。事不过三。那就给你最后一次机会。- (void)forwardInvocation:(NSInvocation *)anInvocation。</p>\n<p>这一次运行时系统会将消息打包成一个NSInvocation对象。启动完整的消息转发机制。</p>\n<p>那么forwardInvocation：干了些什么呢？</p>\n<ul>\n<li>1.定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</li>\n<li>2.使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>\n</ul>\n<p>还是用代码说话。瞎逼逼谁不会啊。<br>还是刚才的代码。只不过改了下Person的实现文件。oldWang有一个dog。让oldWang像狗一样的叫。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)eat &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    NSMethodSignature *sign = [super methodSignatureForSelector:aSelector];</span><br><span class=\"line\">    if (!sign) &#123;</span><br><span class=\"line\">        sign = [[self.dog class] instanceMethodSignatureForSelector:@selector(bark)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sign;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class=\"line\">    if (anInvocation) &#123;</span><br><span class=\"line\">        [anInvocation invokeWithTarget:self.dog];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>在这里，我们重载了methodSignatureForSelector方法，这里需要返回一个非nil的NSMethodSignature对象。然后在forwardInvocation里进行转发消息。所以你可以在methodSignatureForSelector方法里对所有未识别的消息进行签名。感觉就像是个加工厂。消息想要进入forwardInvocation转发前必须经过这里包装下。接下来运行时系统会将这里NSMethodSignature对象自动打包成一个个NSInvocation对象。进入forwardInvocation，将消息发送出去。</p>\n<p>其实这里，一开始我有过一个疑问，既然OC不支持多继承。那么通过消息转发这种形式，不是很像是多继承吗？后来发现，它和多继承最大区别是在于，多继承是在于集中。而这种方式却更像是在分散。将不同的功能分散到不同的对象身上。</p>\n<p>到了这里OC中的消息转发也差不多了。那么我又有疑问了。知道了这么多，有毛用？不知道我也能干活。<br>通过查阅资料，Demo。总结了消息转发的几个用途。</p>\n<ul>\n<li>创建一个对象负责把消息转发给一个由其它对象组成的响应链，代理对象会在这个有其它对象组成的集合里寻找能够处理该消息的对象； </li>\n<li>把一个对象包在一个logger对象里，用来拦截或者纪录一些有趣的消息调用；</li>\n<li>比如声明类的属性为dynamic，使用自定义的方法来截取和取代由系统自动生成的getter和setter方法。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-0707de44c067caeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"异常.jpg\"></p>\n","site":{"data":{}},"excerpt":"<p>举个栗子！！！<br>Person.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">- (void)eat;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>Person.m<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (void)eat &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>","more":"<p>Main.m<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Person *p = [[Person alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-如何调用p对象的eat方法呢？除了-p-eat-这种方式，还有没有其他方式能够调用eat方法？如果我在-h文件中没有eat方法的声明，又如何调用？\"><a href=\"#1-如何调用p对象的eat方法呢？除了-p-eat-这种方式，还有没有其他方式能够调用eat方法？如果我在-h文件中没有eat方法的声明，又如何调用？\" class=\"headerlink\" title=\"1.如何调用p对象的eat方法呢？除了[p eat]这种方式，还有没有其他方式能够调用eat方法？如果我在.h文件中没有eat方法的声明，又如何调用？\"></a>1.如何调用p对象的eat方法呢？除了[p eat]这种方式，还有没有其他方式能够调用eat方法？如果我在.h文件中没有eat方法的声明，又如何调用？</h4><ul>\n<li><p>1&gt;直接调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[p eat];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2&gt;通过performSelector</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([p respondsToSelector:@selector(eat)]) &#123; // 判断方法是否存在，防止方法不存在导致闪退</span><br><span class=\"line\">\t[p performSelector:@selector(eat)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3&gt;利用NSInvovation</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取方法签名</span><br><span class=\"line\">NSMethodSignature *sign = [[p class] instanceMethodSignatureForSelector:selector];</span><br><span class=\"line\">// 创建invocation对象</span><br><span class=\"line\">NSInvocation *eatIvo = [NSInvocation invocationWithMethodSignature:sign];</span><br><span class=\"line\">eatIvo.target = p;</span><br><span class=\"line\">eatIvo.selector = selector;</span><br><span class=\"line\">[eatIvo invoke];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4&gt;运行时消息函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(p,@selector(eat));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>PS:</strong><br>在Xcode7中直接调用objc_msgSend函数会报错。主要是因为编译器会检查你objc_msgSend函数调用。解决办法有2种：</p>\n<ul>\n<li><p>1.强转  </p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class = [p class];</span><br><span class=\"line\">((void * ()(void, SEL))(void*)objc_msgSend)(&amp;class, @selector(eat));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.Build Settings-&gt;Enable Strict Checking of objec_msgSend Calls 设置为YES</p>\n</li>\n</ul>\n<p>方法调用的几种方式。那么一开始的那个疑问，如果-eat方法只有实现，在.h文件中而没有声明，这样外部也就无法调用到-eat方法了。当然还是可以利用上述2，3，4种方式来调用。又在想，如果做绝一点，连Person类都不让你知道呢？我又该怎么创建Person类的实例？怎么调用p对象的那个-eat方法呢？这时候就需要用到运行时。获取到类名还有类的所有方法名。利用反射将字符串转变为类，方法等等。同样可以利用2,3,4来调用方法。那是不是可以认为在OC中没有严格意义上的私有方法呢。</p>\n<h4 id=\"2-OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\"><a href=\"#2-OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\" class=\"headerlink\" title=\"2.OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？\"></a>2.OC中的SEL是什么东西？方法和函数有什么关系？动态绑定是什么意思？为什么OC中的方法调用也叫发消息？那么消息是怎么传递的呢？消息转发又是什么鬼？还有消息机制的完整流程是几个意思？</h4><p>一大串的问题。对于消息这东西，思绪是乱的。静下心来一点点的梳理一遍，也是受益很多，对于OC也有了更深的理解。</p>\n<ul>\n<li><p>1.SEL是什么？SEL也叫方法选择器，它的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>;</span></span><br></pre></td></tr></table></figure>\n<p>其实就是一个特殊的结构体类型的指针，而该结构体就是对每个方法的方法名，参数序列等等一些信息的描述。</p>\n<p>关于SEL其实就是一个根据方法名哈希处理后的一个用来标识某个方法的一个唯一标识而已。一个SEL就代表着一个方法。通过这个SEL就能找到对应的方法实现。使用哈希处理后的方法名而不用方法名去做标识，这样提高了查找方法实现的效率。<br>ps：</p>\n<ul>\n<li>@selector()只是个编译器指令。在编译期会自动将这部分转换为对应的代码。</li>\n<li>在某一个类或该类的继承体系中，如果出现两个方法名相同的方法，即使参数不同。他们生成的SEL也是一样的。所以OC中某一个类或该类的继承体系中最好不要出现两个相同方法名的方法。</li>\n</ul>\n</li>\n<li><p>2.动态绑定<br>OC既然是动态语言，重要的一个体现就是动态绑定。OC是在运行时确定对象所属的真实类型。确定类型之后，才会将对应的属性和响应的消息绑定到该对象上。</p>\n</li>\n<li><p>3.方法<br>我们知道类的结构中有一个MethodLists表。里面存储的都是一个个方法。该结构体中主要就SEL（方法选择）和IMP（方法实现）。简单理解该结构体就相当于是在SEL和IMP之间做了一个映射。方便我们通过SEL找到对应的IMP。</p>\n<p>内存结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> *<span class=\"title\">Method</span>;</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> &#123;</span></span><br><span class=\"line\">    SEL method_name                 OBJC2_UNAVAILABLE;  <span class=\"comment\">// 方法名</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *method_types                  OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    IMP method_imp                      OBJC2_UNAVAILABLE;  <span class=\"comment\">// 方法实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.发消息<br>[p eat];通常我们说对象p调用了eat方法，也可以说向p对象发送了一条eat的消息。这两种说法。我觉得后面那种方式更加形象也更加准确。<br>那这句话的背后系统又干了些什么？是时候推开门进去看一看了。<br>在编译时期，编译器会将大部分的方法转换为函数，如objc_msgSend(),obj_msgSendSuper()等等。而在运行时期，消息才会被绑定到方法上。<br>例如：</p>\n<pre><code>[p eat];\n在编译时则会转换为：objc_msgSend(p,@selector(eat));这样的函数。\n</code></pre><p>objc_msgSend()是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br><span class=\"line\">receiver：消息接收者</span><br><span class=\"line\">selector：方法选择器</span><br><span class=\"line\">arg：其他参数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>5.消息传递<br>画个图吧。画好了。</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-adec86257f242c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"消息传递过程.png\"></p>\n<p>因为OC的动态特性。所以它会运行时确定该对象或该类所属的真实类型，也就是根isa指针去找它的真实类型。确定类型后，首先它会去cache表里面根据SEL去找IMP(方法实现函数)。没有的话，她就会去MethodLists里面找。找到了就去执行对应的IMP，并且她会将这个方法扔到Cache里面。如果在MethodLists里面也没找着。她回去根据superclass区她的父类按照这个顺序去查找方法实现。直到根类为止。从这里也就能看出来OC的方法调用其实走的是一个缓存机制。提高了方法调用的效率。</p>\n<ul>\n<li><p>消息转发<br>刚才说到了消息传递。有个疑问。如果在在Person.m中干掉-eat方法实现呢？那么整套流程走了下来。都没有找到那个方法会出现什么情况？答案当然是unrecognized selector sent to instance 0x2b2b2b2b..类似的字样，并且闪退。<br>所以，系统在经过消息传递过程后，还没有找到这个方法，那么它又偷偷摸摸的干了些什么呢？给不给机会挽回一下呢？<br>点开NSObject类的头文件。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-1ada22c46563f0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NSObject.png\"></p>\n</li>\n</ul>\n<p>发现了四个方法。这四个方法也就是用来实现消息转发的。也是用来给你没有实现那个方法的过错进行补救的。当然OC是人性化的。她一共给了你三次机会。消息转发的具体步骤如下：<br>1.方案一。如果是实例方法，会调用+ (BOOL)resolveInstanceMethod:(SEL)sel；方法。如果是类方法，则调用+ (BOOL)resolveClassMethod:(SEL)sel；<br>这两个方法的作用也就是让你在程序运行时动态的为一个selector提供实现。<br>栗如上面的那个疑问。我在Person.m中干掉了-eat的实现。则可以通过重载这个方法动态添加-eat的方法实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\">void eatIMP(id self ,SEL _cmd) &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    if (sel == @selector(eat)) &#123;</span><br><span class=\"line\">        class_addMethod([self class], sel, (IMP)eatIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p> 这里用到了class_addMethod()函数；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class=\"line\">cls：添加方法到指定的类。</span><br><span class=\"line\">name：方法选择器</span><br><span class=\"line\">imp：方法实现</span><br><span class=\"line\">types：请参考Objective-C Runtime Programming Guide-类型编码</span><br></pre></td></tr></table></figure></p>\n<p>(<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\"> Objective-C Runtime Programming Guide-类型编码</a>)</p>\n<p>这种方式让我们有机会在运行时通过resolveInstanceMethod或resolveClassMethod中动态的将某个方法实现添加到类中。那问题就来了。就一个方法实现而已。还要弄这么多代码。有毛用啊？<br>这个动态方法解析主要是为了解决@dynamic属性而存在的。</p>\n<p>那么我又要举手了。@dynamic又是什么鬼？<br>@dynamic 其实就是要是关键字。是相对于 @synthesize 的，它们用样用于修饰 @property，用于生成对应的的 getter 和 setter 方法。但是 @ dynamic 表示这个成员变量的 getter 和 setter 方法并不是直接由编译器生成，而是手工生成或者运行时生成。</p>\n<p>2.方案二<br>如果方案一你自己没有处理的话。就会来到- (id)forwardingTargetForSelector:(SEL)selector；这个方法。这个方法主要是用来将这个消息发送给一个可以处理的对象的。栗如：我收到了一个bug，我处理不了，我基友说他可以。那我通过这个方法我就可以把这个bug转发给我基友了。<br>栗如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Dog.h&quot;</span><br><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\">@property (nonatomic, strong) Dog *dog;</span><br><span class=\"line\">- (void)eat;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">Person.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)eat &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    if (aSelector == @selector(bark)) &#123;</span><br><span class=\"line\">        return self.dog;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">@interface Dog : NSObject</span><br><span class=\"line\">- (void)bark;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Dog.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;Dog.h&quot;</span><br><span class=\"line\">@implementation Dog</span><br><span class=\"line\">- (void)bark &#123;</span><br><span class=\"line\">    NSLog(@&quot;wangwang...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Dog *dog = [[Dog alloc] init];</span><br><span class=\"line\">        Person *oldWang = [[Person alloc] init];</span><br><span class=\"line\">        oldWang.dog = dog;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [oldWang performSelector:@selector(bark)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>人有一只狗。狗有一个叫的方法。在main.m中我分别创建了一个Dog实例，还有个Person实例。并且将dog赋值给了oldWang的dog属性是不是。<br>那么现在oldWang有了一条dog。[oldWang performSelector:@selector(bark)];我们让oldWang像狗狗一样的叫。很明显不可能的是吧。所以我们在Person中重载了forwardingTargetForSelector方法。在这里面将bark这条消息发送给了dog属性。</p>\n<p>PS:<br>这种方式看起来蛮有意思的。混搭有没有。人可以飞。猪可以上树。但是有一个很大的局限性。具体执行这些行为的都不是对象本身。而是该对象持有的其他对象或者其他对象。感觉有点狐假虎威。</p>\n<p>使用场景：这种方式只适用于我们只想将消息转发到另一个能处理该消息的对象上，而并不能处理消息的参数和返回值。</p>\n<p>方案三：<br>好吧。再假设你第一步和第二步都没有做处理。事不过三。那就给你最后一次机会。- (void)forwardInvocation:(NSInvocation *)anInvocation。</p>\n<p>这一次运行时系统会将消息打包成一个NSInvocation对象。启动完整的消息转发机制。</p>\n<p>那么forwardInvocation：干了些什么呢？</p>\n<ul>\n<li>1.定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</li>\n<li>2.使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>\n</ul>\n<p>还是用代码说话。瞎逼逼谁不会啊。<br>还是刚才的代码。只不过改了下Person的实现文件。oldWang有一个dog。让oldWang像狗一样的叫。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Person.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)eat &#123;</span><br><span class=\"line\">    NSLog(@&quot;eat...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    NSMethodSignature *sign = [super methodSignatureForSelector:aSelector];</span><br><span class=\"line\">    if (!sign) &#123;</span><br><span class=\"line\">        sign = [[self.dog class] instanceMethodSignatureForSelector:@selector(bark)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sign;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class=\"line\">    if (anInvocation) &#123;</span><br><span class=\"line\">        [anInvocation invokeWithTarget:self.dog];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>在这里，我们重载了methodSignatureForSelector方法，这里需要返回一个非nil的NSMethodSignature对象。然后在forwardInvocation里进行转发消息。所以你可以在methodSignatureForSelector方法里对所有未识别的消息进行签名。感觉就像是个加工厂。消息想要进入forwardInvocation转发前必须经过这里包装下。接下来运行时系统会将这里NSMethodSignature对象自动打包成一个个NSInvocation对象。进入forwardInvocation，将消息发送出去。</p>\n<p>其实这里，一开始我有过一个疑问，既然OC不支持多继承。那么通过消息转发这种形式，不是很像是多继承吗？后来发现，它和多继承最大区别是在于，多继承是在于集中。而这种方式却更像是在分散。将不同的功能分散到不同的对象身上。</p>\n<p>到了这里OC中的消息转发也差不多了。那么我又有疑问了。知道了这么多，有毛用？不知道我也能干活。<br>通过查阅资料，Demo。总结了消息转发的几个用途。</p>\n<ul>\n<li>创建一个对象负责把消息转发给一个由其它对象组成的响应链，代理对象会在这个有其它对象组成的集合里寻找能够处理该消息的对象； </li>\n<li>把一个对象包在一个logger对象里，用来拦截或者纪录一些有趣的消息调用；</li>\n<li>比如声明类的属性为dynamic，使用自定义的方法来截取和取代由系统自动生成的getter和setter方法。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-0707de44c067caeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"异常.jpg\"></p>"},{"layout":"post","title":"React Native 03：换肤支持","date":"2016-09-18T02:25:29.000Z","_content":"> 因为原生这边有个换肤功能，用户下载对应的皮肤包，用户切换皮肤之后，会触发一个全局的通知，需要支持换肤的UI视图对象会注册通知这个通知监听，然后重新渲染。某一天产品跑过来说，RN的页面也要支持换肤哦。呵呵。。。\n\n## 思路\n\n### 1.先看看原生那边换肤是怎么玩的。\n\n* 点开app下载一个皮肤包。会从服务器请求一个zip压缩包。\n\n* 解压缩打开，一份色值表配置json文件，若干替换图片。\n  看代码。大致实现是换肤库提供了很多的UIKit组件的分类，提供了相关设置色值，图片的方法。并且会去注册监听换\n\n  肤通知。一般我们写业务代码的时候，都会使用那些分类所提供的支持换肤的方法。并且部分页面需要主动监听换肤通知的从而实现主动渲染。当触发换肤的时候，页面重新渲染，就会从对应的皮肤包里获取对应的图片，以及色值。从而实现的换肤。\n<!-- more -->\n\n### 2.RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\n\n* 色值\n  首先原生写好了一个桥接方法，传入不同的key去色值表中查找对应的16进制色值，返回给rn。rn页面在render()函数之前，调用该桥接获取色值，并且通过state保存该色值。之后在render()函数渲染的时候设置到对应的节点上就行了。好吧。是可以。后来又发现了个问题。RN中原生和JS桥接是异步执行，那么就不能保证在render()函数执行之前获取到的是真正的色值。很尴尬。这种方式好像行不通。换个思路。\n\n* 图片\n  其实RN加载图片，是通过RCTImageLoader这个类。通过断点发现主要调用下面的那个方法。\n\n  ```\n  -(RCTImageLoaderCancellationBlock)_loadImageOrDataWithURLRequest:(NSURLRequest *)request\n                                                               size:(CGSize)size\n                                                              scale:(CGFloat)scale\n                                                         resizeMode:(RCTResizeMode)resizeMode\n                                                      progressBlock:(RCTImageLoaderProgressBlock)progressHandler\n                                                   partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadHandler\n                                                    completionBlock:(void (^)(NSError *error, id imageOrData, BOOL cacheResult, NSString *fetchDate))completionBlock {\n  }\n  ```\n\n  主要的一个参数就是request。如果是网络图片就是正常的http:// 协议的链接。如果是本地图片，不管是项目image.xcassets里的图片还是mainBundle里的图片，又或者是沙盒里的图片，都会是一个file://协议的图片本地地址。好吧。替换下图片路径试试？结果可行。那么RN图片换肤就可以通过修改源码来实现。\n### 3.图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置'red'，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\n\n* 原生部分\n  找了半天，发现了RCTConvert中有个方法是用来转换颜色的。断点发现RN中的设置颜色最终都会来到该方法里转换成UIColor的对象。\n\n  ```\n    + (UIColor *)UIColor:(id)json\n  {\n    if (!json) {\n      return nil;\n    }\n    if ([json isKindOfClass:[NSString class]]) {\n        //去皮肤包查找色值\n        if([json isEqualToString:@\"ck_black\"]) {\n            return [UIColor whiteColor];\n        }\n    }\n    if ([json isKindOfClass:[NSArray class]]) {\n      NSArray *components = [self NSNumberArray:json];\n      CGFloat alpha = components.count > 3 ? [self CGFloat:components[3]] : 1.0;\n      return [UIColor colorWithRed:[self CGFloat:components[0]]\n                             green:[self CGFloat:components[1]]\n                              blue:[self CGFloat:components[2]]\n                             alpha:alpha];\n    } else if ([json isKindOfClass:[NSNumber class]]) {\n      NSUInteger argb = [self NSUInteger:json];\n      CGFloat a = ((argb >> 24) & 0xFF) / 255.0;\n      CGFloat r = ((argb >> 16) & 0xFF) / 255.0;\n      CGFloat g = ((argb >> 8) & 0xFF) / 255.0;\n      CGFloat b = (argb & 0xFF) / 255.0;\n      return [UIColor colorWithRed:r green:g blue:b alpha:a];\n    } else {\n      RCTLogConvertError(json, @\"a UIColor. Did you forget to call processColor() on the JS side?\");\n      return nil;\n    }\n  }\n  ```\n\n  好吧。看起来该方法里只支持从RN那边传递过来的NSArray类型和NSNumber类型的。也不支持NSString类型的啊。所以RN中通过'red'这种字符串设置颜色的解析并不是在原生这部分。所以在原生部分支持字符串类型。通过该字符串key去对应皮肤包的色值表中去查找真正的色值。\n\n\n* RN部分\n  发现node_modules/react-native/Libraries/StyleSheet/processColor.js该文件中processColor()函数是用来解析色值的。\n\n  ```\n    var Platform = require('Platform');\n    var normalizeColor = require('normalizeColor');\n  /* eslint no-bitwise: 0 */\n  function processColor(color) {\n    if (color === undefined || color === null) {\n      return color;\n    }\n\n    var int32Color = normalizeColor(color);\n    if (int32Color === null) {\n      return undefined;\n    }\n\n    if(typeof int32Color === 'string') {\n      return int32Color;\n    }\n\n    // Converts 0xrrggbbaa into 0xaarrggbb\n    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;\n\n    if (Platform.OS === 'android') {\n      // Android use 32 bit *signed* integer to represent the color\n      // We utilize the fact that bitwise operations in JS also operates on\n      // signed 32 bit integers, so that we can use those to convert from\n      // *unsigned* to *signed* 32bit int that way.\n      int32Color = int32Color | 0x0;\n    }\n    return int32Color;\n  }\n  ```\n\n  在该方法中，RN会去查找类似'red'这样的色值，并且返回为一个32位int类型。如果没找到对应色值，它会强转为一个0x0的色值。所以我们在它查找完之后，强转之前，如果没找到，直接将字符串类型的变量返回出去，这样原生也就能接受到一个字符串类型的key了。\n","source":"_posts/rn-03.md","raw":"---\nlayout: post\ntitle: \"React Native 03：换肤支持\"\ndate: 2016-09-18 10:25:29\ncategories: \n- 技术\n- [技术, React Native]\ntags: \n- 技术\n- React Native\n---\n> 因为原生这边有个换肤功能，用户下载对应的皮肤包，用户切换皮肤之后，会触发一个全局的通知，需要支持换肤的UI视图对象会注册通知这个通知监听，然后重新渲染。某一天产品跑过来说，RN的页面也要支持换肤哦。呵呵。。。\n\n## 思路\n\n### 1.先看看原生那边换肤是怎么玩的。\n\n* 点开app下载一个皮肤包。会从服务器请求一个zip压缩包。\n\n* 解压缩打开，一份色值表配置json文件，若干替换图片。\n  看代码。大致实现是换肤库提供了很多的UIKit组件的分类，提供了相关设置色值，图片的方法。并且会去注册监听换\n\n  肤通知。一般我们写业务代码的时候，都会使用那些分类所提供的支持换肤的方法。并且部分页面需要主动监听换肤通知的从而实现主动渲染。当触发换肤的时候，页面重新渲染，就会从对应的皮肤包里获取对应的图片，以及色值。从而实现的换肤。\n<!-- more -->\n\n### 2.RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\n\n* 色值\n  首先原生写好了一个桥接方法，传入不同的key去色值表中查找对应的16进制色值，返回给rn。rn页面在render()函数之前，调用该桥接获取色值，并且通过state保存该色值。之后在render()函数渲染的时候设置到对应的节点上就行了。好吧。是可以。后来又发现了个问题。RN中原生和JS桥接是异步执行，那么就不能保证在render()函数执行之前获取到的是真正的色值。很尴尬。这种方式好像行不通。换个思路。\n\n* 图片\n  其实RN加载图片，是通过RCTImageLoader这个类。通过断点发现主要调用下面的那个方法。\n\n  ```\n  -(RCTImageLoaderCancellationBlock)_loadImageOrDataWithURLRequest:(NSURLRequest *)request\n                                                               size:(CGSize)size\n                                                              scale:(CGFloat)scale\n                                                         resizeMode:(RCTResizeMode)resizeMode\n                                                      progressBlock:(RCTImageLoaderProgressBlock)progressHandler\n                                                   partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadHandler\n                                                    completionBlock:(void (^)(NSError *error, id imageOrData, BOOL cacheResult, NSString *fetchDate))completionBlock {\n  }\n  ```\n\n  主要的一个参数就是request。如果是网络图片就是正常的http:// 协议的链接。如果是本地图片，不管是项目image.xcassets里的图片还是mainBundle里的图片，又或者是沙盒里的图片，都会是一个file://协议的图片本地地址。好吧。替换下图片路径试试？结果可行。那么RN图片换肤就可以通过修改源码来实现。\n### 3.图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置'red'，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\n\n* 原生部分\n  找了半天，发现了RCTConvert中有个方法是用来转换颜色的。断点发现RN中的设置颜色最终都会来到该方法里转换成UIColor的对象。\n\n  ```\n    + (UIColor *)UIColor:(id)json\n  {\n    if (!json) {\n      return nil;\n    }\n    if ([json isKindOfClass:[NSString class]]) {\n        //去皮肤包查找色值\n        if([json isEqualToString:@\"ck_black\"]) {\n            return [UIColor whiteColor];\n        }\n    }\n    if ([json isKindOfClass:[NSArray class]]) {\n      NSArray *components = [self NSNumberArray:json];\n      CGFloat alpha = components.count > 3 ? [self CGFloat:components[3]] : 1.0;\n      return [UIColor colorWithRed:[self CGFloat:components[0]]\n                             green:[self CGFloat:components[1]]\n                              blue:[self CGFloat:components[2]]\n                             alpha:alpha];\n    } else if ([json isKindOfClass:[NSNumber class]]) {\n      NSUInteger argb = [self NSUInteger:json];\n      CGFloat a = ((argb >> 24) & 0xFF) / 255.0;\n      CGFloat r = ((argb >> 16) & 0xFF) / 255.0;\n      CGFloat g = ((argb >> 8) & 0xFF) / 255.0;\n      CGFloat b = (argb & 0xFF) / 255.0;\n      return [UIColor colorWithRed:r green:g blue:b alpha:a];\n    } else {\n      RCTLogConvertError(json, @\"a UIColor. Did you forget to call processColor() on the JS side?\");\n      return nil;\n    }\n  }\n  ```\n\n  好吧。看起来该方法里只支持从RN那边传递过来的NSArray类型和NSNumber类型的。也不支持NSString类型的啊。所以RN中通过'red'这种字符串设置颜色的解析并不是在原生这部分。所以在原生部分支持字符串类型。通过该字符串key去对应皮肤包的色值表中去查找真正的色值。\n\n\n* RN部分\n  发现node_modules/react-native/Libraries/StyleSheet/processColor.js该文件中processColor()函数是用来解析色值的。\n\n  ```\n    var Platform = require('Platform');\n    var normalizeColor = require('normalizeColor');\n  /* eslint no-bitwise: 0 */\n  function processColor(color) {\n    if (color === undefined || color === null) {\n      return color;\n    }\n\n    var int32Color = normalizeColor(color);\n    if (int32Color === null) {\n      return undefined;\n    }\n\n    if(typeof int32Color === 'string') {\n      return int32Color;\n    }\n\n    // Converts 0xrrggbbaa into 0xaarrggbb\n    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;\n\n    if (Platform.OS === 'android') {\n      // Android use 32 bit *signed* integer to represent the color\n      // We utilize the fact that bitwise operations in JS also operates on\n      // signed 32 bit integers, so that we can use those to convert from\n      // *unsigned* to *signed* 32bit int that way.\n      int32Color = int32Color | 0x0;\n    }\n    return int32Color;\n  }\n  ```\n\n  在该方法中，RN会去查找类似'red'这样的色值，并且返回为一个32位int类型。如果没找到对应色值，它会强转为一个0x0的色值。所以我们在它查找完之后，强转之前，如果没找到，直接将字符串类型的变量返回出去，这样原生也就能接受到一个字符串类型的key了。\n","slug":"rn-03","published":1,"updated":"2019-12-20T06:08:22.051Z","comments":1,"photos":[],"link":"","_id":"ck4dsux3d0010odnqbbn5mkvz","content":"<blockquote>\n<p>因为原生这边有个换肤功能，用户下载对应的皮肤包，用户切换皮肤之后，会触发一个全局的通知，需要支持换肤的UI视图对象会注册通知这个通知监听，然后重新渲染。某一天产品跑过来说，RN的页面也要支持换肤哦。呵呵。。。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"1-先看看原生那边换肤是怎么玩的。\"><a href=\"#1-先看看原生那边换肤是怎么玩的。\" class=\"headerlink\" title=\"1.先看看原生那边换肤是怎么玩的。\"></a>1.先看看原生那边换肤是怎么玩的。</h3><ul>\n<li><p>点开app下载一个皮肤包。会从服务器请求一个zip压缩包。</p>\n</li>\n<li><p>解压缩打开，一份色值表配置json文件，若干替换图片。<br>看代码。大致实现是换肤库提供了很多的UIKit组件的分类，提供了相关设置色值，图片的方法。并且会去注册监听换</p>\n<p>肤通知。一般我们写业务代码的时候，都会使用那些分类所提供的支持换肤的方法。并且部分页面需要主动监听换肤通知的从而实现主动渲染。当触发换肤的时候，页面重新渲染，就会从对应的皮肤包里获取对应的图片，以及色值。从而实现的换肤。</p>\n<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"2-RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\"><a href=\"#2-RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\" class=\"headerlink\" title=\"2.RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\"></a>2.RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？</h3><ul>\n<li><p>色值<br>首先原生写好了一个桥接方法，传入不同的key去色值表中查找对应的16进制色值，返回给rn。rn页面在render()函数之前，调用该桥接获取色值，并且通过state保存该色值。之后在render()函数渲染的时候设置到对应的节点上就行了。好吧。是可以。后来又发现了个问题。RN中原生和JS桥接是异步执行，那么就不能保证在render()函数执行之前获取到的是真正的色值。很尴尬。这种方式好像行不通。换个思路。</p>\n</li>\n<li><p>图片<br>其实RN加载图片，是通过RCTImageLoader这个类。通过断点发现主要调用下面的那个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(RCTImageLoaderCancellationBlock)_loadImageOrDataWithURLRequest:(NSURLRequest *)request</span><br><span class=\"line\">                                                             size:(CGSize)size</span><br><span class=\"line\">                                                            scale:(CGFloat)scale</span><br><span class=\"line\">                                                       resizeMode:(RCTResizeMode)resizeMode</span><br><span class=\"line\">                                                    progressBlock:(RCTImageLoaderProgressBlock)progressHandler</span><br><span class=\"line\">                                                 partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadHandler</span><br><span class=\"line\">                                                  completionBlock:(void (^)(NSError *error, id imageOrData, BOOL cacheResult, NSString *fetchDate))completionBlock &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要的一个参数就是request。如果是网络图片就是正常的http:// 协议的链接。如果是本地图片，不管是项目image.xcassets里的图片还是mainBundle里的图片，又或者是沙盒里的图片，都会是一个file://协议的图片本地地址。好吧。替换下图片路径试试？结果可行。那么RN图片换肤就可以通过修改源码来实现。</p>\n<h3 id=\"3-图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\"><a href=\"#3-图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\" class=\"headerlink\" title=\"3.图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\"></a>3.图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。</h3></li>\n<li><p>原生部分<br>找了半天，发现了RCTConvert中有个方法是用来转换颜色的。断点发现RN中的设置颜色最终都会来到该方法里转换成UIColor的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  + (UIColor *)UIColor:(id)json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (!json) &#123;</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if ([json isKindOfClass:[NSString class]]) &#123;</span><br><span class=\"line\">      //去皮肤包查找色值</span><br><span class=\"line\">      if([json isEqualToString:@&quot;ck_black&quot;]) &#123;</span><br><span class=\"line\">          return [UIColor whiteColor];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if ([json isKindOfClass:[NSArray class]]) &#123;</span><br><span class=\"line\">    NSArray *components = [self NSNumberArray:json];</span><br><span class=\"line\">    CGFloat alpha = components.count &gt; 3 ? [self CGFloat:components[3]] : 1.0;</span><br><span class=\"line\">    return [UIColor colorWithRed:[self CGFloat:components[0]]</span><br><span class=\"line\">                           green:[self CGFloat:components[1]]</span><br><span class=\"line\">                            blue:[self CGFloat:components[2]]</span><br><span class=\"line\">                           alpha:alpha];</span><br><span class=\"line\">  &#125; else if ([json isKindOfClass:[NSNumber class]]) &#123;</span><br><span class=\"line\">    NSUInteger argb = [self NSUInteger:json];</span><br><span class=\"line\">    CGFloat a = ((argb &gt;&gt; 24) &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    CGFloat r = ((argb &gt;&gt; 16) &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    CGFloat g = ((argb &gt;&gt; 8) &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    CGFloat b = (argb &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    return [UIColor colorWithRed:r green:g blue:b alpha:a];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    RCTLogConvertError(json, @&quot;a UIColor. Did you forget to call processColor() on the JS side?&quot;);</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧。看起来该方法里只支持从RN那边传递过来的NSArray类型和NSNumber类型的。也不支持NSString类型的啊。所以RN中通过’red’这种字符串设置颜色的解析并不是在原生这部分。所以在原生部分支持字符串类型。通过该字符串key去对应皮肤包的色值表中去查找真正的色值。</p>\n</li>\n</ul>\n<ul>\n<li><p>RN部分<br>发现node_modules/react-native/Libraries/StyleSheet/processColor.js该文件中processColor()函数是用来解析色值的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  var Platform = require(&apos;Platform&apos;);</span><br><span class=\"line\">  var normalizeColor = require(&apos;normalizeColor&apos;);</span><br><span class=\"line\">/* eslint no-bitwise: 0 */</span><br><span class=\"line\">function processColor(color) &#123;</span><br><span class=\"line\">  if (color === undefined || color === null) &#123;</span><br><span class=\"line\">    return color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  var int32Color = normalizeColor(color);</span><br><span class=\"line\">  if (int32Color === null) &#123;</span><br><span class=\"line\">    return undefined;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if(typeof int32Color === &apos;string&apos;) &#123;</span><br><span class=\"line\">    return int32Color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Converts 0xrrggbbaa into 0xaarrggbb</span><br><span class=\"line\">  int32Color = (int32Color &lt;&lt; 24 | int32Color &gt;&gt;&gt; 8) &gt;&gt;&gt; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (Platform.OS === &apos;android&apos;) &#123;</span><br><span class=\"line\">    // Android use 32 bit *signed* integer to represent the color</span><br><span class=\"line\">    // We utilize the fact that bitwise operations in JS also operates on</span><br><span class=\"line\">    // signed 32 bit integers, so that we can use those to convert from</span><br><span class=\"line\">    // *unsigned* to *signed* 32bit int that way.</span><br><span class=\"line\">    int32Color = int32Color | 0x0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return int32Color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该方法中，RN会去查找类似’red’这样的色值，并且返回为一个32位int类型。如果没找到对应色值，它会强转为一个0x0的色值。所以我们在它查找完之后，强转之前，如果没找到，直接将字符串类型的变量返回出去，这样原生也就能接受到一个字符串类型的key了。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>因为原生这边有个换肤功能，用户下载对应的皮肤包，用户切换皮肤之后，会触发一个全局的通知，需要支持换肤的UI视图对象会注册通知这个通知监听，然后重新渲染。某一天产品跑过来说，RN的页面也要支持换肤哦。呵呵。。。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"1-先看看原生那边换肤是怎么玩的。\"><a href=\"#1-先看看原生那边换肤是怎么玩的。\" class=\"headerlink\" title=\"1.先看看原生那边换肤是怎么玩的。\"></a>1.先看看原生那边换肤是怎么玩的。</h3><ul>\n<li><p>点开app下载一个皮肤包。会从服务器请求一个zip压缩包。</p>\n</li>\n<li><p>解压缩打开，一份色值表配置json文件，若干替换图片。<br>看代码。大致实现是换肤库提供了很多的UIKit组件的分类，提供了相关设置色值，图片的方法。并且会去注册监听换</p>\n<p>肤通知。一般我们写业务代码的时候，都会使用那些分类所提供的支持换肤的方法。并且部分页面需要主动监听换肤通知的从而实现主动渲染。当触发换肤的时候，页面重新渲染，就会从对应的皮肤包里获取对应的图片，以及色值。从而实现的换肤。</p>","more":"</li>\n</ul>\n<h3 id=\"2-RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\"><a href=\"#2-RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\" class=\"headerlink\" title=\"2.RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？\"></a>2.RN这边既然要支持换肤，不就是JS中设置图片，色值的地方改成通过桥接从原生那边获取对应的色值和图片吗？</h3><ul>\n<li><p>色值<br>首先原生写好了一个桥接方法，传入不同的key去色值表中查找对应的16进制色值，返回给rn。rn页面在render()函数之前，调用该桥接获取色值，并且通过state保存该色值。之后在render()函数渲染的时候设置到对应的节点上就行了。好吧。是可以。后来又发现了个问题。RN中原生和JS桥接是异步执行，那么就不能保证在render()函数执行之前获取到的是真正的色值。很尴尬。这种方式好像行不通。换个思路。</p>\n</li>\n<li><p>图片<br>其实RN加载图片，是通过RCTImageLoader这个类。通过断点发现主要调用下面的那个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(RCTImageLoaderCancellationBlock)_loadImageOrDataWithURLRequest:(NSURLRequest *)request</span><br><span class=\"line\">                                                             size:(CGSize)size</span><br><span class=\"line\">                                                            scale:(CGFloat)scale</span><br><span class=\"line\">                                                       resizeMode:(RCTResizeMode)resizeMode</span><br><span class=\"line\">                                                    progressBlock:(RCTImageLoaderProgressBlock)progressHandler</span><br><span class=\"line\">                                                 partialLoadBlock:(RCTImageLoaderPartialLoadBlock)partialLoadHandler</span><br><span class=\"line\">                                                  completionBlock:(void (^)(NSError *error, id imageOrData, BOOL cacheResult, NSString *fetchDate))completionBlock &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要的一个参数就是request。如果是网络图片就是正常的http:// 协议的链接。如果是本地图片，不管是项目image.xcassets里的图片还是mainBundle里的图片，又或者是沙盒里的图片，都会是一个file://协议的图片本地地址。好吧。替换下图片路径试试？结果可行。那么RN图片换肤就可以通过修改源码来实现。</p>\n<h3 id=\"3-图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\"><a href=\"#3-图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\" class=\"headerlink\" title=\"3.图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。\"></a>3.图片搞定了，还有色值呢？既然图片可以通过修改源码的形式搞定，那么色值能不能也通过修改源码的方式去搞？找到原生这边生成UIColor的方法？之前RN那部分不仅支持16进制的色值，而且还支持字符串类型的色值，例如设置’red’，RN最终会设置成真正的色值。RN是不是通过这个字符串key，去它自己的色值表去查找对应色值的呢？那么就要找到将‘red’解析成真正色值的方法。</h3></li>\n<li><p>原生部分<br>找了半天，发现了RCTConvert中有个方法是用来转换颜色的。断点发现RN中的设置颜色最终都会来到该方法里转换成UIColor的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  + (UIColor *)UIColor:(id)json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (!json) &#123;</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if ([json isKindOfClass:[NSString class]]) &#123;</span><br><span class=\"line\">      //去皮肤包查找色值</span><br><span class=\"line\">      if([json isEqualToString:@&quot;ck_black&quot;]) &#123;</span><br><span class=\"line\">          return [UIColor whiteColor];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if ([json isKindOfClass:[NSArray class]]) &#123;</span><br><span class=\"line\">    NSArray *components = [self NSNumberArray:json];</span><br><span class=\"line\">    CGFloat alpha = components.count &gt; 3 ? [self CGFloat:components[3]] : 1.0;</span><br><span class=\"line\">    return [UIColor colorWithRed:[self CGFloat:components[0]]</span><br><span class=\"line\">                           green:[self CGFloat:components[1]]</span><br><span class=\"line\">                            blue:[self CGFloat:components[2]]</span><br><span class=\"line\">                           alpha:alpha];</span><br><span class=\"line\">  &#125; else if ([json isKindOfClass:[NSNumber class]]) &#123;</span><br><span class=\"line\">    NSUInteger argb = [self NSUInteger:json];</span><br><span class=\"line\">    CGFloat a = ((argb &gt;&gt; 24) &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    CGFloat r = ((argb &gt;&gt; 16) &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    CGFloat g = ((argb &gt;&gt; 8) &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    CGFloat b = (argb &amp; 0xFF) / 255.0;</span><br><span class=\"line\">    return [UIColor colorWithRed:r green:g blue:b alpha:a];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    RCTLogConvertError(json, @&quot;a UIColor. Did you forget to call processColor() on the JS side?&quot;);</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧。看起来该方法里只支持从RN那边传递过来的NSArray类型和NSNumber类型的。也不支持NSString类型的啊。所以RN中通过’red’这种字符串设置颜色的解析并不是在原生这部分。所以在原生部分支持字符串类型。通过该字符串key去对应皮肤包的色值表中去查找真正的色值。</p>\n</li>\n</ul>\n<ul>\n<li><p>RN部分<br>发现node_modules/react-native/Libraries/StyleSheet/processColor.js该文件中processColor()函数是用来解析色值的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  var Platform = require(&apos;Platform&apos;);</span><br><span class=\"line\">  var normalizeColor = require(&apos;normalizeColor&apos;);</span><br><span class=\"line\">/* eslint no-bitwise: 0 */</span><br><span class=\"line\">function processColor(color) &#123;</span><br><span class=\"line\">  if (color === undefined || color === null) &#123;</span><br><span class=\"line\">    return color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  var int32Color = normalizeColor(color);</span><br><span class=\"line\">  if (int32Color === null) &#123;</span><br><span class=\"line\">    return undefined;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if(typeof int32Color === &apos;string&apos;) &#123;</span><br><span class=\"line\">    return int32Color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Converts 0xrrggbbaa into 0xaarrggbb</span><br><span class=\"line\">  int32Color = (int32Color &lt;&lt; 24 | int32Color &gt;&gt;&gt; 8) &gt;&gt;&gt; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (Platform.OS === &apos;android&apos;) &#123;</span><br><span class=\"line\">    // Android use 32 bit *signed* integer to represent the color</span><br><span class=\"line\">    // We utilize the fact that bitwise operations in JS also operates on</span><br><span class=\"line\">    // signed 32 bit integers, so that we can use those to convert from</span><br><span class=\"line\">    // *unsigned* to *signed* 32bit int that way.</span><br><span class=\"line\">    int32Color = int32Color | 0x0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return int32Color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该方法中，RN会去查找类似’red’这样的色值，并且返回为一个32位int类型。如果没找到对应色值，它会强转为一个0x0的色值。所以我们在它查找完之后，强转之前，如果没找到，直接将字符串类型的变量返回出去，这样原生也就能接受到一个字符串类型的key了。</p>\n</li>\n</ul>"},{"layout":"post","title":"React Native 01：学习笔记","date":"2016-07-20T03:44:50.000Z","_content":"\n> React Native是Facebook弄出来的一款用来开发真正原生、可渲染iOS和 Android移动应用的JavaScrit框架。它其实就是基于Javascript和React的基础上来开发原生应用。并且一份代码可以同时支持iOS和Android，也就是能够做到真正意义上的跨平台。React Native和React的区别在于，React是将浏览器作为渲染平台的，RN则是将移动设备作为渲染平台。代码上的体现就是用web思想去写原生的代码。所以ReactNative具有Native的一个最大的优势，它可以做到热更新，也就是不需要发包就可以改点东西\n\n## IDE\n\nNuclide：Nuclide 是 Facebook 推出的一套基于 Atom 的开发工具集。提供自动完成和JavaScript类型检查，内建React开发支持，并支持 Facebook 最新的 React Native 库，支持 Facebook 的 Flow JavaScript 类型检查器。\nPS:推荐使用Atom配合Nuclide来搞RN开发。反正是好用。\n<!-- more -->\n\n## HelloWorld\n\n![DraggedImage.png](http://upload-images.jianshu.io/upload_images/1488967-e8ec6c5fd6def5a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* ####package.json\n\n  这个文件主要是用来配置一些信息的，添加一些依赖库的。然后需要利用npm执行npm install命令来安装模块到node_modules目录。\n  PS:npm是一个Node的模块管理器。我们只需要一行命令就能将一些开源的模块给搞下来。感觉和cocoapods功能有点像。\n\n![DraggedImage-1.png](http://upload-images.jianshu.io/upload_images/1488967-8b818dc3449ff01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* ####iOS工程\n\n  从index.ios.js文件中创建了一个名字叫AwesomeProject的view，并且添加到window的rootVC的view上。\n  ![DraggedImage-2.png](http://upload-images.jianshu.io/upload_images/1488967-18c0bc4333325908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* ####index.ios.js\n\n  ![DraggedImage-3.png](http://upload-images.jianshu.io/upload_images/1488967-b02587533049e761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## ES5&ES6\n\n不管是ES5还是ES6都只是JS的一个规范，RN中并没有强制规定你要用哪个。但是RN官方还有很多大神们都建议我们直接入手ES6。但是问题就来了，你从开源网站上clone下来的代码就有的人用ES5,有的人用ES6了。所有知道这两个的区别是有必要的。不然你就会看到如下类似的红色页面：\n\n![5478D0A5F1183C3D2EDEB67CCCBB36DE.jpg.png](http://upload-images.jianshu.io/upload_images/1488967-e3c12198a497792b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n\n### 类（Class ）\n\nJS中的Class具有很多面向对象语言的特性，虽然它也有属性，方法。还有继承等。但都只是假象。它并不是真正意义上的面向对象语言中的那种class。它其实通过构造函数的形式。将类的属性和方法都定义在构造函数的prototype对象上面。额。好吧。用的时候还是像面向对象的那种方式使用。\n\n```\n//1.定义class\nclass Point { \n  constructor(x, y) {// 构造函数\n\t this.x = x;\n\t this.y = y;\n   } \n  toString() { \n\treturn '(' + this.x + ', ' + this.y + ')'; \n   }\n}\n// 2.创建实例\nvar a = new Point();\na.toString();\n```\n\n上面定义了一个Point类，有2个属性（x和y），一个构造方法（constructor）还有一个方法（toString）。\n一个class对应一个构造函数。当你使用new创建一个该类的实例的时候，它会调用该构造函数。同样一个class可以生成个多个的实例对象，但是所有的实例对象都共有这一个class原型。\n\n### 继承（extends）\n\n```\nclass Point3D extends Point { \n   constructor(x, y, z) {    \n \t super(x,y);\n \t this.z = z;\n    } \n   toString() { \n \treturn '(' + this.x + ', ' + this.y + ',' + this.z + ')'; \n    }\n }\n```\n\n上面Point3D类继承与Point，并且在构造函数里利用suepr（）方法调用了父类的构造函数。\nJS中的继承，子类可以具有父类所有属性和方法。但是在子类的构造函数里，必须要调用super（）,这样才能在子类中使用this关键字。\n\n### 回调函数和Promise\n\n在RN中经常要用到异步编程。所以就需要将执行的结果回调出去。一般采用2种方式。一种是回调函数，另一种是Promise。\n例如：\n\n```\n1.回调函数\n //定义\n StorageUtil.load = function(key,successCallback,errorCallback){\n \tstorage.load({\n \t  key: key,\n \t}).then(ret => {\n \t  successCallback(ret);\n \t}).catch(err => {\n \t  errorCallback(err);\n \t})  \n }\n //使用\n \tStorageUtil.load(\n \t  APPID_KEY,\n \t  (data)=> {\n \t\tconsole.log('data'+data);\n \t  },\n \t  (err)=> {\n \t\tconsole.log('err'+err);\n \t  }\n \t);\n 2.Promise\n //定义\n StorageUtil.load2 = function(key){\n    return new Promise((resolve, reject) =>{\n \tstorage.load({\n \t  key: key,\n \t}).then(ret => {\n \t  resolve(ret);\n \t}).catch(err => {\n \t  reject(err);\n \t})  \n   });\n }\n //使用\n \tStorageUtil.load2(APPID_KEY).then((data)=>{\n \t\tconsole.log('[load2]---'+data);\n \t})\n \t.catch((error)=>{\n \t\tconsole.log('err'+err);\n \t});\n```\n### 引用\n\n* ES5\n\n  ```\n  //1.导入\n   var React = require(\"react\");\n   var {\n   \t   Component, \n   \t   PropTypes\n   } = React;\n   var ReactNative = require(\"react-native\");\n   var {\n   \t   Image,\n   \t   Text,\n   } = ReactNative; \n   //2.导出\n   var MyComponent = React.createClass({ \n   \t  ...\n   });\n   module.exports = MyComponent;\n   //3.引用\n   var MyComponent = require('./MyComponent');\n  ```\n\n  ​\n\n* ES6\n\n  ```\n  //1.导入\n   import React, { \n   \t  Component, \n   \t  PropTypes,\n   } from 'react';\n   import { \n  \t  Image, \n   \t  Text,\n   } from 'react-native'\n   //2.导出\n   export default class MyComponent extends Component{ \n   \t  ...\n   }\n   //3.引用\n   import MyComponent from './MyComponent';\n  ```\n\n  ​\n\n### 组件\n\n* ES5\n\n  ```\n  //1.组件\n   var Photo = React.createClass({ \n   \t\trender: function() {\n   \t\t\t   return ( \n   \t\t\t\t  <Image source={this.props.source} /> \n   \t\t\t  ); \n   \t\t},\n   });\n   //2.组件方法\n   test: function(){ \n   },\n   //3.Props\n   getDefaultProps: function() { //默认属性\n   \t  return { \n   \t\t\timageId: 0, \n   \t  }; \n   },\n   propTypes: {  //属性类型\n   \t  imageId: React.PropTypes.number.isRequired, \n   },\n   //4.state\n   getInitialState: function() { \n   \t  return { \n   \t\t  iconName:'', \n   \t  }; \n   },\n   //5.bind()\n   在ES5下，React.createClass会把所有的方法都bind一遍,\n   例如：给按钮绑定点击方法的时候不需要bind(this)\n    render: function(){\n   \t\treturn (\n   \t\t\t<TouchableHighlight onPress={this.onClick}>\n   \t\t\t</TouchableHighlight>\n   \t\t)\n   \t},\n  ```\n\n  ​\n\n​\n\n* ES6\n\n  ```\n  //1.定义组件\n   class Photo extends React.Component { \n   \trender() { \n   \t\treturn ( \n   \t\t\t<Image source={this.props.source} /> \n   \t\t); \n   \t}\n   }\n   //2.组件方法\n   test(){ \n   },\n   //3.Props\n   static defaultProps = { //默认属性\n   \timageId: 0, \n   }; \n   static propTypes = { //属性类型\n   \t imageId: React.PropTypes.number.isRequired,\n   }; \n   //4.State\n   constructor(props){\n   \t  super(props); \n   \t  this.state = { \n   \t\t\t  iconName: '', \n   \t  };\n    }\n   //5.bind()\n   在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用\n   例如：\n   render(){ \n   \t  return (\n   \t\t\t<TouchableHighlight  onPress={this.onClick.bind(this)} >\n   \t\t\t</TouchableHighlight> \n   \t\t\t<TouchableHighlight  onPress={()=>this.onClick()}>\n   \t\t\t</TouchableHighlight> \n   \t\t) \n   }, \n  ```\n\n  ​\n\n## React\n\n###flex布局\n* 1.水平居中（alignItems:’center’）\n\n* 2.垂直居中（justifyContent:’center’）\n\n* 3.水平垂直居中（alignItems:’center’, justifyContent:’center’）\n\n* 4.flexDirection(row, column)\n\n  栗如：\n\n  * 行（宽度比例1:2:1）\n\n    ```\n    render() {\n       return (\n        <View style = {{flex:1,flexDirection:'row'}}>\n           <View style = {{flex:1,backgroundColor:'red'}}>\n           </View>\n           <View style = {{flex:2,backgroundColor:'blue'}}>\n           </View>\n           <View style = {{flex:1,backgroundColor:'yellow'}}>\n           </View>\n         </View>\n         );\n     }\n    ```\n\n    ![Simulator Screen Shot 2016年10月27日 上午11.42.51.png](http://upload-images.jianshu.io/upload_images/1488967-223a080a685d2d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\t\n\n  * 列（高度比例：1:2:1）\n\n    ```\n    render() {\n         return (\n           <View style = {{flex:1,flexDirection:'column'}}>\n             <View style = {{flex:1,backgroundColor:'red'}}>\n             </View>\n             <View style = {{flex:2,backgroundColor:'blue'}}>\n             </View>\n             <View style = {{flex:1,backgroundColor:'yellow'}}>\n             </View>\n           </View>\n           );\n       }\n    ```\n\n    ![Simulator Screen Shot 2016年10月27日 上午11.35.11.png](http://upload-images.jianshu.io/upload_images/1488967-18c3f054e9d00b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    *<u>PS:利用这个就可以完成一些复杂的网格布局,例如多层嵌套的布局。</u>,*\n\n    ![1902568823-56fde33a311f0_articlex-1.png](http://upload-images.jianshu.io/upload_images/1488967-3f75b2cf5ab0acff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* 5.图片（resizeMode）\n\n  * contain（模式容器完全容纳图片，图片宽高自适应)\n\n    ```\n    <Text style={styles.welcome}> 100px height with resizeMode contain </Text>\n    <View style={[{flex: 1, backgroundColor: '#fe0000'}]}>\n       <Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.contain}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} />\n    </View>\n    ```\n\n    ![DraggedImage-4.png](http://upload-images.jianshu.io/upload_images/1488967-8ac50bf3fd9d3170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  *  cover(图片会被截取并铺满容器)\n\n     ```\n      <Text style={styles.welcome}> 100px height with resizeMode cover </Text>\n        <View style={[{flex: 1, backgroundColor: '#fe0000'}]}>\n            <Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.cover}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} />\n        </View>\n     ```\n\n     ![DraggedImage-5-1.png](http://upload-images.jianshu.io/upload_images/1488967-3af14a733f92ff9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  * stretch(图片拉伸适应模式容器)\n\n    ```\n    <Text style={styles.welcome}> 100px height with resizeMode stretch </Text>\n       <View style={[{flex: 1, backgroundColor: '#fe0000'}]}>\n           <Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.stretch}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} />\n       </View>\n    ```\n\n    ![DraggedImage-6.png](http://upload-images.jianshu.io/upload_images/1488967-691333022d5e6a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###生命周期\n\n关于RN中组件的生命周期很类似于iOS中VC中的View的生命周期。一开始在调试的时候会发现组件的render方法调用的非常频繁。所以知道组件的生命周期是很有必要。这样我们可以在适当的方法里面完成相应的事情，比如在componentDidMount添加通知，componentWillUnmount中移除通知等等。\n\n![DraggedImage-7.png](http://upload-images.jianshu.io/upload_images/1488967-8205f2a9738e64a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* **getDefaultProps**：组件实例创建前调用，多个实例间共享引用。注意：如果父组件传递过来的Props和你在该函数中定义的Props的key一样，将会被覆盖。\n* **getInitalState**:组件示例创建的时候调用的第一个函数。主要用于初始化state。注意：为了在使用中不出现空值，建议初始化state的时候尽可能给每一个可能用到的值都赋一个初始值。\n* **componentWillMount**：在render前，getInitalState之后调用。仅调用一次，可以用于改变state操作。\n* **render**：组件渲染函数，会返回一个Virtual DOM，只允许返回一个最外层容器组件。render函数尽量保持纯净，只渲染组件，不修改状态，不执行副操作（比如计时器）。\n* **componentDidMount**:在render渲染之后，React会根据Virtual DOM来生成真实DOM，生成完毕后会调用该函数。在浏览器端（React），我们可以通过this.getDOMNode()来拿到相应的DOM节点。然而我们在RN中并用不到，在RN中主要在该函数中执行网络请求，定时器开启等相关操作\n* **componentWillReceiveProps(nextProps)**:props改变（父容器来更改或是redux），将会调用该函数。新的props将会作为参数传递进来，老的props可以根据this.props来获取。我们可以在该函数中对state作一些处理。注意：在该函数中更新state不会引起二次渲染。\n* **boolean shouldComponentUpdate(object nextProps, object nextState)**：该函数传递过来两个参数，新的state和新的props。state和props的改变都会调到该函数。该函数主要对传递过来的nextProps和nextState作判断。如果返回true则重新渲染，如果返回false则不重新渲染。在某些特定条件下，我们可以根据传递过来的props和state来选择更新或者不更新，从而提高效率。\n* **componentWillUpdate(object nextProps, object nextState)**：与componentWillMount方法类似，组件上会接收到新的props或者state渲染之前，调用该方法。但是不可以在该方法中更新state和props。\n* **componentDidUpdate(object prevProps,object prevState)**:和初始化时期的componentDidMount类似，在render之后，真实DOM生成之后调用该函数。传递过来的是当前的props和state。在该函数中同样可以使用this.getDOMNode()来拿到相应的DOM节点。如果你需要在运行中执行某些副操作，请在该函数中完成。\n* **componentWillUnmount**：组件DOM中移除的时候调用。在这里进行一些相关的销毁操作，比如定时器，监听等等。\n\n## React Native\n\n###存储\nRN官方有封装一个AsyncStorage组件，采用key-value的形式用来处理一些数据存储操作。\nPS：更推荐使用react-native-storage这个开源组件，它是对AsyncStorage的一层封装，并且他每个方法都是会返回一个Promise对象。使用起来更加方便。\n```\nimport React, { Component } from 'react';\n import {\n   AsyncStorage,\n } from 'react-native';\n import Storage from 'react-native-storage'; \n global.USER = { \n   admin_id: '',\n   user_name: '',\n   admin_name: '',\n   expiry: 0,\n   auth_token: '' \n };\n global.APPID = 0;\n \n \n \n global.USER_KEY = 'USERKEY';\n global.APPID_KEY = 'APPIDKEY';\n global.SHOW_ERROR = '0'; //0表示显示全部，1显示异常\n \n var StorageUtil = {};\n \n var storage = new Storage({\n   // 最大容量，默认值1000条数据循环存储\n   size: 1000,\n \n   // 存储引擎：对于RN使用AsyncStorage，对于web使用window.localStorage\n  // 如果不指定则数据只会保存在内存中，重启后即丢失\n   storageBackend: AsyncStorage,\n \n   // 数据过期时间，默认一整天（1000 * 3600 * 24 毫秒），设为null则永不过期\n   defaultExpires: null,\n \n   // 读写时在内存中缓存数据。默认启用。\n   enableCache: true,\n \n  // 如果storage中没有相应数据，或数据已过期，\n   // 则会调用相应的sync同步方法，无缝返回最新数据。\n   sync: {\n   }\n });\n \n \n \n StorageUtil.init = function(callback){\n     storage.getBatchData([\n         { key: USER_KEY },\n         { key: APPID_KEY }\n     ]).then(results => {\n      console.log('[results]--'+ results);\n      USER = results[0];\n       APPID = results[1];\n      console.log('[init:USER]--'+ USER);\n      console.log('[init:APPID]--'+ APPID);\n      callback(true);\n    }).catch(err => {\n      console.log(err);\n      callback(false);\n    });  \n },\nStorageUtil.save = function(key,data){\n  // 使用key来保存数据。这些数据一般是全局独有的，常常需要调用的。\n  // 除非你手动移除，这些数据会被永久保存，而且默认不会过期。\n  storage.save({\n    key: key,  //注意:请不要在key中使用_下划线符号!\n    rawData: data,\n     // 如果不指定过期时间，则会使用defaultExpires参数\n     // 如果设为null，则永不过期\n     // expires: 1000 * 36000\n\n   });\n   if (key == USER_KEY) {\n     USER = data;\n   }else if (key == APPID_KEY) {\n     APPID = data;\n   }\n   console.log('[SAVE:USER]--'+ USER.user_name);\n   console.log('[SAVE:APPID]--'+ APPID);\n },\n StorageUtil.load = function(key,successCallback,errorCallback){\n   // 读取\n   storage.load({\n     key: key,\n   }).then(ret => {\n     successCallback(ret);\n     //如果找到数据，则在then方法中返回\n   }).catch(err => {\n     //如果没有找到数据且没有同步方法，\n    //或者有其他异常，则在catch中返回\n     errorCallback(err);\n   })  \n },\n \n module.exports = StorageUtil;\n```\n###网络\nRN的网络组件封装的非常好用。直接上代码吧。\n```\n getMoviesFromApiAsync() {\n     return fetch('http://facebook.github.io/react-native/movies.json')\n       .then((response) => response.json())\n       .then((responseJson) => {\n         return responseJson.movies;\n       })\n       .catch((error) => {\n         console.error(error);\n       });\n   }\n```\n###桥接\n例如：\n```\nOC代码\nRCT_EXPORT_METHOD(getVersion:(RCTResponseSenderBlock)callback)\n{\n  NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"];\n  callback(@[version]);\n}\n```\n\n```\nJS代码\nASHUtilManager.getVersion((version)=> {\n\t\t\tthis.setState({\n      \t\t\tversionText : 'V' + version,\n      \t\t});\n\t\t});\n```\n***PS：在RCT_EXPORT_METHOD宏括起来的方法都是异步执行的，如果方法里涉及到UI的操作，需要放到主线程里执行。RN中的桥接方式比JSBridge好用多了。***\n\n----\n##ReactNative疑问整理：\n* 1.RN中没有VC的概念。它把view的生命周期事件封装在了view里面，而不是像iOS中用VC去管理view的生命周期。suoyi RN中的转场都只是view层的切换。\n* 2.this.setState()不生效。\n  ![.png](http://upload-images.jianshu.io/upload_images/1488967-7cc66594fcce14d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  react中的setState 是异步执行的，修改状态后并没有马上生效， setState 函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，就是设置状态成功之后执行的。所以正确做法。\n  ![屏幕快照 2016-11-08 下午5.23.52.png](http://upload-images.jianshu.io/upload_images/1488967-ebb3cdf71c9ac2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* 3.RN中ImageView加载网络图片，只做了内存缓存，而没有做磁盘缓存。\n  ![读取缓存 .png](http://upload-images.jianshu.io/upload_images/1488967-4a1ccedc8b6ad87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  ![添加缓存.png](http://upload-images.jianshu.io/upload_images/1488967-dc36f197305d3aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  上面代码中_decodedImageCache对象的类型是NSCache。可以看出RN并没有做磁盘缓存。\n* 4.RN的网络请求没有被NSURLProtocol拦截。\n  在想怎么给RN中的图片做磁盘缓存的时候，调试的过程中发现RN中通过fetch发起的所有请求都没有被注册的NSURLProtocol拦截，那么问题就来了。没有被拦截，难道是RN的网络用了更底层的东西？\n* 5.关于动态下发代码，有两种做法。\n  *  在程序一启动的时候，判断是否需要更新，然后去下载所有代码打包后zip包。之后需要显示RN的view的时候就可以去加载对应的view就可以了。\n  *  一个页面对应一个url，通过这个url去请求单独页面的RN代码。这样可以做到每次进入的时候都会加载最新的页面。也就是像浏览器那样重新打开，重新去请求页面。\n\n  但是最后还是选择了第一种方式，同时保留了第二种。在封装的vc上，提供自动刷新的属性。也支持每次进入页面都自动更新代码。\n\n附录：\n学习资料\n[http://reactnative.cn/]\n[https://github.com/reactnativecn/react-native-guide]\n[http://www.jianshu.com/p/7c43af022758]\n","source":"_posts/rn-01.md","raw":"---\nlayout: post\ntitle: React Native 01：学习笔记\ndate: 2016-07-20 11:44:50\ncategories: \n- 技术\n- [技术, React Native]\ntags: \n- 技术\n- 笔记\n- React Native\n---\n\n> React Native是Facebook弄出来的一款用来开发真正原生、可渲染iOS和 Android移动应用的JavaScrit框架。它其实就是基于Javascript和React的基础上来开发原生应用。并且一份代码可以同时支持iOS和Android，也就是能够做到真正意义上的跨平台。React Native和React的区别在于，React是将浏览器作为渲染平台的，RN则是将移动设备作为渲染平台。代码上的体现就是用web思想去写原生的代码。所以ReactNative具有Native的一个最大的优势，它可以做到热更新，也就是不需要发包就可以改点东西\n\n## IDE\n\nNuclide：Nuclide 是 Facebook 推出的一套基于 Atom 的开发工具集。提供自动完成和JavaScript类型检查，内建React开发支持，并支持 Facebook 最新的 React Native 库，支持 Facebook 的 Flow JavaScript 类型检查器。\nPS:推荐使用Atom配合Nuclide来搞RN开发。反正是好用。\n<!-- more -->\n\n## HelloWorld\n\n![DraggedImage.png](http://upload-images.jianshu.io/upload_images/1488967-e8ec6c5fd6def5a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* ####package.json\n\n  这个文件主要是用来配置一些信息的，添加一些依赖库的。然后需要利用npm执行npm install命令来安装模块到node_modules目录。\n  PS:npm是一个Node的模块管理器。我们只需要一行命令就能将一些开源的模块给搞下来。感觉和cocoapods功能有点像。\n\n![DraggedImage-1.png](http://upload-images.jianshu.io/upload_images/1488967-8b818dc3449ff01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* ####iOS工程\n\n  从index.ios.js文件中创建了一个名字叫AwesomeProject的view，并且添加到window的rootVC的view上。\n  ![DraggedImage-2.png](http://upload-images.jianshu.io/upload_images/1488967-18c0bc4333325908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* ####index.ios.js\n\n  ![DraggedImage-3.png](http://upload-images.jianshu.io/upload_images/1488967-b02587533049e761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## ES5&ES6\n\n不管是ES5还是ES6都只是JS的一个规范，RN中并没有强制规定你要用哪个。但是RN官方还有很多大神们都建议我们直接入手ES6。但是问题就来了，你从开源网站上clone下来的代码就有的人用ES5,有的人用ES6了。所有知道这两个的区别是有必要的。不然你就会看到如下类似的红色页面：\n\n![5478D0A5F1183C3D2EDEB67CCCBB36DE.jpg.png](http://upload-images.jianshu.io/upload_images/1488967-e3c12198a497792b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n\n### 类（Class ）\n\nJS中的Class具有很多面向对象语言的特性，虽然它也有属性，方法。还有继承等。但都只是假象。它并不是真正意义上的面向对象语言中的那种class。它其实通过构造函数的形式。将类的属性和方法都定义在构造函数的prototype对象上面。额。好吧。用的时候还是像面向对象的那种方式使用。\n\n```\n//1.定义class\nclass Point { \n  constructor(x, y) {// 构造函数\n\t this.x = x;\n\t this.y = y;\n   } \n  toString() { \n\treturn '(' + this.x + ', ' + this.y + ')'; \n   }\n}\n// 2.创建实例\nvar a = new Point();\na.toString();\n```\n\n上面定义了一个Point类，有2个属性（x和y），一个构造方法（constructor）还有一个方法（toString）。\n一个class对应一个构造函数。当你使用new创建一个该类的实例的时候，它会调用该构造函数。同样一个class可以生成个多个的实例对象，但是所有的实例对象都共有这一个class原型。\n\n### 继承（extends）\n\n```\nclass Point3D extends Point { \n   constructor(x, y, z) {    \n \t super(x,y);\n \t this.z = z;\n    } \n   toString() { \n \treturn '(' + this.x + ', ' + this.y + ',' + this.z + ')'; \n    }\n }\n```\n\n上面Point3D类继承与Point，并且在构造函数里利用suepr（）方法调用了父类的构造函数。\nJS中的继承，子类可以具有父类所有属性和方法。但是在子类的构造函数里，必须要调用super（）,这样才能在子类中使用this关键字。\n\n### 回调函数和Promise\n\n在RN中经常要用到异步编程。所以就需要将执行的结果回调出去。一般采用2种方式。一种是回调函数，另一种是Promise。\n例如：\n\n```\n1.回调函数\n //定义\n StorageUtil.load = function(key,successCallback,errorCallback){\n \tstorage.load({\n \t  key: key,\n \t}).then(ret => {\n \t  successCallback(ret);\n \t}).catch(err => {\n \t  errorCallback(err);\n \t})  \n }\n //使用\n \tStorageUtil.load(\n \t  APPID_KEY,\n \t  (data)=> {\n \t\tconsole.log('data'+data);\n \t  },\n \t  (err)=> {\n \t\tconsole.log('err'+err);\n \t  }\n \t);\n 2.Promise\n //定义\n StorageUtil.load2 = function(key){\n    return new Promise((resolve, reject) =>{\n \tstorage.load({\n \t  key: key,\n \t}).then(ret => {\n \t  resolve(ret);\n \t}).catch(err => {\n \t  reject(err);\n \t})  \n   });\n }\n //使用\n \tStorageUtil.load2(APPID_KEY).then((data)=>{\n \t\tconsole.log('[load2]---'+data);\n \t})\n \t.catch((error)=>{\n \t\tconsole.log('err'+err);\n \t});\n```\n### 引用\n\n* ES5\n\n  ```\n  //1.导入\n   var React = require(\"react\");\n   var {\n   \t   Component, \n   \t   PropTypes\n   } = React;\n   var ReactNative = require(\"react-native\");\n   var {\n   \t   Image,\n   \t   Text,\n   } = ReactNative; \n   //2.导出\n   var MyComponent = React.createClass({ \n   \t  ...\n   });\n   module.exports = MyComponent;\n   //3.引用\n   var MyComponent = require('./MyComponent');\n  ```\n\n  ​\n\n* ES6\n\n  ```\n  //1.导入\n   import React, { \n   \t  Component, \n   \t  PropTypes,\n   } from 'react';\n   import { \n  \t  Image, \n   \t  Text,\n   } from 'react-native'\n   //2.导出\n   export default class MyComponent extends Component{ \n   \t  ...\n   }\n   //3.引用\n   import MyComponent from './MyComponent';\n  ```\n\n  ​\n\n### 组件\n\n* ES5\n\n  ```\n  //1.组件\n   var Photo = React.createClass({ \n   \t\trender: function() {\n   \t\t\t   return ( \n   \t\t\t\t  <Image source={this.props.source} /> \n   \t\t\t  ); \n   \t\t},\n   });\n   //2.组件方法\n   test: function(){ \n   },\n   //3.Props\n   getDefaultProps: function() { //默认属性\n   \t  return { \n   \t\t\timageId: 0, \n   \t  }; \n   },\n   propTypes: {  //属性类型\n   \t  imageId: React.PropTypes.number.isRequired, \n   },\n   //4.state\n   getInitialState: function() { \n   \t  return { \n   \t\t  iconName:'', \n   \t  }; \n   },\n   //5.bind()\n   在ES5下，React.createClass会把所有的方法都bind一遍,\n   例如：给按钮绑定点击方法的时候不需要bind(this)\n    render: function(){\n   \t\treturn (\n   \t\t\t<TouchableHighlight onPress={this.onClick}>\n   \t\t\t</TouchableHighlight>\n   \t\t)\n   \t},\n  ```\n\n  ​\n\n​\n\n* ES6\n\n  ```\n  //1.定义组件\n   class Photo extends React.Component { \n   \trender() { \n   \t\treturn ( \n   \t\t\t<Image source={this.props.source} /> \n   \t\t); \n   \t}\n   }\n   //2.组件方法\n   test(){ \n   },\n   //3.Props\n   static defaultProps = { //默认属性\n   \timageId: 0, \n   }; \n   static propTypes = { //属性类型\n   \t imageId: React.PropTypes.number.isRequired,\n   }; \n   //4.State\n   constructor(props){\n   \t  super(props); \n   \t  this.state = { \n   \t\t\t  iconName: '', \n   \t  };\n    }\n   //5.bind()\n   在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用\n   例如：\n   render(){ \n   \t  return (\n   \t\t\t<TouchableHighlight  onPress={this.onClick.bind(this)} >\n   \t\t\t</TouchableHighlight> \n   \t\t\t<TouchableHighlight  onPress={()=>this.onClick()}>\n   \t\t\t</TouchableHighlight> \n   \t\t) \n   }, \n  ```\n\n  ​\n\n## React\n\n###flex布局\n* 1.水平居中（alignItems:’center’）\n\n* 2.垂直居中（justifyContent:’center’）\n\n* 3.水平垂直居中（alignItems:’center’, justifyContent:’center’）\n\n* 4.flexDirection(row, column)\n\n  栗如：\n\n  * 行（宽度比例1:2:1）\n\n    ```\n    render() {\n       return (\n        <View style = {{flex:1,flexDirection:'row'}}>\n           <View style = {{flex:1,backgroundColor:'red'}}>\n           </View>\n           <View style = {{flex:2,backgroundColor:'blue'}}>\n           </View>\n           <View style = {{flex:1,backgroundColor:'yellow'}}>\n           </View>\n         </View>\n         );\n     }\n    ```\n\n    ![Simulator Screen Shot 2016年10月27日 上午11.42.51.png](http://upload-images.jianshu.io/upload_images/1488967-223a080a685d2d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\t\n\n  * 列（高度比例：1:2:1）\n\n    ```\n    render() {\n         return (\n           <View style = {{flex:1,flexDirection:'column'}}>\n             <View style = {{flex:1,backgroundColor:'red'}}>\n             </View>\n             <View style = {{flex:2,backgroundColor:'blue'}}>\n             </View>\n             <View style = {{flex:1,backgroundColor:'yellow'}}>\n             </View>\n           </View>\n           );\n       }\n    ```\n\n    ![Simulator Screen Shot 2016年10月27日 上午11.35.11.png](http://upload-images.jianshu.io/upload_images/1488967-18c3f054e9d00b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    *<u>PS:利用这个就可以完成一些复杂的网格布局,例如多层嵌套的布局。</u>,*\n\n    ![1902568823-56fde33a311f0_articlex-1.png](http://upload-images.jianshu.io/upload_images/1488967-3f75b2cf5ab0acff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* 5.图片（resizeMode）\n\n  * contain（模式容器完全容纳图片，图片宽高自适应)\n\n    ```\n    <Text style={styles.welcome}> 100px height with resizeMode contain </Text>\n    <View style={[{flex: 1, backgroundColor: '#fe0000'}]}>\n       <Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.contain}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} />\n    </View>\n    ```\n\n    ![DraggedImage-4.png](http://upload-images.jianshu.io/upload_images/1488967-8ac50bf3fd9d3170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  *  cover(图片会被截取并铺满容器)\n\n     ```\n      <Text style={styles.welcome}> 100px height with resizeMode cover </Text>\n        <View style={[{flex: 1, backgroundColor: '#fe0000'}]}>\n            <Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.cover}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} />\n        </View>\n     ```\n\n     ![DraggedImage-5-1.png](http://upload-images.jianshu.io/upload_images/1488967-3af14a733f92ff9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  * stretch(图片拉伸适应模式容器)\n\n    ```\n    <Text style={styles.welcome}> 100px height with resizeMode stretch </Text>\n       <View style={[{flex: 1, backgroundColor: '#fe0000'}]}>\n           <Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.stretch}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} />\n       </View>\n    ```\n\n    ![DraggedImage-6.png](http://upload-images.jianshu.io/upload_images/1488967-691333022d5e6a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###生命周期\n\n关于RN中组件的生命周期很类似于iOS中VC中的View的生命周期。一开始在调试的时候会发现组件的render方法调用的非常频繁。所以知道组件的生命周期是很有必要。这样我们可以在适当的方法里面完成相应的事情，比如在componentDidMount添加通知，componentWillUnmount中移除通知等等。\n\n![DraggedImage-7.png](http://upload-images.jianshu.io/upload_images/1488967-8205f2a9738e64a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* **getDefaultProps**：组件实例创建前调用，多个实例间共享引用。注意：如果父组件传递过来的Props和你在该函数中定义的Props的key一样，将会被覆盖。\n* **getInitalState**:组件示例创建的时候调用的第一个函数。主要用于初始化state。注意：为了在使用中不出现空值，建议初始化state的时候尽可能给每一个可能用到的值都赋一个初始值。\n* **componentWillMount**：在render前，getInitalState之后调用。仅调用一次，可以用于改变state操作。\n* **render**：组件渲染函数，会返回一个Virtual DOM，只允许返回一个最外层容器组件。render函数尽量保持纯净，只渲染组件，不修改状态，不执行副操作（比如计时器）。\n* **componentDidMount**:在render渲染之后，React会根据Virtual DOM来生成真实DOM，生成完毕后会调用该函数。在浏览器端（React），我们可以通过this.getDOMNode()来拿到相应的DOM节点。然而我们在RN中并用不到，在RN中主要在该函数中执行网络请求，定时器开启等相关操作\n* **componentWillReceiveProps(nextProps)**:props改变（父容器来更改或是redux），将会调用该函数。新的props将会作为参数传递进来，老的props可以根据this.props来获取。我们可以在该函数中对state作一些处理。注意：在该函数中更新state不会引起二次渲染。\n* **boolean shouldComponentUpdate(object nextProps, object nextState)**：该函数传递过来两个参数，新的state和新的props。state和props的改变都会调到该函数。该函数主要对传递过来的nextProps和nextState作判断。如果返回true则重新渲染，如果返回false则不重新渲染。在某些特定条件下，我们可以根据传递过来的props和state来选择更新或者不更新，从而提高效率。\n* **componentWillUpdate(object nextProps, object nextState)**：与componentWillMount方法类似，组件上会接收到新的props或者state渲染之前，调用该方法。但是不可以在该方法中更新state和props。\n* **componentDidUpdate(object prevProps,object prevState)**:和初始化时期的componentDidMount类似，在render之后，真实DOM生成之后调用该函数。传递过来的是当前的props和state。在该函数中同样可以使用this.getDOMNode()来拿到相应的DOM节点。如果你需要在运行中执行某些副操作，请在该函数中完成。\n* **componentWillUnmount**：组件DOM中移除的时候调用。在这里进行一些相关的销毁操作，比如定时器，监听等等。\n\n## React Native\n\n###存储\nRN官方有封装一个AsyncStorage组件，采用key-value的形式用来处理一些数据存储操作。\nPS：更推荐使用react-native-storage这个开源组件，它是对AsyncStorage的一层封装，并且他每个方法都是会返回一个Promise对象。使用起来更加方便。\n```\nimport React, { Component } from 'react';\n import {\n   AsyncStorage,\n } from 'react-native';\n import Storage from 'react-native-storage'; \n global.USER = { \n   admin_id: '',\n   user_name: '',\n   admin_name: '',\n   expiry: 0,\n   auth_token: '' \n };\n global.APPID = 0;\n \n \n \n global.USER_KEY = 'USERKEY';\n global.APPID_KEY = 'APPIDKEY';\n global.SHOW_ERROR = '0'; //0表示显示全部，1显示异常\n \n var StorageUtil = {};\n \n var storage = new Storage({\n   // 最大容量，默认值1000条数据循环存储\n   size: 1000,\n \n   // 存储引擎：对于RN使用AsyncStorage，对于web使用window.localStorage\n  // 如果不指定则数据只会保存在内存中，重启后即丢失\n   storageBackend: AsyncStorage,\n \n   // 数据过期时间，默认一整天（1000 * 3600 * 24 毫秒），设为null则永不过期\n   defaultExpires: null,\n \n   // 读写时在内存中缓存数据。默认启用。\n   enableCache: true,\n \n  // 如果storage中没有相应数据，或数据已过期，\n   // 则会调用相应的sync同步方法，无缝返回最新数据。\n   sync: {\n   }\n });\n \n \n \n StorageUtil.init = function(callback){\n     storage.getBatchData([\n         { key: USER_KEY },\n         { key: APPID_KEY }\n     ]).then(results => {\n      console.log('[results]--'+ results);\n      USER = results[0];\n       APPID = results[1];\n      console.log('[init:USER]--'+ USER);\n      console.log('[init:APPID]--'+ APPID);\n      callback(true);\n    }).catch(err => {\n      console.log(err);\n      callback(false);\n    });  \n },\nStorageUtil.save = function(key,data){\n  // 使用key来保存数据。这些数据一般是全局独有的，常常需要调用的。\n  // 除非你手动移除，这些数据会被永久保存，而且默认不会过期。\n  storage.save({\n    key: key,  //注意:请不要在key中使用_下划线符号!\n    rawData: data,\n     // 如果不指定过期时间，则会使用defaultExpires参数\n     // 如果设为null，则永不过期\n     // expires: 1000 * 36000\n\n   });\n   if (key == USER_KEY) {\n     USER = data;\n   }else if (key == APPID_KEY) {\n     APPID = data;\n   }\n   console.log('[SAVE:USER]--'+ USER.user_name);\n   console.log('[SAVE:APPID]--'+ APPID);\n },\n StorageUtil.load = function(key,successCallback,errorCallback){\n   // 读取\n   storage.load({\n     key: key,\n   }).then(ret => {\n     successCallback(ret);\n     //如果找到数据，则在then方法中返回\n   }).catch(err => {\n     //如果没有找到数据且没有同步方法，\n    //或者有其他异常，则在catch中返回\n     errorCallback(err);\n   })  \n },\n \n module.exports = StorageUtil;\n```\n###网络\nRN的网络组件封装的非常好用。直接上代码吧。\n```\n getMoviesFromApiAsync() {\n     return fetch('http://facebook.github.io/react-native/movies.json')\n       .then((response) => response.json())\n       .then((responseJson) => {\n         return responseJson.movies;\n       })\n       .catch((error) => {\n         console.error(error);\n       });\n   }\n```\n###桥接\n例如：\n```\nOC代码\nRCT_EXPORT_METHOD(getVersion:(RCTResponseSenderBlock)callback)\n{\n  NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"];\n  callback(@[version]);\n}\n```\n\n```\nJS代码\nASHUtilManager.getVersion((version)=> {\n\t\t\tthis.setState({\n      \t\t\tversionText : 'V' + version,\n      \t\t});\n\t\t});\n```\n***PS：在RCT_EXPORT_METHOD宏括起来的方法都是异步执行的，如果方法里涉及到UI的操作，需要放到主线程里执行。RN中的桥接方式比JSBridge好用多了。***\n\n----\n##ReactNative疑问整理：\n* 1.RN中没有VC的概念。它把view的生命周期事件封装在了view里面，而不是像iOS中用VC去管理view的生命周期。suoyi RN中的转场都只是view层的切换。\n* 2.this.setState()不生效。\n  ![.png](http://upload-images.jianshu.io/upload_images/1488967-7cc66594fcce14d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  react中的setState 是异步执行的，修改状态后并没有马上生效， setState 函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，就是设置状态成功之后执行的。所以正确做法。\n  ![屏幕快照 2016-11-08 下午5.23.52.png](http://upload-images.jianshu.io/upload_images/1488967-ebb3cdf71c9ac2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* 3.RN中ImageView加载网络图片，只做了内存缓存，而没有做磁盘缓存。\n  ![读取缓存 .png](http://upload-images.jianshu.io/upload_images/1488967-4a1ccedc8b6ad87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  ![添加缓存.png](http://upload-images.jianshu.io/upload_images/1488967-dc36f197305d3aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  上面代码中_decodedImageCache对象的类型是NSCache。可以看出RN并没有做磁盘缓存。\n* 4.RN的网络请求没有被NSURLProtocol拦截。\n  在想怎么给RN中的图片做磁盘缓存的时候，调试的过程中发现RN中通过fetch发起的所有请求都没有被注册的NSURLProtocol拦截，那么问题就来了。没有被拦截，难道是RN的网络用了更底层的东西？\n* 5.关于动态下发代码，有两种做法。\n  *  在程序一启动的时候，判断是否需要更新，然后去下载所有代码打包后zip包。之后需要显示RN的view的时候就可以去加载对应的view就可以了。\n  *  一个页面对应一个url，通过这个url去请求单独页面的RN代码。这样可以做到每次进入的时候都会加载最新的页面。也就是像浏览器那样重新打开，重新去请求页面。\n\n  但是最后还是选择了第一种方式，同时保留了第二种。在封装的vc上，提供自动刷新的属性。也支持每次进入页面都自动更新代码。\n\n附录：\n学习资料\n[http://reactnative.cn/]\n[https://github.com/reactnativecn/react-native-guide]\n[http://www.jianshu.com/p/7c43af022758]\n","slug":"rn-01","published":1,"updated":"2019-12-20T06:08:22.051Z","comments":1,"photos":[],"link":"","_id":"ck4dsux3e0012odnquzqw55wl","content":"<blockquote>\n<p>React Native是Facebook弄出来的一款用来开发真正原生、可渲染iOS和 Android移动应用的JavaScrit框架。它其实就是基于Javascript和React的基础上来开发原生应用。并且一份代码可以同时支持iOS和Android，也就是能够做到真正意义上的跨平台。React Native和React的区别在于，React是将浏览器作为渲染平台的，RN则是将移动设备作为渲染平台。代码上的体现就是用web思想去写原生的代码。所以ReactNative具有Native的一个最大的优势，它可以做到热更新，也就是不需要发包就可以改点东西</p>\n</blockquote>\n<h2 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h2><p>Nuclide：Nuclide 是 Facebook 推出的一套基于 Atom 的开发工具集。提供自动完成和JavaScript类型检查，内建React开发支持，并支持 Facebook 最新的 React Native 库，支持 Facebook 的 Flow JavaScript 类型检查器。<br>PS:推荐使用Atom配合Nuclide来搞RN开发。反正是好用。<br><a id=\"more\"></a></p>\n<h2 id=\"HelloWorld\"><a href=\"#HelloWorld\" class=\"headerlink\" title=\"HelloWorld\"></a>HelloWorld</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-e8ec6c5fd6def5a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage.png\"></p>\n<ul>\n<li><p>####package.json</p>\n<p>这个文件主要是用来配置一些信息的，添加一些依赖库的。然后需要利用npm执行npm install命令来安装模块到node_modules目录。<br>PS:npm是一个Node的模块管理器。我们只需要一行命令就能将一些开源的模块给搞下来。感觉和cocoapods功能有点像。</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-8b818dc3449ff01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-1.png\"></p>\n<ul>\n<li><p>####iOS工程</p>\n<p>从index.ios.js文件中创建了一个名字叫AwesomeProject的view，并且添加到window的rootVC的view上。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-18c0bc4333325908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-2.png\"></p>\n</li>\n</ul>\n<ul>\n<li><p>####index.ios.js</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-b02587533049e761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-3.png\"></p>\n</li>\n</ul>\n<h2 id=\"ES5-amp-ES6\"><a href=\"#ES5-amp-ES6\" class=\"headerlink\" title=\"ES5&amp;ES6\"></a>ES5&amp;ES6</h2><p>不管是ES5还是ES6都只是JS的一个规范，RN中并没有强制规定你要用哪个。但是RN官方还有很多大神们都建议我们直接入手ES6。但是问题就来了，你从开源网站上clone下来的代码就有的人用ES5,有的人用ES6了。所有知道这两个的区别是有必要的。不然你就会看到如下类似的红色页面：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-e3c12198a497792b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"5478D0A5F1183C3D2EDEB67CCCBB36DE.jpg.png\"></p>\n<h3 id=\"类（Class-）\"><a href=\"#类（Class-）\" class=\"headerlink\" title=\"类（Class ）\"></a>类（Class ）</h3><p>JS中的Class具有很多面向对象语言的特性，虽然它也有属性，方法。还有继承等。但都只是假象。它并不是真正意义上的面向对象语言中的那种class。它其实通过构造函数的形式。将类的属性和方法都定义在构造函数的prototype对象上面。额。好吧。用的时候还是像面向对象的那种方式使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.定义class</span><br><span class=\"line\">class Point &#123; </span><br><span class=\"line\">  constructor(x, y) &#123;// 构造函数</span><br><span class=\"line\">\t this.x = x;</span><br><span class=\"line\">\t this.y = y;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">  toString() &#123; </span><br><span class=\"line\">\treturn &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 2.创建实例</span><br><span class=\"line\">var a = new Point();</span><br><span class=\"line\">a.toString();</span><br></pre></td></tr></table></figure>\n<p>上面定义了一个Point类，有2个属性（x和y），一个构造方法（constructor）还有一个方法（toString）。<br>一个class对应一个构造函数。当你使用new创建一个该类的实例的时候，它会调用该构造函数。同样一个class可以生成个多个的实例对象，但是所有的实例对象都共有这一个class原型。</p>\n<h3 id=\"继承（extends）\"><a href=\"#继承（extends）\" class=\"headerlink\" title=\"继承（extends）\"></a>继承（extends）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point3D extends Point &#123; </span><br><span class=\"line\">   constructor(x, y, z) &#123;    </span><br><span class=\"line\"> \t super(x,y);</span><br><span class=\"line\"> \t this.z = z;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">   toString() &#123; </span><br><span class=\"line\"> \treturn &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;,&apos; + this.z + &apos;)&apos;; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>上面Point3D类继承与Point，并且在构造函数里利用suepr（）方法调用了父类的构造函数。<br>JS中的继承，子类可以具有父类所有属性和方法。但是在子类的构造函数里，必须要调用super（）,这样才能在子类中使用this关键字。</p>\n<h3 id=\"回调函数和Promise\"><a href=\"#回调函数和Promise\" class=\"headerlink\" title=\"回调函数和Promise\"></a>回调函数和Promise</h3><p>在RN中经常要用到异步编程。所以就需要将执行的结果回调出去。一般采用2种方式。一种是回调函数，另一种是Promise。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.回调函数</span><br><span class=\"line\"> //定义</span><br><span class=\"line\"> StorageUtil.load = function(key,successCallback,errorCallback)&#123;</span><br><span class=\"line\"> \tstorage.load(&#123;</span><br><span class=\"line\"> \t  key: key,</span><br><span class=\"line\"> \t&#125;).then(ret =&gt; &#123;</span><br><span class=\"line\"> \t  successCallback(ret);</span><br><span class=\"line\"> \t&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\"> \t  errorCallback(err);</span><br><span class=\"line\"> \t&#125;)  </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //使用</span><br><span class=\"line\"> \tStorageUtil.load(</span><br><span class=\"line\"> \t  APPID_KEY,</span><br><span class=\"line\"> \t  (data)=&gt; &#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;data&apos;+data);</span><br><span class=\"line\"> \t  &#125;,</span><br><span class=\"line\"> \t  (err)=&gt; &#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;err&apos;+err);</span><br><span class=\"line\"> \t  &#125;</span><br><span class=\"line\"> \t);</span><br><span class=\"line\"> 2.Promise</span><br><span class=\"line\"> //定义</span><br><span class=\"line\"> StorageUtil.load2 = function(key)&#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt;&#123;</span><br><span class=\"line\"> \tstorage.load(&#123;</span><br><span class=\"line\"> \t  key: key,</span><br><span class=\"line\"> \t&#125;).then(ret =&gt; &#123;</span><br><span class=\"line\"> \t  resolve(ret);</span><br><span class=\"line\"> \t&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\"> \t  reject(err);</span><br><span class=\"line\"> \t&#125;)  </span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //使用</span><br><span class=\"line\"> \tStorageUtil.load2(APPID_KEY).then((data)=&gt;&#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;[load2]---&apos;+data);</span><br><span class=\"line\"> \t&#125;)</span><br><span class=\"line\"> \t.catch((error)=&gt;&#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;err&apos;+err);</span><br><span class=\"line\"> \t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><ul>\n<li><p>ES5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.导入</span><br><span class=\"line\"> var React = require(&quot;react&quot;);</span><br><span class=\"line\"> var &#123;</span><br><span class=\"line\"> \t   Component, </span><br><span class=\"line\"> \t   PropTypes</span><br><span class=\"line\"> &#125; = React;</span><br><span class=\"line\"> var ReactNative = require(&quot;react-native&quot;);</span><br><span class=\"line\"> var &#123;</span><br><span class=\"line\"> \t   Image,</span><br><span class=\"line\"> \t   Text,</span><br><span class=\"line\"> &#125; = ReactNative; </span><br><span class=\"line\"> //2.导出</span><br><span class=\"line\"> var MyComponent = React.createClass(&#123; </span><br><span class=\"line\"> \t  ...</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> module.exports = MyComponent;</span><br><span class=\"line\"> //3.引用</span><br><span class=\"line\"> var MyComponent = require(&apos;./MyComponent&apos;);</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>ES6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.导入</span><br><span class=\"line\"> import React, &#123; </span><br><span class=\"line\"> \t  Component, </span><br><span class=\"line\"> \t  PropTypes,</span><br><span class=\"line\"> &#125; from &apos;react&apos;;</span><br><span class=\"line\"> import &#123; </span><br><span class=\"line\">\t  Image, </span><br><span class=\"line\"> \t  Text,</span><br><span class=\"line\"> &#125; from &apos;react-native&apos;</span><br><span class=\"line\"> //2.导出</span><br><span class=\"line\"> export default class MyComponent extends Component&#123; </span><br><span class=\"line\"> \t  ...</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //3.引用</span><br><span class=\"line\"> import MyComponent from &apos;./MyComponent&apos;;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><ul>\n<li><p>ES5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.组件</span><br><span class=\"line\"> var Photo = React.createClass(&#123; </span><br><span class=\"line\"> \t\trender: function() &#123;</span><br><span class=\"line\"> \t\t\t   return ( </span><br><span class=\"line\"> \t\t\t\t  &lt;Image source=&#123;this.props.source&#125; /&gt; </span><br><span class=\"line\"> \t\t\t  ); </span><br><span class=\"line\"> \t\t&#125;,</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> //2.组件方法</span><br><span class=\"line\"> test: function()&#123; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //3.Props</span><br><span class=\"line\"> getDefaultProps: function() &#123; //默认属性</span><br><span class=\"line\"> \t  return &#123; </span><br><span class=\"line\"> \t\t\timageId: 0, </span><br><span class=\"line\"> \t  &#125;; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> propTypes: &#123;  //属性类型</span><br><span class=\"line\"> \t  imageId: React.PropTypes.number.isRequired, </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //4.state</span><br><span class=\"line\"> getInitialState: function() &#123; </span><br><span class=\"line\"> \t  return &#123; </span><br><span class=\"line\"> \t\t  iconName:&apos;&apos;, </span><br><span class=\"line\"> \t  &#125;; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //5.bind()</span><br><span class=\"line\"> 在ES5下，React.createClass会把所有的方法都bind一遍,</span><br><span class=\"line\"> 例如：给按钮绑定点击方法的时候不需要bind(this)</span><br><span class=\"line\">  render: function()&#123;</span><br><span class=\"line\"> \t\treturn (</span><br><span class=\"line\"> \t\t\t&lt;TouchableHighlight onPress=&#123;this.onClick&#125;&gt;</span><br><span class=\"line\"> \t\t\t&lt;/TouchableHighlight&gt;</span><br><span class=\"line\"> \t\t)</span><br><span class=\"line\"> \t&#125;,</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<p>​</p>\n<ul>\n<li><p>ES6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.定义组件</span><br><span class=\"line\"> class Photo extends React.Component &#123; </span><br><span class=\"line\"> \trender() &#123; </span><br><span class=\"line\"> \t\treturn ( </span><br><span class=\"line\"> \t\t\t&lt;Image source=&#123;this.props.source&#125; /&gt; </span><br><span class=\"line\"> \t\t); </span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //2.组件方法</span><br><span class=\"line\"> test()&#123; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //3.Props</span><br><span class=\"line\"> static defaultProps = &#123; //默认属性</span><br><span class=\"line\"> \timageId: 0, </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> static propTypes = &#123; //属性类型</span><br><span class=\"line\"> \t imageId: React.PropTypes.number.isRequired,</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> //4.State</span><br><span class=\"line\"> constructor(props)&#123;</span><br><span class=\"line\"> \t  super(props); </span><br><span class=\"line\"> \t  this.state = &#123; </span><br><span class=\"line\"> \t\t\t  iconName: &apos;&apos;, </span><br><span class=\"line\"> \t  &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> //5.bind()</span><br><span class=\"line\"> 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用</span><br><span class=\"line\"> 例如：</span><br><span class=\"line\"> render()&#123; </span><br><span class=\"line\"> \t  return (</span><br><span class=\"line\"> \t\t\t&lt;TouchableHighlight  onPress=&#123;this.onClick.bind(this)&#125; &gt;</span><br><span class=\"line\"> \t\t\t&lt;/TouchableHighlight&gt; </span><br><span class=\"line\"> \t\t\t&lt;TouchableHighlight  onPress=&#123;()=&gt;this.onClick()&#125;&gt;</span><br><span class=\"line\"> \t\t\t&lt;/TouchableHighlight&gt; </span><br><span class=\"line\"> \t\t) </span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>###flex布局</p>\n<ul>\n<li><p>1.水平居中（alignItems:’center’）</p>\n</li>\n<li><p>2.垂直居中（justifyContent:’center’）</p>\n</li>\n<li><p>3.水平垂直居中（alignItems:’center’, justifyContent:’center’）</p>\n</li>\n<li><p>4.flexDirection(row, column)</p>\n<p>栗如：</p>\n<ul>\n<li><p>行（宽度比例1:2:1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">   return (</span><br><span class=\"line\">    &lt;View style = &#123;&#123;flex:1,flexDirection:&apos;row&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;red&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:2,backgroundColor:&apos;blue&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;yellow&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">     &lt;/View&gt;</span><br><span class=\"line\">     );</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-223a080a685d2d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Simulator Screen Shot 2016年10月27日 上午11.42.51.png\">    </p>\n</li>\n<li><p>列（高度比例：1:2:1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">     return (</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:1,flexDirection:&apos;column&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;red&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;/View&gt;</span><br><span class=\"line\">         &lt;View style = &#123;&#123;flex:2,backgroundColor:&apos;blue&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;/View&gt;</span><br><span class=\"line\">         &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;yellow&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;/View&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">       );</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-18c3f054e9d00b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Simulator Screen Shot 2016年10月27日 上午11.35.11.png\"></p>\n<p><em><u>PS:利用这个就可以完成一些复杂的网格布局,例如多层嵌套的布局。</u>,</em></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-3f75b2cf5ab0acff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1902568823-56fde33a311f0_articlex-1.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>5.图片（resizeMode）</p>\n<ul>\n<li><p>contain（模式容器完全容纳图片，图片宽高自适应)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;styles.welcome&#125;&gt; 100px height with resizeMode contain &lt;/Text&gt;</span><br><span class=\"line\">&lt;View style=&#123;[&#123;flex: 1, backgroundColor: &apos;#fe0000&apos;&#125;]&#125;&gt;</span><br><span class=\"line\">   &lt;Image style=&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.contain&#125;&#125; source=&#123;&#123;uri: &apos;http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&apos;&#125;&#125; /&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-8ac50bf3fd9d3170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-4.png\"></p>\n</li>\n<li><p>cover(图片会被截取并铺满容器)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;styles.welcome&#125;&gt; 100px height with resizeMode cover &lt;/Text&gt;</span><br><span class=\"line\">  &lt;View style=&#123;[&#123;flex: 1, backgroundColor: &apos;#fe0000&apos;&#125;]&#125;&gt;</span><br><span class=\"line\">      &lt;Image style=&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.cover&#125;&#125; source=&#123;&#123;uri: &apos;http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&apos;&#125;&#125; /&gt;</span><br><span class=\"line\">  &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-3af14a733f92ff9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-5-1.png\"></p>\n</li>\n<li><p>stretch(图片拉伸适应模式容器)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;styles.welcome&#125;&gt; 100px height with resizeMode stretch &lt;/Text&gt;</span><br><span class=\"line\">   &lt;View style=&#123;[&#123;flex: 1, backgroundColor: &apos;#fe0000&apos;&#125;]&#125;&gt;</span><br><span class=\"line\">       &lt;Image style=&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.stretch&#125;&#125; source=&#123;&#123;uri: &apos;http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&apos;&#125;&#125; /&gt;</span><br><span class=\"line\">   &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-691333022d5e6a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-6.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>###生命周期</p>\n<p>关于RN中组件的生命周期很类似于iOS中VC中的View的生命周期。一开始在调试的时候会发现组件的render方法调用的非常频繁。所以知道组件的生命周期是很有必要。这样我们可以在适当的方法里面完成相应的事情，比如在componentDidMount添加通知，componentWillUnmount中移除通知等等。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-8205f2a9738e64a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-7.png\"></p>\n<ul>\n<li><strong>getDefaultProps</strong>：组件实例创建前调用，多个实例间共享引用。注意：如果父组件传递过来的Props和你在该函数中定义的Props的key一样，将会被覆盖。</li>\n<li><strong>getInitalState</strong>:组件示例创建的时候调用的第一个函数。主要用于初始化state。注意：为了在使用中不出现空值，建议初始化state的时候尽可能给每一个可能用到的值都赋一个初始值。</li>\n<li><strong>componentWillMount</strong>：在render前，getInitalState之后调用。仅调用一次，可以用于改变state操作。</li>\n<li><strong>render</strong>：组件渲染函数，会返回一个Virtual DOM，只允许返回一个最外层容器组件。render函数尽量保持纯净，只渲染组件，不修改状态，不执行副操作（比如计时器）。</li>\n<li><strong>componentDidMount</strong>:在render渲染之后，React会根据Virtual DOM来生成真实DOM，生成完毕后会调用该函数。在浏览器端（React），我们可以通过this.getDOMNode()来拿到相应的DOM节点。然而我们在RN中并用不到，在RN中主要在该函数中执行网络请求，定时器开启等相关操作</li>\n<li><strong>componentWillReceiveProps(nextProps)</strong>:props改变（父容器来更改或是redux），将会调用该函数。新的props将会作为参数传递进来，老的props可以根据this.props来获取。我们可以在该函数中对state作一些处理。注意：在该函数中更新state不会引起二次渲染。</li>\n<li><strong>boolean shouldComponentUpdate(object nextProps, object nextState)</strong>：该函数传递过来两个参数，新的state和新的props。state和props的改变都会调到该函数。该函数主要对传递过来的nextProps和nextState作判断。如果返回true则重新渲染，如果返回false则不重新渲染。在某些特定条件下，我们可以根据传递过来的props和state来选择更新或者不更新，从而提高效率。</li>\n<li><strong>componentWillUpdate(object nextProps, object nextState)</strong>：与componentWillMount方法类似，组件上会接收到新的props或者state渲染之前，调用该方法。但是不可以在该方法中更新state和props。</li>\n<li><strong>componentDidUpdate(object prevProps,object prevState)</strong>:和初始化时期的componentDidMount类似，在render之后，真实DOM生成之后调用该函数。传递过来的是当前的props和state。在该函数中同样可以使用this.getDOMNode()来拿到相应的DOM节点。如果你需要在运行中执行某些副操作，请在该函数中完成。</li>\n<li><strong>componentWillUnmount</strong>：组件DOM中移除的时候调用。在这里进行一些相关的销毁操作，比如定时器，监听等等。</li>\n</ul>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><p>###存储<br>RN官方有封装一个AsyncStorage组件，采用key-value的形式用来处理一些数据存储操作。<br>PS：更推荐使用react-native-storage这个开源组件，它是对AsyncStorage的一层封装，并且他每个方法都是会返回一个Promise对象。使用起来更加方便。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\"> import &#123;</span><br><span class=\"line\">   AsyncStorage,</span><br><span class=\"line\"> &#125; from &apos;react-native&apos;;</span><br><span class=\"line\"> import Storage from &apos;react-native-storage&apos;; </span><br><span class=\"line\"> global.USER = &#123; </span><br><span class=\"line\">   admin_id: &apos;&apos;,</span><br><span class=\"line\">   user_name: &apos;&apos;,</span><br><span class=\"line\">   admin_name: &apos;&apos;,</span><br><span class=\"line\">   expiry: 0,</span><br><span class=\"line\">   auth_token: &apos;&apos; </span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> global.APPID = 0;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> global.USER_KEY = &apos;USERKEY&apos;;</span><br><span class=\"line\"> global.APPID_KEY = &apos;APPIDKEY&apos;;</span><br><span class=\"line\"> global.SHOW_ERROR = &apos;0&apos;; //0表示显示全部，1显示异常</span><br><span class=\"line\"> </span><br><span class=\"line\"> var StorageUtil = &#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> var storage = new Storage(&#123;</span><br><span class=\"line\">   // 最大容量，默认值1000条数据循环存储</span><br><span class=\"line\">   size: 1000,</span><br><span class=\"line\"> </span><br><span class=\"line\">   // 存储引擎：对于RN使用AsyncStorage，对于web使用window.localStorage</span><br><span class=\"line\">  // 如果不指定则数据只会保存在内存中，重启后即丢失</span><br><span class=\"line\">   storageBackend: AsyncStorage,</span><br><span class=\"line\"> </span><br><span class=\"line\">   // 数据过期时间，默认一整天（1000 * 3600 * 24 毫秒），设为null则永不过期</span><br><span class=\"line\">   defaultExpires: null,</span><br><span class=\"line\"> </span><br><span class=\"line\">   // 读写时在内存中缓存数据。默认启用。</span><br><span class=\"line\">   enableCache: true,</span><br><span class=\"line\"> </span><br><span class=\"line\">  // 如果storage中没有相应数据，或数据已过期，</span><br><span class=\"line\">   // 则会调用相应的sync同步方法，无缝返回最新数据。</span><br><span class=\"line\">   sync: &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> StorageUtil.init = function(callback)&#123;</span><br><span class=\"line\">     storage.getBatchData([</span><br><span class=\"line\">         &#123; key: USER_KEY &#125;,</span><br><span class=\"line\">         &#123; key: APPID_KEY &#125;</span><br><span class=\"line\">     ]).then(results =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;[results]--&apos;+ results);</span><br><span class=\"line\">      USER = results[0];</span><br><span class=\"line\">       APPID = results[1];</span><br><span class=\"line\">      console.log(&apos;[init:USER]--&apos;+ USER);</span><br><span class=\"line\">      console.log(&apos;[init:APPID]--&apos;+ APPID);</span><br><span class=\"line\">      callback(true);</span><br><span class=\"line\">    &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">      console.log(err);</span><br><span class=\"line\">      callback(false);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\">StorageUtil.save = function(key,data)&#123;</span><br><span class=\"line\">  // 使用key来保存数据。这些数据一般是全局独有的，常常需要调用的。</span><br><span class=\"line\">  // 除非你手动移除，这些数据会被永久保存，而且默认不会过期。</span><br><span class=\"line\">  storage.save(&#123;</span><br><span class=\"line\">    key: key,  //注意:请不要在key中使用_下划线符号!</span><br><span class=\"line\">    rawData: data,</span><br><span class=\"line\">     // 如果不指定过期时间，则会使用defaultExpires参数</span><br><span class=\"line\">     // 如果设为null，则永不过期</span><br><span class=\"line\">     // expires: 1000 * 36000</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   if (key == USER_KEY) &#123;</span><br><span class=\"line\">     USER = data;</span><br><span class=\"line\">   &#125;else if (key == APPID_KEY) &#123;</span><br><span class=\"line\">     APPID = data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&apos;[SAVE:USER]--&apos;+ USER.user_name);</span><br><span class=\"line\">   console.log(&apos;[SAVE:APPID]--&apos;+ APPID);</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> StorageUtil.load = function(key,successCallback,errorCallback)&#123;</span><br><span class=\"line\">   // 读取</span><br><span class=\"line\">   storage.load(&#123;</span><br><span class=\"line\">     key: key,</span><br><span class=\"line\">   &#125;).then(ret =&gt; &#123;</span><br><span class=\"line\">     successCallback(ret);</span><br><span class=\"line\">     //如果找到数据，则在then方法中返回</span><br><span class=\"line\">   &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">     //如果没有找到数据且没有同步方法，</span><br><span class=\"line\">    //或者有其他异常，则在catch中返回</span><br><span class=\"line\">     errorCallback(err);</span><br><span class=\"line\">   &#125;)  </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\"> module.exports = StorageUtil;</span><br></pre></td></tr></table></figure></p>\n<p>###网络<br>RN的网络组件封装的非常好用。直接上代码吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getMoviesFromApiAsync() &#123;</span><br><span class=\"line\">    return fetch(&apos;http://facebook.github.io/react-native/movies.json&apos;)</span><br><span class=\"line\">      .then((response) =&gt; response.json())</span><br><span class=\"line\">      .then((responseJson) =&gt; &#123;</span><br><span class=\"line\">        return responseJson.movies;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch((error) =&gt; &#123;</span><br><span class=\"line\">        console.error(error);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>###桥接<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OC代码</span><br><span class=\"line\">RCT_EXPORT_METHOD(getVersion:(RCTResponseSenderBlock)callback)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br><span class=\"line\">  callback(@[version]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS代码</span><br><span class=\"line\">ASHUtilManager.getVersion((version)=&gt; &#123;</span><br><span class=\"line\">\t\t\tthis.setState(&#123;</span><br><span class=\"line\">      \t\t\tversionText : &apos;V&apos; + version,</span><br><span class=\"line\">      \t\t&#125;);</span><br><span class=\"line\">\t\t&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong><em>PS：在RCT_EXPORT_METHOD宏括起来的方法都是异步执行的，如果方法里涉及到UI的操作，需要放到主线程里执行。RN中的桥接方式比JSBridge好用多了。</em></strong></p>\n<hr>\n<p>##ReactNative疑问整理：</p>\n<ul>\n<li>1.RN中没有VC的概念。它把view的生命周期事件封装在了view里面，而不是像iOS中用VC去管理view的生命周期。suoyi RN中的转场都只是view层的切换。</li>\n<li>2.this.setState()不生效。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-7cc66594fcce14d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\".png\"><br>react中的setState 是异步执行的，修改状态后并没有马上生效， setState 函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，就是设置状态成功之后执行的。所以正确做法。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-ebb3cdf71c9ac2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-11-08 下午5.23.52.png\"></li>\n</ul>\n<ul>\n<li>3.RN中ImageView加载网络图片，只做了内存缓存，而没有做磁盘缓存。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4a1ccedc8b6ad87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"读取缓存 .png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-dc36f197305d3aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加缓存.png\"><br>上面代码中_decodedImageCache对象的类型是NSCache。可以看出RN并没有做磁盘缓存。</li>\n<li>4.RN的网络请求没有被NSURLProtocol拦截。<br>在想怎么给RN中的图片做磁盘缓存的时候，调试的过程中发现RN中通过fetch发起的所有请求都没有被注册的NSURLProtocol拦截，那么问题就来了。没有被拦截，难道是RN的网络用了更底层的东西？</li>\n<li><p>5.关于动态下发代码，有两种做法。</p>\n<ul>\n<li>在程序一启动的时候，判断是否需要更新，然后去下载所有代码打包后zip包。之后需要显示RN的view的时候就可以去加载对应的view就可以了。</li>\n<li>一个页面对应一个url，通过这个url去请求单独页面的RN代码。这样可以做到每次进入的时候都会加载最新的页面。也就是像浏览器那样重新打开，重新去请求页面。</li>\n</ul>\n<p>但是最后还是选择了第一种方式，同时保留了第二种。在封装的vc上，提供自动刷新的属性。也支持每次进入页面都自动更新代码。</p>\n</li>\n</ul>\n<p>附录：<br>学习资料<br>[<a href=\"http://reactnative.cn/]\" target=\"_blank\" rel=\"noopener\">http://reactnative.cn/]</a><br>[<a href=\"https://github.com/reactnativecn/react-native-guide]\" target=\"_blank\" rel=\"noopener\">https://github.com/reactnativecn/react-native-guide]</a><br>[<a href=\"http://www.jianshu.com/p/7c43af022758]\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/7c43af022758]</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>React Native是Facebook弄出来的一款用来开发真正原生、可渲染iOS和 Android移动应用的JavaScrit框架。它其实就是基于Javascript和React的基础上来开发原生应用。并且一份代码可以同时支持iOS和Android，也就是能够做到真正意义上的跨平台。React Native和React的区别在于，React是将浏览器作为渲染平台的，RN则是将移动设备作为渲染平台。代码上的体现就是用web思想去写原生的代码。所以ReactNative具有Native的一个最大的优势，它可以做到热更新，也就是不需要发包就可以改点东西</p>\n</blockquote>\n<h2 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h2><p>Nuclide：Nuclide 是 Facebook 推出的一套基于 Atom 的开发工具集。提供自动完成和JavaScript类型检查，内建React开发支持，并支持 Facebook 最新的 React Native 库，支持 Facebook 的 Flow JavaScript 类型检查器。<br>PS:推荐使用Atom配合Nuclide来搞RN开发。反正是好用。<br>","more":"</p>\n<h2 id=\"HelloWorld\"><a href=\"#HelloWorld\" class=\"headerlink\" title=\"HelloWorld\"></a>HelloWorld</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-e8ec6c5fd6def5a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage.png\"></p>\n<ul>\n<li><p>####package.json</p>\n<p>这个文件主要是用来配置一些信息的，添加一些依赖库的。然后需要利用npm执行npm install命令来安装模块到node_modules目录。<br>PS:npm是一个Node的模块管理器。我们只需要一行命令就能将一些开源的模块给搞下来。感觉和cocoapods功能有点像。</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-8b818dc3449ff01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-1.png\"></p>\n<ul>\n<li><p>####iOS工程</p>\n<p>从index.ios.js文件中创建了一个名字叫AwesomeProject的view，并且添加到window的rootVC的view上。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-18c0bc4333325908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-2.png\"></p>\n</li>\n</ul>\n<ul>\n<li><p>####index.ios.js</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-b02587533049e761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-3.png\"></p>\n</li>\n</ul>\n<h2 id=\"ES5-amp-ES6\"><a href=\"#ES5-amp-ES6\" class=\"headerlink\" title=\"ES5&amp;ES6\"></a>ES5&amp;ES6</h2><p>不管是ES5还是ES6都只是JS的一个规范，RN中并没有强制规定你要用哪个。但是RN官方还有很多大神们都建议我们直接入手ES6。但是问题就来了，你从开源网站上clone下来的代码就有的人用ES5,有的人用ES6了。所有知道这两个的区别是有必要的。不然你就会看到如下类似的红色页面：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-e3c12198a497792b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"5478D0A5F1183C3D2EDEB67CCCBB36DE.jpg.png\"></p>\n<h3 id=\"类（Class-）\"><a href=\"#类（Class-）\" class=\"headerlink\" title=\"类（Class ）\"></a>类（Class ）</h3><p>JS中的Class具有很多面向对象语言的特性，虽然它也有属性，方法。还有继承等。但都只是假象。它并不是真正意义上的面向对象语言中的那种class。它其实通过构造函数的形式。将类的属性和方法都定义在构造函数的prototype对象上面。额。好吧。用的时候还是像面向对象的那种方式使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.定义class</span><br><span class=\"line\">class Point &#123; </span><br><span class=\"line\">  constructor(x, y) &#123;// 构造函数</span><br><span class=\"line\">\t this.x = x;</span><br><span class=\"line\">\t this.y = y;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">  toString() &#123; </span><br><span class=\"line\">\treturn &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 2.创建实例</span><br><span class=\"line\">var a = new Point();</span><br><span class=\"line\">a.toString();</span><br></pre></td></tr></table></figure>\n<p>上面定义了一个Point类，有2个属性（x和y），一个构造方法（constructor）还有一个方法（toString）。<br>一个class对应一个构造函数。当你使用new创建一个该类的实例的时候，它会调用该构造函数。同样一个class可以生成个多个的实例对象，但是所有的实例对象都共有这一个class原型。</p>\n<h3 id=\"继承（extends）\"><a href=\"#继承（extends）\" class=\"headerlink\" title=\"继承（extends）\"></a>继承（extends）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point3D extends Point &#123; </span><br><span class=\"line\">   constructor(x, y, z) &#123;    </span><br><span class=\"line\"> \t super(x,y);</span><br><span class=\"line\"> \t this.z = z;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">   toString() &#123; </span><br><span class=\"line\"> \treturn &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;,&apos; + this.z + &apos;)&apos;; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>上面Point3D类继承与Point，并且在构造函数里利用suepr（）方法调用了父类的构造函数。<br>JS中的继承，子类可以具有父类所有属性和方法。但是在子类的构造函数里，必须要调用super（）,这样才能在子类中使用this关键字。</p>\n<h3 id=\"回调函数和Promise\"><a href=\"#回调函数和Promise\" class=\"headerlink\" title=\"回调函数和Promise\"></a>回调函数和Promise</h3><p>在RN中经常要用到异步编程。所以就需要将执行的结果回调出去。一般采用2种方式。一种是回调函数，另一种是Promise。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.回调函数</span><br><span class=\"line\"> //定义</span><br><span class=\"line\"> StorageUtil.load = function(key,successCallback,errorCallback)&#123;</span><br><span class=\"line\"> \tstorage.load(&#123;</span><br><span class=\"line\"> \t  key: key,</span><br><span class=\"line\"> \t&#125;).then(ret =&gt; &#123;</span><br><span class=\"line\"> \t  successCallback(ret);</span><br><span class=\"line\"> \t&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\"> \t  errorCallback(err);</span><br><span class=\"line\"> \t&#125;)  </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //使用</span><br><span class=\"line\"> \tStorageUtil.load(</span><br><span class=\"line\"> \t  APPID_KEY,</span><br><span class=\"line\"> \t  (data)=&gt; &#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;data&apos;+data);</span><br><span class=\"line\"> \t  &#125;,</span><br><span class=\"line\"> \t  (err)=&gt; &#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;err&apos;+err);</span><br><span class=\"line\"> \t  &#125;</span><br><span class=\"line\"> \t);</span><br><span class=\"line\"> 2.Promise</span><br><span class=\"line\"> //定义</span><br><span class=\"line\"> StorageUtil.load2 = function(key)&#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt;&#123;</span><br><span class=\"line\"> \tstorage.load(&#123;</span><br><span class=\"line\"> \t  key: key,</span><br><span class=\"line\"> \t&#125;).then(ret =&gt; &#123;</span><br><span class=\"line\"> \t  resolve(ret);</span><br><span class=\"line\"> \t&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\"> \t  reject(err);</span><br><span class=\"line\"> \t&#125;)  </span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //使用</span><br><span class=\"line\"> \tStorageUtil.load2(APPID_KEY).then((data)=&gt;&#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;[load2]---&apos;+data);</span><br><span class=\"line\"> \t&#125;)</span><br><span class=\"line\"> \t.catch((error)=&gt;&#123;</span><br><span class=\"line\"> \t\tconsole.log(&apos;err&apos;+err);</span><br><span class=\"line\"> \t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><ul>\n<li><p>ES5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.导入</span><br><span class=\"line\"> var React = require(&quot;react&quot;);</span><br><span class=\"line\"> var &#123;</span><br><span class=\"line\"> \t   Component, </span><br><span class=\"line\"> \t   PropTypes</span><br><span class=\"line\"> &#125; = React;</span><br><span class=\"line\"> var ReactNative = require(&quot;react-native&quot;);</span><br><span class=\"line\"> var &#123;</span><br><span class=\"line\"> \t   Image,</span><br><span class=\"line\"> \t   Text,</span><br><span class=\"line\"> &#125; = ReactNative; </span><br><span class=\"line\"> //2.导出</span><br><span class=\"line\"> var MyComponent = React.createClass(&#123; </span><br><span class=\"line\"> \t  ...</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> module.exports = MyComponent;</span><br><span class=\"line\"> //3.引用</span><br><span class=\"line\"> var MyComponent = require(&apos;./MyComponent&apos;);</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>ES6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.导入</span><br><span class=\"line\"> import React, &#123; </span><br><span class=\"line\"> \t  Component, </span><br><span class=\"line\"> \t  PropTypes,</span><br><span class=\"line\"> &#125; from &apos;react&apos;;</span><br><span class=\"line\"> import &#123; </span><br><span class=\"line\">\t  Image, </span><br><span class=\"line\"> \t  Text,</span><br><span class=\"line\"> &#125; from &apos;react-native&apos;</span><br><span class=\"line\"> //2.导出</span><br><span class=\"line\"> export default class MyComponent extends Component&#123; </span><br><span class=\"line\"> \t  ...</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //3.引用</span><br><span class=\"line\"> import MyComponent from &apos;./MyComponent&apos;;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><ul>\n<li><p>ES5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.组件</span><br><span class=\"line\"> var Photo = React.createClass(&#123; </span><br><span class=\"line\"> \t\trender: function() &#123;</span><br><span class=\"line\"> \t\t\t   return ( </span><br><span class=\"line\"> \t\t\t\t  &lt;Image source=&#123;this.props.source&#125; /&gt; </span><br><span class=\"line\"> \t\t\t  ); </span><br><span class=\"line\"> \t\t&#125;,</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> //2.组件方法</span><br><span class=\"line\"> test: function()&#123; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //3.Props</span><br><span class=\"line\"> getDefaultProps: function() &#123; //默认属性</span><br><span class=\"line\"> \t  return &#123; </span><br><span class=\"line\"> \t\t\timageId: 0, </span><br><span class=\"line\"> \t  &#125;; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> propTypes: &#123;  //属性类型</span><br><span class=\"line\"> \t  imageId: React.PropTypes.number.isRequired, </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //4.state</span><br><span class=\"line\"> getInitialState: function() &#123; </span><br><span class=\"line\"> \t  return &#123; </span><br><span class=\"line\"> \t\t  iconName:&apos;&apos;, </span><br><span class=\"line\"> \t  &#125;; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //5.bind()</span><br><span class=\"line\"> 在ES5下，React.createClass会把所有的方法都bind一遍,</span><br><span class=\"line\"> 例如：给按钮绑定点击方法的时候不需要bind(this)</span><br><span class=\"line\">  render: function()&#123;</span><br><span class=\"line\"> \t\treturn (</span><br><span class=\"line\"> \t\t\t&lt;TouchableHighlight onPress=&#123;this.onClick&#125;&gt;</span><br><span class=\"line\"> \t\t\t&lt;/TouchableHighlight&gt;</span><br><span class=\"line\"> \t\t)</span><br><span class=\"line\"> \t&#125;,</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<p>​</p>\n<ul>\n<li><p>ES6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.定义组件</span><br><span class=\"line\"> class Photo extends React.Component &#123; </span><br><span class=\"line\"> \trender() &#123; </span><br><span class=\"line\"> \t\treturn ( </span><br><span class=\"line\"> \t\t\t&lt;Image source=&#123;this.props.source&#125; /&gt; </span><br><span class=\"line\"> \t\t); </span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> //2.组件方法</span><br><span class=\"line\"> test()&#123; </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> //3.Props</span><br><span class=\"line\"> static defaultProps = &#123; //默认属性</span><br><span class=\"line\"> \timageId: 0, </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> static propTypes = &#123; //属性类型</span><br><span class=\"line\"> \t imageId: React.PropTypes.number.isRequired,</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> //4.State</span><br><span class=\"line\"> constructor(props)&#123;</span><br><span class=\"line\"> \t  super(props); </span><br><span class=\"line\"> \t  this.state = &#123; </span><br><span class=\"line\"> \t\t\t  iconName: &apos;&apos;, </span><br><span class=\"line\"> \t  &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> //5.bind()</span><br><span class=\"line\"> 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用</span><br><span class=\"line\"> 例如：</span><br><span class=\"line\"> render()&#123; </span><br><span class=\"line\"> \t  return (</span><br><span class=\"line\"> \t\t\t&lt;TouchableHighlight  onPress=&#123;this.onClick.bind(this)&#125; &gt;</span><br><span class=\"line\"> \t\t\t&lt;/TouchableHighlight&gt; </span><br><span class=\"line\"> \t\t\t&lt;TouchableHighlight  onPress=&#123;()=&gt;this.onClick()&#125;&gt;</span><br><span class=\"line\"> \t\t\t&lt;/TouchableHighlight&gt; </span><br><span class=\"line\"> \t\t) </span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>###flex布局</p>\n<ul>\n<li><p>1.水平居中（alignItems:’center’）</p>\n</li>\n<li><p>2.垂直居中（justifyContent:’center’）</p>\n</li>\n<li><p>3.水平垂直居中（alignItems:’center’, justifyContent:’center’）</p>\n</li>\n<li><p>4.flexDirection(row, column)</p>\n<p>栗如：</p>\n<ul>\n<li><p>行（宽度比例1:2:1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">   return (</span><br><span class=\"line\">    &lt;View style = &#123;&#123;flex:1,flexDirection:&apos;row&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;red&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:2,backgroundColor:&apos;blue&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;yellow&apos;&#125;&#125;&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">     &lt;/View&gt;</span><br><span class=\"line\">     );</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-223a080a685d2d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Simulator Screen Shot 2016年10月27日 上午11.42.51.png\">    </p>\n</li>\n<li><p>列（高度比例：1:2:1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">     return (</span><br><span class=\"line\">       &lt;View style = &#123;&#123;flex:1,flexDirection:&apos;column&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;red&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;/View&gt;</span><br><span class=\"line\">         &lt;View style = &#123;&#123;flex:2,backgroundColor:&apos;blue&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;/View&gt;</span><br><span class=\"line\">         &lt;View style = &#123;&#123;flex:1,backgroundColor:&apos;yellow&apos;&#125;&#125;&gt;</span><br><span class=\"line\">         &lt;/View&gt;</span><br><span class=\"line\">       &lt;/View&gt;</span><br><span class=\"line\">       );</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-18c3f054e9d00b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Simulator Screen Shot 2016年10月27日 上午11.35.11.png\"></p>\n<p><em><u>PS:利用这个就可以完成一些复杂的网格布局,例如多层嵌套的布局。</u>,</em></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-3f75b2cf5ab0acff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1902568823-56fde33a311f0_articlex-1.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>5.图片（resizeMode）</p>\n<ul>\n<li><p>contain（模式容器完全容纳图片，图片宽高自适应)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;styles.welcome&#125;&gt; 100px height with resizeMode contain &lt;/Text&gt;</span><br><span class=\"line\">&lt;View style=&#123;[&#123;flex: 1, backgroundColor: &apos;#fe0000&apos;&#125;]&#125;&gt;</span><br><span class=\"line\">   &lt;Image style=&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.contain&#125;&#125; source=&#123;&#123;uri: &apos;http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&apos;&#125;&#125; /&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-8ac50bf3fd9d3170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-4.png\"></p>\n</li>\n<li><p>cover(图片会被截取并铺满容器)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;styles.welcome&#125;&gt; 100px height with resizeMode cover &lt;/Text&gt;</span><br><span class=\"line\">  &lt;View style=&#123;[&#123;flex: 1, backgroundColor: &apos;#fe0000&apos;&#125;]&#125;&gt;</span><br><span class=\"line\">      &lt;Image style=&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.cover&#125;&#125; source=&#123;&#123;uri: &apos;http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&apos;&#125;&#125; /&gt;</span><br><span class=\"line\">  &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-3af14a733f92ff9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-5-1.png\"></p>\n</li>\n<li><p>stretch(图片拉伸适应模式容器)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Text style=&#123;styles.welcome&#125;&gt; 100px height with resizeMode stretch &lt;/Text&gt;</span><br><span class=\"line\">   &lt;View style=&#123;[&#123;flex: 1, backgroundColor: &apos;#fe0000&apos;&#125;]&#125;&gt;</span><br><span class=\"line\">       &lt;Image style=&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.stretch&#125;&#125; source=&#123;&#123;uri: &apos;http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&apos;&#125;&#125; /&gt;</span><br><span class=\"line\">   &lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-691333022d5e6a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-6.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>###生命周期</p>\n<p>关于RN中组件的生命周期很类似于iOS中VC中的View的生命周期。一开始在调试的时候会发现组件的render方法调用的非常频繁。所以知道组件的生命周期是很有必要。这样我们可以在适当的方法里面完成相应的事情，比如在componentDidMount添加通知，componentWillUnmount中移除通知等等。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1488967-8205f2a9738e64a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DraggedImage-7.png\"></p>\n<ul>\n<li><strong>getDefaultProps</strong>：组件实例创建前调用，多个实例间共享引用。注意：如果父组件传递过来的Props和你在该函数中定义的Props的key一样，将会被覆盖。</li>\n<li><strong>getInitalState</strong>:组件示例创建的时候调用的第一个函数。主要用于初始化state。注意：为了在使用中不出现空值，建议初始化state的时候尽可能给每一个可能用到的值都赋一个初始值。</li>\n<li><strong>componentWillMount</strong>：在render前，getInitalState之后调用。仅调用一次，可以用于改变state操作。</li>\n<li><strong>render</strong>：组件渲染函数，会返回一个Virtual DOM，只允许返回一个最外层容器组件。render函数尽量保持纯净，只渲染组件，不修改状态，不执行副操作（比如计时器）。</li>\n<li><strong>componentDidMount</strong>:在render渲染之后，React会根据Virtual DOM来生成真实DOM，生成完毕后会调用该函数。在浏览器端（React），我们可以通过this.getDOMNode()来拿到相应的DOM节点。然而我们在RN中并用不到，在RN中主要在该函数中执行网络请求，定时器开启等相关操作</li>\n<li><strong>componentWillReceiveProps(nextProps)</strong>:props改变（父容器来更改或是redux），将会调用该函数。新的props将会作为参数传递进来，老的props可以根据this.props来获取。我们可以在该函数中对state作一些处理。注意：在该函数中更新state不会引起二次渲染。</li>\n<li><strong>boolean shouldComponentUpdate(object nextProps, object nextState)</strong>：该函数传递过来两个参数，新的state和新的props。state和props的改变都会调到该函数。该函数主要对传递过来的nextProps和nextState作判断。如果返回true则重新渲染，如果返回false则不重新渲染。在某些特定条件下，我们可以根据传递过来的props和state来选择更新或者不更新，从而提高效率。</li>\n<li><strong>componentWillUpdate(object nextProps, object nextState)</strong>：与componentWillMount方法类似，组件上会接收到新的props或者state渲染之前，调用该方法。但是不可以在该方法中更新state和props。</li>\n<li><strong>componentDidUpdate(object prevProps,object prevState)</strong>:和初始化时期的componentDidMount类似，在render之后，真实DOM生成之后调用该函数。传递过来的是当前的props和state。在该函数中同样可以使用this.getDOMNode()来拿到相应的DOM节点。如果你需要在运行中执行某些副操作，请在该函数中完成。</li>\n<li><strong>componentWillUnmount</strong>：组件DOM中移除的时候调用。在这里进行一些相关的销毁操作，比如定时器，监听等等。</li>\n</ul>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><p>###存储<br>RN官方有封装一个AsyncStorage组件，采用key-value的形式用来处理一些数据存储操作。<br>PS：更推荐使用react-native-storage这个开源组件，它是对AsyncStorage的一层封装，并且他每个方法都是会返回一个Promise对象。使用起来更加方便。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\"> import &#123;</span><br><span class=\"line\">   AsyncStorage,</span><br><span class=\"line\"> &#125; from &apos;react-native&apos;;</span><br><span class=\"line\"> import Storage from &apos;react-native-storage&apos;; </span><br><span class=\"line\"> global.USER = &#123; </span><br><span class=\"line\">   admin_id: &apos;&apos;,</span><br><span class=\"line\">   user_name: &apos;&apos;,</span><br><span class=\"line\">   admin_name: &apos;&apos;,</span><br><span class=\"line\">   expiry: 0,</span><br><span class=\"line\">   auth_token: &apos;&apos; </span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> global.APPID = 0;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> global.USER_KEY = &apos;USERKEY&apos;;</span><br><span class=\"line\"> global.APPID_KEY = &apos;APPIDKEY&apos;;</span><br><span class=\"line\"> global.SHOW_ERROR = &apos;0&apos;; //0表示显示全部，1显示异常</span><br><span class=\"line\"> </span><br><span class=\"line\"> var StorageUtil = &#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> var storage = new Storage(&#123;</span><br><span class=\"line\">   // 最大容量，默认值1000条数据循环存储</span><br><span class=\"line\">   size: 1000,</span><br><span class=\"line\"> </span><br><span class=\"line\">   // 存储引擎：对于RN使用AsyncStorage，对于web使用window.localStorage</span><br><span class=\"line\">  // 如果不指定则数据只会保存在内存中，重启后即丢失</span><br><span class=\"line\">   storageBackend: AsyncStorage,</span><br><span class=\"line\"> </span><br><span class=\"line\">   // 数据过期时间，默认一整天（1000 * 3600 * 24 毫秒），设为null则永不过期</span><br><span class=\"line\">   defaultExpires: null,</span><br><span class=\"line\"> </span><br><span class=\"line\">   // 读写时在内存中缓存数据。默认启用。</span><br><span class=\"line\">   enableCache: true,</span><br><span class=\"line\"> </span><br><span class=\"line\">  // 如果storage中没有相应数据，或数据已过期，</span><br><span class=\"line\">   // 则会调用相应的sync同步方法，无缝返回最新数据。</span><br><span class=\"line\">   sync: &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> StorageUtil.init = function(callback)&#123;</span><br><span class=\"line\">     storage.getBatchData([</span><br><span class=\"line\">         &#123; key: USER_KEY &#125;,</span><br><span class=\"line\">         &#123; key: APPID_KEY &#125;</span><br><span class=\"line\">     ]).then(results =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;[results]--&apos;+ results);</span><br><span class=\"line\">      USER = results[0];</span><br><span class=\"line\">       APPID = results[1];</span><br><span class=\"line\">      console.log(&apos;[init:USER]--&apos;+ USER);</span><br><span class=\"line\">      console.log(&apos;[init:APPID]--&apos;+ APPID);</span><br><span class=\"line\">      callback(true);</span><br><span class=\"line\">    &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">      console.log(err);</span><br><span class=\"line\">      callback(false);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\">StorageUtil.save = function(key,data)&#123;</span><br><span class=\"line\">  // 使用key来保存数据。这些数据一般是全局独有的，常常需要调用的。</span><br><span class=\"line\">  // 除非你手动移除，这些数据会被永久保存，而且默认不会过期。</span><br><span class=\"line\">  storage.save(&#123;</span><br><span class=\"line\">    key: key,  //注意:请不要在key中使用_下划线符号!</span><br><span class=\"line\">    rawData: data,</span><br><span class=\"line\">     // 如果不指定过期时间，则会使用defaultExpires参数</span><br><span class=\"line\">     // 如果设为null，则永不过期</span><br><span class=\"line\">     // expires: 1000 * 36000</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   if (key == USER_KEY) &#123;</span><br><span class=\"line\">     USER = data;</span><br><span class=\"line\">   &#125;else if (key == APPID_KEY) &#123;</span><br><span class=\"line\">     APPID = data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&apos;[SAVE:USER]--&apos;+ USER.user_name);</span><br><span class=\"line\">   console.log(&apos;[SAVE:APPID]--&apos;+ APPID);</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> StorageUtil.load = function(key,successCallback,errorCallback)&#123;</span><br><span class=\"line\">   // 读取</span><br><span class=\"line\">   storage.load(&#123;</span><br><span class=\"line\">     key: key,</span><br><span class=\"line\">   &#125;).then(ret =&gt; &#123;</span><br><span class=\"line\">     successCallback(ret);</span><br><span class=\"line\">     //如果找到数据，则在then方法中返回</span><br><span class=\"line\">   &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">     //如果没有找到数据且没有同步方法，</span><br><span class=\"line\">    //或者有其他异常，则在catch中返回</span><br><span class=\"line\">     errorCallback(err);</span><br><span class=\"line\">   &#125;)  </span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\"> module.exports = StorageUtil;</span><br></pre></td></tr></table></figure></p>\n<p>###网络<br>RN的网络组件封装的非常好用。直接上代码吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getMoviesFromApiAsync() &#123;</span><br><span class=\"line\">    return fetch(&apos;http://facebook.github.io/react-native/movies.json&apos;)</span><br><span class=\"line\">      .then((response) =&gt; response.json())</span><br><span class=\"line\">      .then((responseJson) =&gt; &#123;</span><br><span class=\"line\">        return responseJson.movies;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch((error) =&gt; &#123;</span><br><span class=\"line\">        console.error(error);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>###桥接<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OC代码</span><br><span class=\"line\">RCT_EXPORT_METHOD(getVersion:(RCTResponseSenderBlock)callback)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br><span class=\"line\">  callback(@[version]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS代码</span><br><span class=\"line\">ASHUtilManager.getVersion((version)=&gt; &#123;</span><br><span class=\"line\">\t\t\tthis.setState(&#123;</span><br><span class=\"line\">      \t\t\tversionText : &apos;V&apos; + version,</span><br><span class=\"line\">      \t\t&#125;);</span><br><span class=\"line\">\t\t&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong><em>PS：在RCT_EXPORT_METHOD宏括起来的方法都是异步执行的，如果方法里涉及到UI的操作，需要放到主线程里执行。RN中的桥接方式比JSBridge好用多了。</em></strong></p>\n<hr>\n<p>##ReactNative疑问整理：</p>\n<ul>\n<li>1.RN中没有VC的概念。它把view的生命周期事件封装在了view里面，而不是像iOS中用VC去管理view的生命周期。suoyi RN中的转场都只是view层的切换。</li>\n<li>2.this.setState()不生效。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-7cc66594fcce14d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\".png\"><br>react中的setState 是异步执行的，修改状态后并没有马上生效， setState 函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，就是设置状态成功之后执行的。所以正确做法。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-ebb3cdf71c9ac2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2016-11-08 下午5.23.52.png\"></li>\n</ul>\n<ul>\n<li>3.RN中ImageView加载网络图片，只做了内存缓存，而没有做磁盘缓存。<br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-4a1ccedc8b6ad87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"读取缓存 .png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1488967-dc36f197305d3aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加缓存.png\"><br>上面代码中_decodedImageCache对象的类型是NSCache。可以看出RN并没有做磁盘缓存。</li>\n<li>4.RN的网络请求没有被NSURLProtocol拦截。<br>在想怎么给RN中的图片做磁盘缓存的时候，调试的过程中发现RN中通过fetch发起的所有请求都没有被注册的NSURLProtocol拦截，那么问题就来了。没有被拦截，难道是RN的网络用了更底层的东西？</li>\n<li><p>5.关于动态下发代码，有两种做法。</p>\n<ul>\n<li>在程序一启动的时候，判断是否需要更新，然后去下载所有代码打包后zip包。之后需要显示RN的view的时候就可以去加载对应的view就可以了。</li>\n<li>一个页面对应一个url，通过这个url去请求单独页面的RN代码。这样可以做到每次进入的时候都会加载最新的页面。也就是像浏览器那样重新打开，重新去请求页面。</li>\n</ul>\n<p>但是最后还是选择了第一种方式，同时保留了第二种。在封装的vc上，提供自动刷新的属性。也支持每次进入页面都自动更新代码。</p>\n</li>\n</ul>\n<p>附录：<br>学习资料<br>[<a href=\"http://reactnative.cn/]\" target=\"_blank\" rel=\"noopener\">http://reactnative.cn/]</a><br>[<a href=\"https://github.com/reactnativecn/react-native-guide]\" target=\"_blank\" rel=\"noopener\">https://github.com/reactnativecn/react-native-guide]</a><br>[<a href=\"http://www.jianshu.com/p/7c43af022758]\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/7c43af022758]</a></p>"},{"layout":"post","title":"React Native 02：原生容器类封装","date":"2016-09-11T08:15:20.000Z","_content":"\n> RN中的JS部分的页面组件最终是在原生这边生成一个RCTRootView类的实例，且RN是在view层做的页面生命周期管理。好像不适合以单页面的形式接入到项目中，所以RN能不能像WebView那样的方式来使用？组件渲染有delegate回调给native？并且可以通过url来请求对应RN页面资源文件并且加载RN页面？能不能提供自动重新渲染页面的方法给原生调用？....\n\n## 思路\n\n### 1.继承RCTRootView\n\n### 2.数据通信\n\n**1.容器–>RN（RN页面要用的参数:如请求参数，埋点，自定义等等）**\n<!-- more -->\n * 初始化RN页面\n     容器内部初始化RN页面的时候允许传一个字典类型的自定义参数，它会在组件里根据key-value生成一些默认的props。RN也就可以通过this.props[key]这种形式获取。 \n\n```\n  // iOS\n  IMYRNView *rootView = [[IMYRNView alloc] initWithModuleName:@\"index.ios\" bundleName:@\"TestPage\" initialProperties:@{@\"arg\":@\"参数\"} componentDelegate:self];\n  // RN\n  componentDidMount(){\n         alert('arg'+this.props.arg);\n  }\n```\n\n  * 容器刷新RN页面方法         \n\n    ```\n       // iOS\n    - (void)reloadPage {\n      [self reloadPageWithProperties:nil];\n    }\n        - (void)reloadPageWithProperties:(NSDictionary *)params {\n      [self.bridge.eventDispatcher sendAppEventWithName:@\"reloadPageEvent\"\n                                                   body:params];\n    }\n      //RN\n      componentDidMount(){\n    \t    RNView.bridge_componentDidMount(){\n    \t\t    /*\n    \t\t\t  基础组件需要实现\n    \t\t\t  Native手动刷新RN页面，监听事件名称，实现函数\n    \t\t    */\t\t    \t\tDeviceEventEmitter.addListener('bridge_reloadPage',this.reloadPage.bind(this));\n    \t    }\n    }\n    reloadPage(args) {\n    \t    alert(args.arg1);\n    }\n    ```\n\n**2.RN->容器（桥接）**\n\n**3.RN->RN（RN->容器->RN)**\n\n**4.容器–>容器（直接传就行）**\n\n### 3.容器需要监听RN组件生命周期事件\n\n```\n// iOS\n#pragma mark - RN生命周期回调\nRCT_EXPORT_METHOD(bridge_componentWillMount)\n{\n\n    [NSObject imy_asyncMainBlock:^{\n        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];\n        if ([view.componentDelegate respondsToSelector:@selector(componentWillMount:)]) {\n            [view.componentDelegate componentWillMount:view];\n        }\n    }];\n}\nRCT_EXPORT_METHOD(bridge_componentDidMount)\n{\n    [NSObject imy_asyncMainBlock:^{\n        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];\n        if ([view.componentDelegate respondsToSelector:@selector(componentDidMount:)]) {\n            [view.componentDelegate componentDidMount:view];\n        }\n    }];\n}\n// RN\ncomponentDidMount(){\n\tRNView.bridge_componentDidMount(){\n\t}\n}\n```\n\n## 代码\n\nIMYRNView.h\n```\n#import \"RCTRootView.h\"\n#import \"RCTBridgeModule.h\"\n#import \"RCTLog.h\"\n\n@protocol RNViewComponentDelegate <NSObject>\n\n@optional\n- (void)componentWillMount:(RCTRootView *)rootView;\n- (void)componentDidMount:(RCTRootView *)rootView;\n\n- (void)rootView:(RCTRootView *)rootView componentWillReceiveProps:(id)nextProps;\n- (BOOL)rootView:(RCTRootView *)rootView shouldComponentUpdateNextProps:(id)nextProps nextState:(id)nextState;\n- (void)rootView:(RCTRootView *)rootView componentWillUpdateNextProps:(id)nextProps nextState:(id)nextState;\n- (void)rootView:(RCTRootView *)rootView componentDidUpdateNextProps:(id)nextProps nextState:(id)nextState;\n- (void)componentWillUnmount:(RCTRootView *)rootView;\n@end\n\n@interface IMYRNView : RCTRootView<RCTBridgeModule>\n\n\n- (instancetype)initWithModuleName:(NSString *)moduleName;\n\n- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName;\n\n- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params;\n\n- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params componentDelegate:(id<RNViewComponentDelegate>)componentDelegate;\n\n@property(nonatomic,weak) id<RNViewComponentDelegate> componentDelegate;\n\n///刷新\n- (void)reloadPage;\n- (void)reloadPageWithProperties:(NSDictionary *)params;\n\n@end\n```\nIMYRNViewController.h\n```\n#import <IMYPublic.h>\n\n@class IMYRNView;\n@interface IMYRNViewController : IMYPublicBaseViewController\n\n@property(nonatomic,copy)NSString *navTitle;\n@property(nonatomic,copy)NSString *bundleName;\n@property(nonatomic,copy)NSString *moduleName;\n@property(nonatomic,strong)NSDictionary *initialProperties;/**< RN要用的参数:请求参数，埋点，自定义... */\n@property(nonatomic,assign)BOOL isNeedReloadPage;\n@property(nonatomic,strong,readonly)IMYRNView *rnView;\n\n\n@end\n```\n","source":"_posts/rn-02.md","raw":"---\nlayout: post\ntitle: \"React Native 02：原生容器类封装\"\ndate: 2016-09-11 16:15:20\ncategories: \n- 技术\n- [技术, React Native]\ntags: \n- 技术\n- React Native\n---\n\n> RN中的JS部分的页面组件最终是在原生这边生成一个RCTRootView类的实例，且RN是在view层做的页面生命周期管理。好像不适合以单页面的形式接入到项目中，所以RN能不能像WebView那样的方式来使用？组件渲染有delegate回调给native？并且可以通过url来请求对应RN页面资源文件并且加载RN页面？能不能提供自动重新渲染页面的方法给原生调用？....\n\n## 思路\n\n### 1.继承RCTRootView\n\n### 2.数据通信\n\n**1.容器–>RN（RN页面要用的参数:如请求参数，埋点，自定义等等）**\n<!-- more -->\n * 初始化RN页面\n     容器内部初始化RN页面的时候允许传一个字典类型的自定义参数，它会在组件里根据key-value生成一些默认的props。RN也就可以通过this.props[key]这种形式获取。 \n\n```\n  // iOS\n  IMYRNView *rootView = [[IMYRNView alloc] initWithModuleName:@\"index.ios\" bundleName:@\"TestPage\" initialProperties:@{@\"arg\":@\"参数\"} componentDelegate:self];\n  // RN\n  componentDidMount(){\n         alert('arg'+this.props.arg);\n  }\n```\n\n  * 容器刷新RN页面方法         \n\n    ```\n       // iOS\n    - (void)reloadPage {\n      [self reloadPageWithProperties:nil];\n    }\n        - (void)reloadPageWithProperties:(NSDictionary *)params {\n      [self.bridge.eventDispatcher sendAppEventWithName:@\"reloadPageEvent\"\n                                                   body:params];\n    }\n      //RN\n      componentDidMount(){\n    \t    RNView.bridge_componentDidMount(){\n    \t\t    /*\n    \t\t\t  基础组件需要实现\n    \t\t\t  Native手动刷新RN页面，监听事件名称，实现函数\n    \t\t    */\t\t    \t\tDeviceEventEmitter.addListener('bridge_reloadPage',this.reloadPage.bind(this));\n    \t    }\n    }\n    reloadPage(args) {\n    \t    alert(args.arg1);\n    }\n    ```\n\n**2.RN->容器（桥接）**\n\n**3.RN->RN（RN->容器->RN)**\n\n**4.容器–>容器（直接传就行）**\n\n### 3.容器需要监听RN组件生命周期事件\n\n```\n// iOS\n#pragma mark - RN生命周期回调\nRCT_EXPORT_METHOD(bridge_componentWillMount)\n{\n\n    [NSObject imy_asyncMainBlock:^{\n        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];\n        if ([view.componentDelegate respondsToSelector:@selector(componentWillMount:)]) {\n            [view.componentDelegate componentWillMount:view];\n        }\n    }];\n}\nRCT_EXPORT_METHOD(bridge_componentDidMount)\n{\n    [NSObject imy_asyncMainBlock:^{\n        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];\n        if ([view.componentDelegate respondsToSelector:@selector(componentDidMount:)]) {\n            [view.componentDelegate componentDidMount:view];\n        }\n    }];\n}\n// RN\ncomponentDidMount(){\n\tRNView.bridge_componentDidMount(){\n\t}\n}\n```\n\n## 代码\n\nIMYRNView.h\n```\n#import \"RCTRootView.h\"\n#import \"RCTBridgeModule.h\"\n#import \"RCTLog.h\"\n\n@protocol RNViewComponentDelegate <NSObject>\n\n@optional\n- (void)componentWillMount:(RCTRootView *)rootView;\n- (void)componentDidMount:(RCTRootView *)rootView;\n\n- (void)rootView:(RCTRootView *)rootView componentWillReceiveProps:(id)nextProps;\n- (BOOL)rootView:(RCTRootView *)rootView shouldComponentUpdateNextProps:(id)nextProps nextState:(id)nextState;\n- (void)rootView:(RCTRootView *)rootView componentWillUpdateNextProps:(id)nextProps nextState:(id)nextState;\n- (void)rootView:(RCTRootView *)rootView componentDidUpdateNextProps:(id)nextProps nextState:(id)nextState;\n- (void)componentWillUnmount:(RCTRootView *)rootView;\n@end\n\n@interface IMYRNView : RCTRootView<RCTBridgeModule>\n\n\n- (instancetype)initWithModuleName:(NSString *)moduleName;\n\n- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName;\n\n- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params;\n\n- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params componentDelegate:(id<RNViewComponentDelegate>)componentDelegate;\n\n@property(nonatomic,weak) id<RNViewComponentDelegate> componentDelegate;\n\n///刷新\n- (void)reloadPage;\n- (void)reloadPageWithProperties:(NSDictionary *)params;\n\n@end\n```\nIMYRNViewController.h\n```\n#import <IMYPublic.h>\n\n@class IMYRNView;\n@interface IMYRNViewController : IMYPublicBaseViewController\n\n@property(nonatomic,copy)NSString *navTitle;\n@property(nonatomic,copy)NSString *bundleName;\n@property(nonatomic,copy)NSString *moduleName;\n@property(nonatomic,strong)NSDictionary *initialProperties;/**< RN要用的参数:请求参数，埋点，自定义... */\n@property(nonatomic,assign)BOOL isNeedReloadPage;\n@property(nonatomic,strong,readonly)IMYRNView *rnView;\n\n\n@end\n```\n","slug":"rn-02","published":1,"updated":"2019-12-20T06:08:22.051Z","comments":1,"photos":[],"link":"","_id":"ck4dsux3f0017odnq6rg0zbeh","content":"<blockquote>\n<p>RN中的JS部分的页面组件最终是在原生这边生成一个RCTRootView类的实例，且RN是在view层做的页面生命周期管理。好像不适合以单页面的形式接入到项目中，所以RN能不能像WebView那样的方式来使用？组件渲染有delegate回调给native？并且可以通过url来请求对应RN页面资源文件并且加载RN页面？能不能提供自动重新渲染页面的方法给原生调用？….</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"1-继承RCTRootView\"><a href=\"#1-继承RCTRootView\" class=\"headerlink\" title=\"1.继承RCTRootView\"></a>1.继承RCTRootView</h3><h3 id=\"2-数据通信\"><a href=\"#2-数据通信\" class=\"headerlink\" title=\"2.数据通信\"></a>2.数据通信</h3><p><strong>1.容器–&gt;RN（RN页面要用的参数:如请求参数，埋点，自定义等等）</strong><br><a id=\"more\"></a></p>\n<ul>\n<li>初始化RN页面<br>  容器内部初始化RN页面的时候允许传一个字典类型的自定义参数，它会在组件里根据key-value生成一些默认的props。RN也就可以通过this.props[key]这种形式获取。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iOS</span><br><span class=\"line\">IMYRNView *rootView = [[IMYRNView alloc] initWithModuleName:@&quot;index.ios&quot; bundleName:@&quot;TestPage&quot; initialProperties:@&#123;@&quot;arg&quot;:@&quot;参数&quot;&#125; componentDelegate:self];</span><br><span class=\"line\">// RN</span><br><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">       alert(&apos;arg&apos;+this.props.arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>容器刷新RN页面方法         </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   // iOS</span><br><span class=\"line\">- (void)reloadPage &#123;</span><br><span class=\"line\">  [self reloadPageWithProperties:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    - (void)reloadPageWithProperties:(NSDictionary *)params &#123;</span><br><span class=\"line\">  [self.bridge.eventDispatcher sendAppEventWithName:@&quot;reloadPageEvent&quot;</span><br><span class=\"line\">                                               body:params];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  //RN</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">\t    RNView.bridge_componentDidMount()&#123;</span><br><span class=\"line\">\t\t    /*</span><br><span class=\"line\">\t\t\t  基础组件需要实现</span><br><span class=\"line\">\t\t\t  Native手动刷新RN页面，监听事件名称，实现函数</span><br><span class=\"line\">\t\t    */\t\t    \t\tDeviceEventEmitter.addListener(&apos;bridge_reloadPage&apos;,this.reloadPage.bind(this));</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">reloadPage(args) &#123;</span><br><span class=\"line\">\t    alert(args.arg1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>2.RN-&gt;容器（桥接）</strong></p>\n<p><strong>3.RN-&gt;RN（RN-&gt;容器-&gt;RN)</strong></p>\n<p><strong>4.容器–&gt;容器（直接传就行）</strong></p>\n<h3 id=\"3-容器需要监听RN组件生命周期事件\"><a href=\"#3-容器需要监听RN组件生命周期事件\" class=\"headerlink\" title=\"3.容器需要监听RN组件生命周期事件\"></a>3.容器需要监听RN组件生命周期事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iOS</span><br><span class=\"line\">#pragma mark - RN生命周期回调</span><br><span class=\"line\">RCT_EXPORT_METHOD(bridge_componentWillMount)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSObject imy_asyncMainBlock:^&#123;</span><br><span class=\"line\">        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];</span><br><span class=\"line\">        if ([view.componentDelegate respondsToSelector:@selector(componentWillMount:)]) &#123;</span><br><span class=\"line\">            [view.componentDelegate componentWillMount:view];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">RCT_EXPORT_METHOD(bridge_componentDidMount)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [NSObject imy_asyncMainBlock:^&#123;</span><br><span class=\"line\">        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];</span><br><span class=\"line\">        if ([view.componentDelegate respondsToSelector:@selector(componentDidMount:)]) &#123;</span><br><span class=\"line\">            [view.componentDelegate componentDidMount:view];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// RN</span><br><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">\tRNView.bridge_componentDidMount()&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>IMYRNView.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;RCTRootView.h&quot;</span><br><span class=\"line\">#import &quot;RCTBridgeModule.h&quot;</span><br><span class=\"line\">#import &quot;RCTLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@protocol RNViewComponentDelegate &lt;NSObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@optional</span><br><span class=\"line\">- (void)componentWillMount:(RCTRootView *)rootView;</span><br><span class=\"line\">- (void)componentDidMount:(RCTRootView *)rootView;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)rootView:(RCTRootView *)rootView componentWillReceiveProps:(id)nextProps;</span><br><span class=\"line\">- (BOOL)rootView:(RCTRootView *)rootView shouldComponentUpdateNextProps:(id)nextProps nextState:(id)nextState;</span><br><span class=\"line\">- (void)rootView:(RCTRootView *)rootView componentWillUpdateNextProps:(id)nextProps nextState:(id)nextState;</span><br><span class=\"line\">- (void)rootView:(RCTRootView *)rootView componentDidUpdateNextProps:(id)nextProps nextState:(id)nextState;</span><br><span class=\"line\">- (void)componentWillUnmount:(RCTRootView *)rootView;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface IMYRNView : RCTRootView&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params componentDelegate:(id&lt;RNViewComponentDelegate&gt;)componentDelegate;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,weak) id&lt;RNViewComponentDelegate&gt; componentDelegate;</span><br><span class=\"line\"></span><br><span class=\"line\">///刷新</span><br><span class=\"line\">- (void)reloadPage;</span><br><span class=\"line\">- (void)reloadPageWithProperties:(NSDictionary *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>IMYRNViewController.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;IMYPublic.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@class IMYRNView;</span><br><span class=\"line\">@interface IMYRNViewController : IMYPublicBaseViewController</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,copy)NSString *navTitle;</span><br><span class=\"line\">@property(nonatomic,copy)NSString *bundleName;</span><br><span class=\"line\">@property(nonatomic,copy)NSString *moduleName;</span><br><span class=\"line\">@property(nonatomic,strong)NSDictionary *initialProperties;/**&lt; RN要用的参数:请求参数，埋点，自定义... */</span><br><span class=\"line\">@property(nonatomic,assign)BOOL isNeedReloadPage;</span><br><span class=\"line\">@property(nonatomic,strong,readonly)IMYRNView *rnView;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>RN中的JS部分的页面组件最终是在原生这边生成一个RCTRootView类的实例，且RN是在view层做的页面生命周期管理。好像不适合以单页面的形式接入到项目中，所以RN能不能像WebView那样的方式来使用？组件渲染有delegate回调给native？并且可以通过url来请求对应RN页面资源文件并且加载RN页面？能不能提供自动重新渲染页面的方法给原生调用？….</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"1-继承RCTRootView\"><a href=\"#1-继承RCTRootView\" class=\"headerlink\" title=\"1.继承RCTRootView\"></a>1.继承RCTRootView</h3><h3 id=\"2-数据通信\"><a href=\"#2-数据通信\" class=\"headerlink\" title=\"2.数据通信\"></a>2.数据通信</h3><p><strong>1.容器–&gt;RN（RN页面要用的参数:如请求参数，埋点，自定义等等）</strong><br>","more":"</p>\n<ul>\n<li>初始化RN页面<br>  容器内部初始化RN页面的时候允许传一个字典类型的自定义参数，它会在组件里根据key-value生成一些默认的props。RN也就可以通过this.props[key]这种形式获取。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iOS</span><br><span class=\"line\">IMYRNView *rootView = [[IMYRNView alloc] initWithModuleName:@&quot;index.ios&quot; bundleName:@&quot;TestPage&quot; initialProperties:@&#123;@&quot;arg&quot;:@&quot;参数&quot;&#125; componentDelegate:self];</span><br><span class=\"line\">// RN</span><br><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">       alert(&apos;arg&apos;+this.props.arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>容器刷新RN页面方法         </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   // iOS</span><br><span class=\"line\">- (void)reloadPage &#123;</span><br><span class=\"line\">  [self reloadPageWithProperties:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    - (void)reloadPageWithProperties:(NSDictionary *)params &#123;</span><br><span class=\"line\">  [self.bridge.eventDispatcher sendAppEventWithName:@&quot;reloadPageEvent&quot;</span><br><span class=\"line\">                                               body:params];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  //RN</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">\t    RNView.bridge_componentDidMount()&#123;</span><br><span class=\"line\">\t\t    /*</span><br><span class=\"line\">\t\t\t  基础组件需要实现</span><br><span class=\"line\">\t\t\t  Native手动刷新RN页面，监听事件名称，实现函数</span><br><span class=\"line\">\t\t    */\t\t    \t\tDeviceEventEmitter.addListener(&apos;bridge_reloadPage&apos;,this.reloadPage.bind(this));</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">reloadPage(args) &#123;</span><br><span class=\"line\">\t    alert(args.arg1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>2.RN-&gt;容器（桥接）</strong></p>\n<p><strong>3.RN-&gt;RN（RN-&gt;容器-&gt;RN)</strong></p>\n<p><strong>4.容器–&gt;容器（直接传就行）</strong></p>\n<h3 id=\"3-容器需要监听RN组件生命周期事件\"><a href=\"#3-容器需要监听RN组件生命周期事件\" class=\"headerlink\" title=\"3.容器需要监听RN组件生命周期事件\"></a>3.容器需要监听RN组件生命周期事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iOS</span><br><span class=\"line\">#pragma mark - RN生命周期回调</span><br><span class=\"line\">RCT_EXPORT_METHOD(bridge_componentWillMount)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSObject imy_asyncMainBlock:^&#123;</span><br><span class=\"line\">        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];</span><br><span class=\"line\">        if ([view.componentDelegate respondsToSelector:@selector(componentWillMount:)]) &#123;</span><br><span class=\"line\">            [view.componentDelegate componentWillMount:view];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">RCT_EXPORT_METHOD(bridge_componentDidMount)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [NSObject imy_asyncMainBlock:^&#123;</span><br><span class=\"line\">        IMYRNView *view = (IMYRNView *)[[UIViewController imy_currentViewControlloer] view];</span><br><span class=\"line\">        if ([view.componentDelegate respondsToSelector:@selector(componentDidMount:)]) &#123;</span><br><span class=\"line\">            [view.componentDelegate componentDidMount:view];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// RN</span><br><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">\tRNView.bridge_componentDidMount()&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>IMYRNView.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;RCTRootView.h&quot;</span><br><span class=\"line\">#import &quot;RCTBridgeModule.h&quot;</span><br><span class=\"line\">#import &quot;RCTLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@protocol RNViewComponentDelegate &lt;NSObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@optional</span><br><span class=\"line\">- (void)componentWillMount:(RCTRootView *)rootView;</span><br><span class=\"line\">- (void)componentDidMount:(RCTRootView *)rootView;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)rootView:(RCTRootView *)rootView componentWillReceiveProps:(id)nextProps;</span><br><span class=\"line\">- (BOOL)rootView:(RCTRootView *)rootView shouldComponentUpdateNextProps:(id)nextProps nextState:(id)nextState;</span><br><span class=\"line\">- (void)rootView:(RCTRootView *)rootView componentWillUpdateNextProps:(id)nextProps nextState:(id)nextState;</span><br><span class=\"line\">- (void)rootView:(RCTRootView *)rootView componentDidUpdateNextProps:(id)nextProps nextState:(id)nextState;</span><br><span class=\"line\">- (void)componentWillUnmount:(RCTRootView *)rootView;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface IMYRNView : RCTRootView&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithModuleName:(NSString *)moduleName bundleName:(NSString *)bundleName initialProperties:(NSDictionary *)params componentDelegate:(id&lt;RNViewComponentDelegate&gt;)componentDelegate;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,weak) id&lt;RNViewComponentDelegate&gt; componentDelegate;</span><br><span class=\"line\"></span><br><span class=\"line\">///刷新</span><br><span class=\"line\">- (void)reloadPage;</span><br><span class=\"line\">- (void)reloadPageWithProperties:(NSDictionary *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>IMYRNViewController.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;IMYPublic.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@class IMYRNView;</span><br><span class=\"line\">@interface IMYRNViewController : IMYPublicBaseViewController</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,copy)NSString *navTitle;</span><br><span class=\"line\">@property(nonatomic,copy)NSString *bundleName;</span><br><span class=\"line\">@property(nonatomic,copy)NSString *moduleName;</span><br><span class=\"line\">@property(nonatomic,strong)NSDictionary *initialProperties;/**&lt; RN要用的参数:请求参数，埋点，自定义... */</span><br><span class=\"line\">@property(nonatomic,assign)BOOL isNeedReloadPage;</span><br><span class=\"line\">@property(nonatomic,strong,readonly)IMYRNView *rnView;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4dsux37000oodnq7rfbgy6g","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3f0016odnql35ftgtd"},{"post_id":"ck4dsux37000oodnq7rfbgy6g","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3g0019odnqpg12rbts"},{"post_id":"ck4dsux37000oodnq7rfbgy6g","category_id":"ck4dsux38000qodnq5rftugde","_id":"ck4dsux3h001dodnqju4awv47"},{"post_id":"ck4dsux2o0000odnqx2wdm4d9","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3i001fodnq4z1bkssk"},{"post_id":"ck4dsux2o0000odnqx2wdm4d9","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3i001jodnq74bo73n7"},{"post_id":"ck4dsux2o0000odnqx2wdm4d9","category_id":"ck4dsux38000qodnq5rftugde","_id":"ck4dsux3j001kodnq9fgvm0tc"},{"post_id":"ck4dsux39000sodnq188i83yi","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3j001modnqmmiw2e2v"},{"post_id":"ck4dsux39000sodnq188i83yi","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3k001podnqqiez3x37"},{"post_id":"ck4dsux39000sodnq188i83yi","category_id":"ck4dsux38000qodnq5rftugde","_id":"ck4dsux3k001sodnqt4nz8k54"},{"post_id":"ck4dsux2z000codnq9cdde1ww","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3l001uodnqpwledlu5"},{"post_id":"ck4dsux2z000codnq9cdde1ww","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3l001wodnqy7xycflh"},{"post_id":"ck4dsux2z000codnq9cdde1ww","category_id":"ck4dsux3b000wodnqto9f2ytb","_id":"ck4dsux3m001zodnq7s99bpq7"},{"post_id":"ck4dsux30000dodnqyl9tioc7","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3m0022odnqm7r1xmw8"},{"post_id":"ck4dsux30000dodnqyl9tioc7","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3n0024odnqyvknp4m2"},{"post_id":"ck4dsux30000dodnqyl9tioc7","category_id":"ck4dsux3b000wodnqto9f2ytb","_id":"ck4dsux3n0025odnqbru2lbbx"},{"post_id":"ck4dsux33000godnqj0mwrf9q","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3o0029odnqwuazq24u"},{"post_id":"ck4dsux33000godnqj0mwrf9q","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3o002bodnqz7o3ya02"},{"post_id":"ck4dsux33000godnqj0mwrf9q","category_id":"ck4dsux38000qodnq5rftugde","_id":"ck4dsux3p002eodnqqk6670o7"},{"post_id":"ck4dsux2w0008odnqdzxsgh4y","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3p002godnqjow3orjg"},{"post_id":"ck4dsux2w0008odnqdzxsgh4y","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3q002kodnqep5pvf4v"},{"post_id":"ck4dsux2w0008odnqdzxsgh4y","category_id":"ck4dsux3b000wodnqto9f2ytb","_id":"ck4dsux3q002modnqrm62d0h1"},{"post_id":"ck4dsux34000iodnqiunw3bqf","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3r002qodnq422xy3ks"},{"post_id":"ck4dsux34000iodnqiunw3bqf","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3r002sodnqy2dq89ek"},{"post_id":"ck4dsux34000iodnqiunw3bqf","category_id":"ck4dsux38000qodnq5rftugde","_id":"ck4dsux3r002wodnqn5j1kwsx"},{"post_id":"ck4dsux36000modnqpf1i755h","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3s002yodnq2unhl4dl"},{"post_id":"ck4dsux36000modnqpf1i755h","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3s0032odnqszc1a1c2"},{"post_id":"ck4dsux36000modnqpf1i755h","category_id":"ck4dsux38000qodnq5rftugde","_id":"ck4dsux3u0034odnqr019kcys"},{"post_id":"ck4dsux2y0009odnqn4t3y3je","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3v0036odnqkq0hs4yp"},{"post_id":"ck4dsux2y0009odnqn4t3y3je","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3v0038odnqyzonvh2r"},{"post_id":"ck4dsux2y0009odnqn4t3y3je","category_id":"ck4dsux3m0020odnqge2onnvj","_id":"ck4dsux3w003aodnqduma999y"},{"post_id":"ck4dsux3a000uodnq1xbt6x9t","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3x003dodnqqco3d2hk"},{"post_id":"ck4dsux3a000uodnq1xbt6x9t","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3x003fodnqhqav5djl"},{"post_id":"ck4dsux3a000uodnq1xbt6x9t","category_id":"ck4dsux3n0026odnqxb2xazv8","_id":"ck4dsux3y003iodnqthay0ya1"},{"post_id":"ck4dsux3b000xodnqatbbboj8","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3y003jodnqb439crsp"},{"post_id":"ck4dsux3b000xodnqatbbboj8","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3y003modnqsk8e56wk"},{"post_id":"ck4dsux3b000xodnqatbbboj8","category_id":"ck4dsux3n0026odnqxb2xazv8","_id":"ck4dsux3y003oodnqcaitmxqo"},{"post_id":"ck4dsux3d0010odnqbbn5mkvz","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3z003qodnqy0x5i2cl"},{"post_id":"ck4dsux3d0010odnqbbn5mkvz","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3z003sodnq553oklj9"},{"post_id":"ck4dsux3d0010odnqbbn5mkvz","category_id":"ck4dsux3p002iodnq3y1kahgg","_id":"ck4dsux3z003uodnq07rex0tv"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3z003vodnqh9g1ciy0"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","category_id":"ck4dsux2z000bodnqhnky1zyp","_id":"ck4dsux3z003wodnqhlvr4xt7"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","category_id":"ck4dsux3e0013odnq6n8g2f50","_id":"ck4dsux3z003xodnqp2c09hgh"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","category_id":"ck4dsux3q002oodnq3dhzr9vc","_id":"ck4dsux3z003yodnqigd2kd7m"},{"post_id":"ck4dsux3e0012odnquzqw55wl","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3z003zodnqksd5e37m"},{"post_id":"ck4dsux3e0012odnquzqw55wl","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3z0040odnqd6yu5zyk"},{"post_id":"ck4dsux3e0012odnquzqw55wl","category_id":"ck4dsux3p002iodnq3y1kahgg","_id":"ck4dsux3z0041odnq4mqykeob"},{"post_id":"ck4dsux3f0017odnq6rg0zbeh","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3z0042odnq77qxf6ej"},{"post_id":"ck4dsux3f0017odnq6rg0zbeh","category_id":"ck4dsux2v0006odnqmarwvtus","_id":"ck4dsux3z0043odnq3jstip3x"},{"post_id":"ck4dsux3f0017odnq6rg0zbeh","category_id":"ck4dsux3p002iodnq3y1kahgg","_id":"ck4dsux3z0044odnqk6sltww9"}],"PostTag":[{"post_id":"ck4dsux2o0000odnqx2wdm4d9","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux34000hodnqwxhddjah"},{"post_id":"ck4dsux2o0000odnqx2wdm4d9","tag_id":"ck4dsux2z000aodnqptbdpzc2","_id":"ck4dsux35000jodnq194uolkn"},{"post_id":"ck4dsux33000godnqj0mwrf9q","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux37000nodnq0e4u2psw"},{"post_id":"ck4dsux33000godnqj0mwrf9q","tag_id":"ck4dsux2z000aodnqptbdpzc2","_id":"ck4dsux38000podnqqudsben8"},{"post_id":"ck4dsux36000modnqpf1i755h","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3a000todnqrgz50l2d"},{"post_id":"ck4dsux36000modnqpf1i755h","tag_id":"ck4dsux2z000aodnqptbdpzc2","_id":"ck4dsux3b000vodnqdzjt5dm0"},{"post_id":"ck4dsux37000oodnq7rfbgy6g","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3c000zodnqr49moprc"},{"post_id":"ck4dsux37000oodnq7rfbgy6g","tag_id":"ck4dsux2z000aodnqptbdpzc2","_id":"ck4dsux3d0011odnqsq73ze3h"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","tag_id":"ck4dsux31000eodnqk9cldcsc","_id":"ck4dsux3f0015odnqrx6gnfnt"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","tag_id":"ck4dsux36000lodnqsh8u6va0","_id":"ck4dsux3g0018odnqmgygube4"},{"post_id":"ck4dsux2u0005odnqz3hjrn3o","tag_id":"ck4dsux39000rodnq36y8blyl","_id":"ck4dsux3g001aodnq7e520q4q"},{"post_id":"ck4dsux2w0008odnqdzxsgh4y","tag_id":"ck4dsux31000eodnqk9cldcsc","_id":"ck4dsux3i001eodnqbkdewuh9"},{"post_id":"ck4dsux2w0008odnqdzxsgh4y","tag_id":"ck4dsux3e0014odnqkub7rnd3","_id":"ck4dsux3i001godnq2lu35c5k"},{"post_id":"ck4dsux2y0009odnqn4t3y3je","tag_id":"ck4dsux31000eodnqk9cldcsc","_id":"ck4dsux3k001oodnqs22htn9x"},{"post_id":"ck4dsux2y0009odnqn4t3y3je","tag_id":"ck4dsux3i001iodnq8is4q1n7","_id":"ck4dsux3k001rodnq0x1ju5os"},{"post_id":"ck4dsux2z000codnq9cdde1ww","tag_id":"ck4dsux31000eodnqk9cldcsc","_id":"ck4dsux3m001yodnq6yimv3lr"},{"post_id":"ck4dsux2z000codnq9cdde1ww","tag_id":"ck4dsux3e0014odnqkub7rnd3","_id":"ck4dsux3m0021odnqnj9lhncf"},{"post_id":"ck4dsux30000dodnqyl9tioc7","tag_id":"ck4dsux31000eodnqk9cldcsc","_id":"ck4dsux3o0028odnqv498s6c8"},{"post_id":"ck4dsux30000dodnqyl9tioc7","tag_id":"ck4dsux3e0014odnqkub7rnd3","_id":"ck4dsux3o002aodnqoytzqucc"},{"post_id":"ck4dsux34000iodnqiunw3bqf","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3p002fodnqo5buawil"},{"post_id":"ck4dsux34000iodnqiunw3bqf","tag_id":"ck4dsux2z000aodnqptbdpzc2","_id":"ck4dsux3p002hodnq7r4xzbxt"},{"post_id":"ck4dsux34000iodnqiunw3bqf","tag_id":"ck4dsux3n0027odnq2v7xvoeq","_id":"ck4dsux3q002lodnqsp6waudg"},{"post_id":"ck4dsux39000sodnq188i83yi","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3q002nodnqjy1wt2hz"},{"post_id":"ck4dsux39000sodnq188i83yi","tag_id":"ck4dsux2z000aodnqptbdpzc2","_id":"ck4dsux3r002rodnq0vuoyn2m"},{"post_id":"ck4dsux39000sodnq188i83yi","tag_id":"ck4dsux3n0027odnq2v7xvoeq","_id":"ck4dsux3r002todnqqazavfm4"},{"post_id":"ck4dsux3a000uodnq1xbt6x9t","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3s002xodnqpcpbfynm"},{"post_id":"ck4dsux3a000uodnq1xbt6x9t","tag_id":"ck4dsux3p002jodnqtu14ok8l","_id":"ck4dsux3s002zodnq5l2egwa6"},{"post_id":"ck4dsux3a000uodnq1xbt6x9t","tag_id":"ck4dsux3q002podnq2p949x5w","_id":"ck4dsux3u0033odnqv81hmsm5"},{"post_id":"ck4dsux3b000xodnqatbbboj8","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3v0037odnq4etpjhla"},{"post_id":"ck4dsux3b000xodnqatbbboj8","tag_id":"ck4dsux3p002jodnqtu14ok8l","_id":"ck4dsux3w0039odnq8ibh86dg"},{"post_id":"ck4dsux3b000xodnqatbbboj8","tag_id":"ck4dsux3q002podnq2p949x5w","_id":"ck4dsux3x003codnq4mbl9wqx"},{"post_id":"ck4dsux3d0010odnqbbn5mkvz","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3x003eodnqrasct6zv"},{"post_id":"ck4dsux3d0010odnqbbn5mkvz","tag_id":"ck4dsux3v0035odnqo0yvyuyr","_id":"ck4dsux3x003hodnq70c2naiw"},{"post_id":"ck4dsux3e0012odnquzqw55wl","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3y003lodnqfo4knpu7"},{"post_id":"ck4dsux3e0012odnquzqw55wl","tag_id":"ck4dsux3q002podnq2p949x5w","_id":"ck4dsux3y003nodnqixmkbpq5"},{"post_id":"ck4dsux3e0012odnquzqw55wl","tag_id":"ck4dsux3v0035odnqo0yvyuyr","_id":"ck4dsux3z003podnqsdenj5p6"},{"post_id":"ck4dsux3f0017odnq6rg0zbeh","tag_id":"ck4dsux2u0004odnqbc3johf6","_id":"ck4dsux3z003rodnqo5mjk98t"},{"post_id":"ck4dsux3f0017odnq6rg0zbeh","tag_id":"ck4dsux3v0035odnqo0yvyuyr","_id":"ck4dsux3z003todnq7xckckli"}],"Tag":[{"name":"技术","_id":"ck4dsux2u0004odnqbc3johf6"},{"name":"iOS","_id":"ck4dsux2z000aodnqptbdpzc2"},{"name":"教程","_id":"ck4dsux31000eodnqk9cldcsc"},{"name":"工具","_id":"ck4dsux36000lodnqsh8u6va0"},{"name":"VPS","_id":"ck4dsux39000rodnq36y8blyl"},{"name":"hexo","_id":"ck4dsux3e0014odnqkub7rnd3"},{"name":"Jenkins","_id":"ck4dsux3i001iodnq8is4q1n7"},{"name":"日常","_id":"ck4dsux3n0027odnq2v7xvoeq"},{"name":"OC","_id":"ck4dsux3p002jodnqtu14ok8l"},{"name":"笔记","_id":"ck4dsux3q002podnq2p949x5w"},{"name":"React Native","_id":"ck4dsux3v0035odnqo0yvyuyr"}]}}