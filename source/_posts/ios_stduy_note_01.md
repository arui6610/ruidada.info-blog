---
layout: post
title: "学习笔记01：OC的对象模型"
date: 2015-05-10 13:36
categories: 
- 技术
- [技术, OC]
tags: 
- 技术
- OC
- 笔记
---

> OC作为一门面向对象语言。不管是学习阶段还是工作阶段。每天都是在和各种各样的类以及对象打交道。
>
> 什么是类？什么是对象？这是一个最初的问题。

## 1.什么是类？什么是对象？
对象是对客观事物的抽象，类是对对象的抽象，类是一种抽象的数据类。它们的关系是对象是类的实例，类是对象的模板。
哈。绕口令么。这个解释太官方。

关于类。我自己理解为类就是你所能看到的一切事物的特征和行为的集合的一个抽象。而对象则是某一个类（抽象）的具体实现。
<!-- more -->

## 2.对象是怎么被创建出来的？
栗如创建一个叫zs的Person实例：Person *zs = [Person alloc] init];
在OC中这段代码做了些什么？

首先有了一个Person类。调用了+alloc方法然后调用了+init方法。创建了一个Person实例。接下来用了一个Person类型的指针引用这个实例。

  * 那+alloc方法里面又做了些什么？
    * 为该对象分配足够的内存 
    * 将该新对象的引用计数 (Retain Count) 设置成 1。
    * 将该新对象的 isa指针指向它的类。
    * 将该新对象的所有其它成员变量的值设置成零。
  * +init方法又做了些什么？
    * init方法也叫初始化方法，字面理解就是初始化一些成员变量。比如我们想要zs对象在创建出来，身高就为180cm，体重60kg，战斗力1000+等等这些属性值。所以我们可以重载init方法。在这里面设置对象的一些成员变量的初始值。


## 3.什么是isa指针？什么是superclass指针？为什么类又叫类对象？既然对象是由它的类创建出来的，那么类由是由谁创建出来的呢？
这一串的问题。在一开始的时候困惑了我很长的一段是时间。其实这些问题最终都指向一个答案，也就是类和对象的内存结构。

![1413628797629491.png](http://upload-images.jianshu.io/upload_images/1488967-42b2c729e2ccb283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

OC是C的一个超集。在C中能够描述一组不同数据类型的变量的集合也就是结构体。所以在OC中不管是对象还是类。本质也就是结构体。那就容易理解了。isa指针就相当于一个标识，标识某个对象或某个类所属的类型。OC既然是一门OOP的语言。那么superclass也就是表示当前类的继承结构。所以在类和元类中，都具有isa和superclass这两个成员变量。而对象只有isa。那么就能解释了。通过类创建了对象，对象的isa指针指向的类。而类是由元类创建出来的，所以类的isa指针指向元类。那么superclass指针呢。因为OC不支持多继承，只能单继承，那么superclass指针理解起来就比较容易了。
到了这里，脑子里又冒出来一个疑问。这种类和对象的isa指针总不能无限制的下去吧，总归是要形成一个闭环或者指向一个创世类吧？所以答案也就是图中最顶层的根类（RootClass）以及根元类的isa和superclass指针的指向了。原来所有的元类的isa指针都指向根元类，而根类的isa指针同样指向根元类，最终根元类的superclass指针指向的是元类。这样就很好的形成了一个闭环。
这样也就顺带解决了我另外的一个疑问，OC是在运行时动态检测对象的所属的真实类型。那么它是怎么检测的呢？答案也就是上面那幅图。对象在创建的时候就已经初始化好了isa指针。那么运行时也就是根据这个isa指针找到它所属的真实类型。

## 4.类主要是由成员变量和方法构成，那么方法又是什么鬼？为什么对象方法只能由对象调用？类方法只能由类来调用？为毛类方法不能由类调用呢？

好吧，又是一长串问题。答案的是OC中的方法调用。首先还是先上图，更加直观的了解类和对象的内存结构。
![屏幕快照 2016-06-20 下午1.14.11.png](http://upload-images.jianshu.io/upload_images/1488967-d99981018e89101a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上图是类的内存结构，最主要的是ivars，methodLists以及cache这三张表。简单的理解就是ivars存储的是该类所有的成员变量。methodLists存储的是该类的所有的对象方法（又或者类对象方法）。cache存储的是methodLists中执行过的方法的方法缓存。
类结构中methodLists表中存储的是对象方法。元类的methodLists存储的是类方法。例如对象方法的调用步骤是，首先根据isa指针确定该对象所属的真实类型，找到该类之后，首先会去cache表中查找有没有这个方法缓存。如果没有，才去methodLists表中查找方法，如果找到了，执行该方法，并将该方法添加进cache表中。如果没有找到就会沿着superclass指针去父类中按步骤依次查找。对于对象方法，以上的这些执行步骤都是在类的结构中去查找的。而类方法却是根据类的isa指针去元类的结构体中执行的。所以这也就能解释，为什么对象方法只能由对象来调用，而类方法只能由类来调用了。

